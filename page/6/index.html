<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/05/Python Data Analysis/第二章：NumPy数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/Python Data Analysis/第二章：NumPy数组/" itemprop="url">第二章：NumPy数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-05T18:44:53+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-Data-Analysis/" itemprop="url" rel="index">
                    <span itemprop="name">Python Data Analysis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="2-1-NumPy数组对象"><a href="#2-1-NumPy数组对象" class="headerlink" title="2.1 NumPy数组对象"></a>2.1 NumPy数组对象</h3><p>NumPy中的多维数组数组称为ndarray， 它有两个组成部分。</p>
<ul>
<li>数据本身</li>
<li>描述数据的元数据</li>
</ul>
<p>在数组的处理过程中，原始数据不受影响，变化的只是元数据而已。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ndarray 与 arange()</span><br><span class="line"></span><br><span class="line">用arange()函数来生成的数组是一维数组，而ndarray则可以具有一个以上的维度。</span><br></pre></td></tr></table></figure>

<h4 id="NumPy数组的优势："><a href="#NumPy数组的优势：" class="headerlink" title="NumPy数组的优势："></a>NumPy数组的优势：</h4><p><strong>NumPy数组通常是由相同种类的元素组成的，即数组中的数据项的数据类型必须一致。</strong></p>
<ul>
<li>NumPy数组元素类型一致<ul>
<li>好处：由于知道数组元素的类型相同，所以能轻松确定存储数组所需空间的大小。</li>
</ul>
</li>
<li>NumPy数组能够运用向量化运算来处理整个数组<ul>
<li>而完成同样的任务，Python列表则通常必须借助循环语句遍历列表，并对逐个元素进行相应的处理。</li>
</ul>
</li>
<li>NumPy使用了优化过的C API，所以运算速度格外的快。</li>
</ul>
<p><code>In : a = arange(5)</code>                                                           </p>
<p><code>In : a.dtype</code>                                                                 </p>
<p><code>Out: dtype(&#39;int64&#39;)</code></p>
<p>此处使用了arange（）来建立数组，并且查看了该数组的数据类型。</p>
<p><code>In: a</code>                                                                       </p>
<p><code>Out: array([0, 1, 2, 3, 4])</code></p>
<p><code>In: a.shape</code>                                                                 </p>
<p><code>Out: (5,)</code></p>
<p>如你所见，该向量有5个元素，它们的值分别是从0到4。</p>
<p>该数组的shape属性是一个元组（就本例而言，这是一个单元素元组），存放的是数组在每一个维度的长度。</p>
<h3 id="2-2-创建多维数组"><a href="#2-2-创建多维数组" class="headerlink" title="2.2 创建多维数组"></a>2.2 创建多维数组</h3><ol>
<li><p>创建多维数组，代码如下：</p>
<p><code>In: m = array([arange(2), arange(2)])</code>                                       </p>
<p><code>In: m</code>                                                                       </p>
<p><code>Out:</code> </p>
<p><code>array([[0, 1],</code></p>
<p>​              <code>[0, 1]])</code></p>
</li>
<li><p>显示该数组的形状，代码如下：</p>
<p><code>In: m.shape</code>                                                                 </p>
<p><code>Out: (2, 2)</code></p>
</li>
</ol>
<p>创建一个 ndarray 只需调用 NumPy 的 array 函数即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(object, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">object</td>
<td align="left">数组或嵌套的数列</td>
</tr>
<tr>
<td align="left">dtype</td>
<td align="left">数组元素的数据类型，可选</td>
</tr>
<tr>
<td align="left">copy</td>
<td align="left">对象是否需要复制，可选</td>
</tr>
<tr>
<td align="left">order</td>
<td align="left">创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</td>
</tr>
<tr>
<td align="left">subok</td>
<td align="left">默认返回一个与基类类型一致的数组</td>
</tr>
<tr>
<td align="left">ndmin</td>
<td align="left">指定生成数组的最小维度</td>
</tr>
</tbody></table>
<h3 id="2-3-选择NumPy数组元素"><a href="#2-3-选择NumPy数组元素" class="headerlink" title="2.3 选择NumPy数组元素"></a>2.3 选择NumPy数组元素</h3><p><code>In: a = array([[1, 2], [3, 4]])</code>                                             </p>
<p><code>In: a</code>                                                                       </p>
<p><code>Out:</code> </p>
<p><code>array([[1, 2],</code></p>
<p>​              <code>[3, 4]])</code></p>
<p>上面的矩阵是通过向array()函数传递一个由列表组成的列表得到的。</p>
<p>下面，通过下标来逐个选择矩阵的各个元素。</p>
<p><code>In: a[0, 0]</code>                                                                 </p>
<p><code>Out: 1</code></p>
<p><code>In: a[0, 1]</code>                                                                 </p>
<p><code>Out: 2</code>                                                           </p>
<p><code>In : a[1, 0]</code>                                                                 </p>
<p><code>Out: 3</code></p>
<p><code>In: a[1, 1]</code>                                                                </p>
<p><code>Out: 4</code></p>
<p>可见，对于数组a，只要通过<code>a[m, n]</code>的形式，就能访问数组内的元素，其中m和n为数组元素的下标。数组元素的下标如下所示：</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%20Data%20Analysis/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20NumPy%E6%95%B0%E7%BB%84/1.png" alt="1"></p>
<h3 id="2-4-NumPy的数值类型"><a href="#2-4-NumPy的数值类型" class="headerlink" title="2.4 NumPy的数值类型"></a>2.4 NumPy的数值类型</h3><p>下表概述了NumPy的各种数值类型：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bool</td>
<td align="left">布尔型数据类型（True 或者 False），占用1比特</td>
</tr>
<tr>
<td align="left">inti</td>
<td align="left">其长度取决于平台的整数（通常为int32 或 int64）</td>
</tr>
<tr>
<td align="left">int8</td>
<td align="left">字节类型（-128 to 127）</td>
</tr>
<tr>
<td align="left">int16</td>
<td align="left">整型（-32768 to 32767）</td>
</tr>
<tr>
<td align="left">int32</td>
<td align="left">整型（-$2^{31}$  to  $2^{31}-1$）</td>
</tr>
<tr>
<td align="left">int64</td>
<td align="left">整型（-$2^{63}$  to  $2^{63}-1$））</td>
</tr>
<tr>
<td align="left">uint8</td>
<td align="left">无符号整型（0 to 255）</td>
</tr>
<tr>
<td align="left">uint16</td>
<td align="left">无符号整型（0 to 65535）</td>
</tr>
<tr>
<td align="left">uint32</td>
<td align="left">无符号整型（0 to $2^{31}-1$）</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">无符号整型（0 to $2^{63}-1$）</td>
</tr>
<tr>
<td align="left">float16</td>
<td align="left">半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td>
</tr>
<tr>
<td align="left">float32</td>
<td align="left">单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td>
</tr>
<tr>
<td align="left">float64或float</td>
<td align="left">双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td>
</tr>
<tr>
<td align="left">complex_</td>
<td align="left">complex128 类型的简写，即 128 位复数</td>
</tr>
<tr>
<td align="left">complex64</td>
<td align="left">复数，表示双 32 位浮点数（实数部分和虚数部分）</td>
</tr>
<tr>
<td align="left">complex128</td>
<td align="left">复数，表示双 64 位浮点数（实数部分和虚数部分）</td>
</tr>
</tbody></table>
<p>注：NumPy跟数学运算有关的数据类型的名称都以数字结尾。这个数字指示了该类型的变量所占用的二进制位数。</p>
<p>每一种数据类型都有相应的转换函数：</p>
<p><code>In: float64(32)</code>                                                            </p>
<p><code>Out: 32.0</code></p>
<p><code>In: int8(42.0)</code>                                                             </p>
<p><code>Out: 42</code></p>
<p><code>In: bool(42)</code>                                                               </p>
<p><code>Out: True</code></p>
<p><code>In: bool(0)</code>                                                                </p>
<p><code>Out: False</code></p>
<p><code>In: bool(42.0)</code>                                                             </p>
<p><code>Out: True</code></p>
<p><code>In: float(True)</code>                                                            </p>
<p><code>Out: 1.0</code></p>
<p><code>In: float(False)</code>                                                           </p>
<p><code>Out: 0.0</code></p>
<p>许多函数都带有一个指定数据类型的参数，该参数通常是可选的：</p>
<p><code>In: arange(7, dtype=uint16)</code>                                                </p>
<p><code>Out: array([0, 1, 2, 3, 4, 5, 6], dtype=uint16)</code></p>
<p>注：</p>
<ol>
<li><p>不允许把复数类型转化成整型。会引发TypeError错误：</p>
<p><code>In: float(42.0 + 1.j)</code>                                                      </p>
<p><code>Traceback (most recent call last)</code></p>
<p><code>&lt;ipython-input-20-c164c131df24&gt; in &lt;module&gt;</code></p>
<p>​    <code>float(42.0 + 1.j)</code></p>
<p><code>TypeError: can&#39;t convert complex to float</code></p>
</li>
<li><p>同样也不允许复数转化成浮点数</p>
</li>
<li><p>允许把浮点数转换成复数  如：complex(1.0)是合法的</p>
</li>
<li><p>复数的实部和虚部分别使用 real( ) 函数和 imag( ) 函数来提取</p>
</li>
</ol>
<h4 id="2-4-1-数据类型对象"><a href="#2-4-1-数据类型对象" class="headerlink" title="2.4.1 数据类型对象"></a>2.4.1 数据类型对象</h4><p><strong>数据类型对象</strong>是numpy.dtype类的实例。</p>
<p>数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面：</p>
<ul>
<li>数据的类型（整数，浮点数或者 Python 对象）</li>
<li>数据的大小（例如， 整数使用多少个字节存储）</li>
<li>数据的字节顺序（小端法或大端法）</li>
<li>在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分</li>
<li>如果数据类型是子数组，它的形状和数据类型</li>
</ul>
<p>数据类型对象表明了数据占用的字节数。所占用的具体数目一般存放在 dtype 的 itemsize 属性中：</p>
<p><code>In: a = array([[1,2],[3,4]])</code><br><code>In: a.dtype.itemsize</code><br><code>Out: 8</code></p>
<h4 id="2-4-2-字符码"><a href="#2-4-2-字符码" class="headerlink" title="2.4.2 字符码"></a>2.4.2 字符码</h4><p>NumPy之所以提供字符码，是为了和其前身Numeric向后兼容。</p>
<p>一般不建议使用字符码。</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">对应类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">b</td>
<td align="left">布尔型</td>
</tr>
<tr>
<td align="left">i</td>
<td align="left">(有符号) 整型</td>
</tr>
<tr>
<td align="left">u</td>
<td align="left">无符号整型 integer</td>
</tr>
<tr>
<td align="left">f</td>
<td align="left">单精度浮点型</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">双精度浮点型</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">复数浮点型</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">timedelta（时间间隔）</td>
</tr>
<tr>
<td align="left">M</td>
<td align="left">datetime（日期时间）</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">复数型</td>
</tr>
<tr>
<td align="left">O</td>
<td align="left">(Python) 对象</td>
</tr>
<tr>
<td align="left">S, a</td>
<td align="left">(byte-)字符串</td>
</tr>
<tr>
<td align="left">U</td>
<td align="left">Unicode</td>
</tr>
<tr>
<td align="left">V</td>
<td align="left">原始数据 (void)</td>
</tr>
</tbody></table>
<p><code>In: arange(7, dtype=&#39;f&#39;)</code>                                                   </p>
<p><code>Out: array([0., 1., 2., 3., 4., 5., 6.], dtype=float32)</code></p>
<p><code>In:  arange(7, dtype=&#39;D&#39;)</code>                                                  </p>
<p><code>Out: array([0.+0.j, 1.+0.j, 2.+0.j, 3.+0.j, 4.+0.j, 5.+0.j, 6.+0.j])</code></p>
<h4 id="2-4-3-Dtype-构造函数"><a href="#2-4-3-Dtype-构造函数" class="headerlink" title="2.4.3 Dtype 构造函数"></a>2.4.3 Dtype 构造函数</h4><p>创建数据类型时，手段有很多，下面以浮点型数据为例进行说明。</p>
<ul>
<li><p>可以用Python自带的常规浮点型</p>
<p><code>In: dtype(float)</code><br><code>Out: float64</code></p>
</li>
<li><p>可以用字符码规定单精度浮点数</p>
<p><code>In: dtype(&#39;f&#39;)</code><br><code>Out: float32</code></p>
</li>
<li><p>可以用字符码规定双精度浮点数</p>
<p><code>In: dtype(&#39;d&#39;)</code><br><code>Out: loat64</code></p>
</li>
<li><p>可以通过dtype构造函数传递一个双字符码。</p>
<ul>
<li>第一个字符表示数据类型</li>
<li>第二个字符表示一个数字，表示该类型占用的字节数（数字2、4、8分别对应16位、32位、64位浮点数）</li>
</ul>
<p><code>In: dtype(&#39;f8&#39;)</code><br><code>Out: float64</code></p>
</li>
</ul>
<p>可以通过sctypeDict.keys()函数列出所有数据类型的字符码。</p>
<p><code>In: sctypeDict.keys()</code>                                                      </p>
<p><code>Out: dict_keys([&#39;?&#39;, 0, &#39;byte&#39;, &#39;b&#39;, 1, &#39;ubyte&#39;, &#39;B&#39;, 2, &#39;short&#39;, &#39;h&#39;, 3, &#39;ushort&#39;, &#39;H&#39;, 4, &#39;i&#39;, 5, &#39;uint&#39;, &#39;I&#39;, 6, &#39;intp&#39;, &#39;p&#39;, 7, &#39;uintp&#39;, &#39;P&#39;, 8, &#39;long&#39;, &#39;l&#39;, &#39;L&#39;, &#39;longlong&#39;, &#39;q&#39;, 9, &#39;ulonglong&#39;, &#39;Q&#39;, 10, &#39;half&#39;, &#39;e&#39;, 23, &#39;f&#39;, 11, &#39;double&#39;, &#39;d&#39;, 12, &#39;longdouble&#39;, &#39;g&#39;, 13, &#39;cfloat&#39;, &#39;F&#39;, 14, &#39;cdouble&#39;, &#39;D&#39;, 15, &#39;clongdouble&#39;, &#39;G&#39;, 16, &#39;O&#39;, 17, &#39;S&#39;, 18, &#39;unicode&#39;, &#39;U&#39;, 19, &#39;void&#39;, &#39;V&#39;, 20, &#39;M&#39;, 21, &#39;m&#39;, 22, &#39;bool8&#39;, &#39;Bool&#39;, &#39;b1&#39;, &#39;int64&#39;, &#39;Int64&#39;, &#39;i8&#39;, &#39;uint64&#39;, &#39;Uint64&#39;, &#39;u8&#39;, &#39;float16&#39;, &#39;Float16&#39;, &#39;f2&#39;, &#39;float32&#39;, &#39;Float32&#39;, &#39;f4&#39;, &#39;float64&#39;, &#39;Float64&#39;, &#39;f8&#39;, &#39;float128&#39;, &#39;Float128&#39;, &#39;f16&#39;, &#39;complex64&#39;, &#39;Complex32&#39;, &#39;c8&#39;, &#39;complex128&#39;, &#39;Complex64&#39;, &#39;c16&#39;, &#39;complex256&#39;, &#39;Complex128&#39;, &#39;c32&#39;, &#39;object0&#39;, &#39;Object0&#39;, &#39;bytes0&#39;, &#39;Bytes0&#39;, &#39;str0&#39;, &#39;Str0&#39;, &#39;void0&#39;, &#39;Void0&#39;, &#39;datetime64&#39;, &#39;Datetime64&#39;, &#39;M8&#39;, &#39;timedelta64&#39;, &#39;Timedelta64&#39;, &#39;m8&#39;, &#39;UInt64&#39;, &#39;int32&#39;, &#39;Int32&#39;, &#39;i4&#39;, &#39;uint32&#39;, &#39;UInt32&#39;, &#39;u4&#39;, &#39;int16&#39;, &#39;Int16&#39;, &#39;i2&#39;, &#39;uint16&#39;, &#39;UInt16&#39;, &#39;u2&#39;, &#39;int8&#39;, &#39;Int8&#39;, &#39;i1&#39;, &#39;uint8&#39;, &#39;UInt8&#39;, &#39;u1&#39;, &#39;complex_&#39;, &#39;int0&#39;, &#39;uint0&#39;, &#39;single&#39;, &#39;csingle&#39;, &#39;singlecomplex&#39;, &#39;float_&#39;, &#39;intc&#39;, &#39;uintc&#39;, &#39;int_&#39;, &#39;longfloat&#39;, &#39;clongfloat&#39;, &#39;longcomplex&#39;, &#39;bool_&#39;, &#39;bytes_&#39;, &#39;string_&#39;, &#39;unicode_&#39;, &#39;object_&#39;, &#39;str_&#39;, &#39;int&#39;, &#39;float&#39;, &#39;complex&#39;, &#39;bool&#39;, &#39;object&#39;, &#39;str&#39;, &#39;bytes&#39;, &#39;a&#39;])</code></p>
<h4 id="2-4-4-dtype属性"><a href="#2-4-4-dtype属性" class="headerlink" title="2.4.4 dtype属性"></a>2.4.4 dtype属性</h4><p>dtype 对象是使用以下语法构造的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.dtype(object, align, copy)</span><br></pre></td></tr></table></figure>

<ul>
<li>object - 要转换为的数据类型对象</li>
<li>align - 如果为 true，填充字段使其类似 C 的结构体。</li>
<li>copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用</li>
</ul>
<p>dtype的属性str中保存的是一个表示数据类型的字符串</p>
<ul>
<li>第一个字符描述字节顺序<ul>
<li>字节顺序是通过对数据类型预先设定”&lt;”或”&gt;”来决定的。”&lt;”意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。”&gt;”意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。</li>
</ul>
</li>
<li>如果需要，后面会跟着字符码和数字，用来表示存储每个数组元素所需的字节数</li>
</ul>
<p><code>In: t = dtype(&#39;Float64&#39;)</code>                                                    </p>
<p><code>In: t.str</code>                                                                   </p>
<p><code>Out: &#39;&lt;f8&#39;</code></p>
<h3 id="2-5-一维数组的切片与索引"><a href="#2-5-一维数组的切片与索引" class="headerlink" title="2.5 一维数组的切片与索引"></a>2.5 一维数组的切片与索引</h3><p>一维NumPy数组的切片操作与Python列表的切片一样。</p>
<p><code>In: a = arange(9)</code>                                                           </p>
<p><code>In: a[3:7]</code>                                                                  </p>
<p><code>Out: array([3, 4, 5, 6])</code>                                                            </p>
<p><code>In: a[:7:2]</code>                                                                 </p>
<p><code>Out: array([0, 2, 4, 6])</code></p>
<p><code>In: a[::-1]</code>                                                                 </p>
<p><code>Out: array([8, 7, 6, 5, 4, 3, 2, 1, 0])</code></p>
<h3 id="2-6-处理数组形状"><a href="#2-6-处理数组形状" class="headerlink" title="2.6 处理数组形状"></a>2.6 处理数组形状</h3><p>首先，先创建数组：</p>
<p><code>b = np.arange(24).reshape(2, 3, 4)</code></p>
<ul>
<li><p><strong>拆解</strong>    </p>
<ul>
<li>可以用 ravel() 函数将多维数组变成一维数组</li>
</ul>
<p><code>In: b</code></p>
<p><code>Out:</code></p>
<p><code>[[[ 0  1  2  3]</code><br>  <code>[ 4  5  6  7]</code><br>  <code>[ 8  9 10 11]]</code><br> <code>[[12 13 14 15]</code><br>  <code>[16 17 18 19]</code><br>  <code>[20 21 22 23]]]</code></p>
</li>
</ul>
<p>  <code>In: b.ravel()</code></p>
<p>  <code>Out:</code></p>
<p>  <code>[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]</code></p>
<ul>
<li><p><strong>拉直</strong>    </p>
<ul>
<li>flatten() 函数其功能与 ravel() 相同<ul>
<li>但 flatten() 函数返回的是真实的数组，需要分配新的内存空间</li>
<li>而 ravel() 函数返回的只是数组的视图 </li>
</ul>
</li>
</ul>
<p><code>In: b.flatten()</code></p>
<p><code>Out:</code></p>
<p><code>[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]</code></p>
</li>
</ul>
<ul>
<li><p><strong>用元组指定数组形状</strong>    </p>
<ul>
<li>除 reshape() 函数外，还可以用元组来轻松定义数组的形状</li>
</ul>
<p><code>In: b.shape = (6,4)</code><br><code>In: b</code></p>
<p><code>Out:</code></p>
<p><code>[[ 0  1  2  3]</code><br> <code>[ 4  5  6  7]</code><br> <code>[ 8  9 10 11]</code><br> <code>[12 13 14 15]</code><br> <code>[16 17 18 19]</code><br> <code>[20 21 22 23]]</code></p>
</li>
</ul>
<ul>
<li><p><strong>转置</strong></p>
<p><code>In: b.transpose()</code></p>
<p><code>Out:</code></p>
<p><code>[[ 0  4  8 12 16 20]</code><br> <code>[ 1  5  9 13 17 21]</code><br> <code>[ 2  6 10 14 18 22]</code><br> <code>[ 3  7 11 15 19 23]]</code></p>
</li>
</ul>
<ul>
<li><p><strong>调整大小</strong></p>
<ul>
<li>函数 resize() 的作用类似于 reshape() ，但是会改变所作用的数组</li>
</ul>
<p><code>In: b.resize((2,12))</code><br><code>In: b</code></p>
<p><code>Out:</code></p>
<p><code>[[ 0  1  2  3  4  5  6  7  8  9 10 11]</code><br> <code>[12 13 14 15 16 17 18 19 20 21 22 23]]</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">b = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)      <span class="comment"># 创建了一个三维数组</span></span><br><span class="line">print(<span class="string">'b:\n'</span>, b)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\nb.ravel()\n'</span>, b.ravel())    <span class="comment"># 拆解，利用ravel（）函数将多维数组变成一维数组</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\nb.flatten()\n'</span>,b.flatten())    <span class="comment"># 拉直</span></span><br><span class="line"></span><br><span class="line">b.shape = (<span class="number">6</span>, <span class="number">4</span>)    <span class="comment"># 重新规定形状</span></span><br><span class="line">print(<span class="string">'\nb.shape = (6, 4)\n'</span>, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\nb.transpose()\n'</span>,b.transpose())    <span class="comment"># 转置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b.resize((<span class="number">2</span>, <span class="number">12</span>))    <span class="comment"># 调整大小</span></span><br><span class="line">print(<span class="string">'\nb.resize((2, 12))\n'</span>, b)</span><br></pre></td></tr></table></figure>

<h4 id="2-6-1-堆叠数组"><a href="#2-6-1-堆叠数组" class="headerlink" title="2.6.1 堆叠数组"></a>2.6.1 堆叠数组</h4><p>从深度看，数组既可以横向叠放，也可以竖向叠放。</p>
<p>首先，先建立数组：</p>
<p><code>In: a = arange(9).reshape(3,3)</code></p>
<p><code>In: a</code></p>
<p><code>Out:</code></p>
<p><code>[[0 1 2]</code><br> <code>[3 4 5]</code><br> <code>[6 7 8]]</code></p>
<p><code>In: b = 2 * a</code></p>
<p><code>In: b</code></p>
<p><code>Out:</code></p>
<p><code>[[ 0  2  4]</code><br> <code>[ 6  8 10]</code><br> <code>[12 14 16]]</code></p>
<ul>
<li><p><strong>水平叠加</strong></p>
<ul>
<li><strong>hstack()</strong> 函数</li>
</ul>
<p><code>In: hstack((a, b))</code></p>
<p><code>Out:</code></p>
<p><code>[[ 0  1  2  0  2  4]</code><br> <code>[ 3  4  5  6  8 10]</code><br> <code>[ 6  7  8 12 14 16]]</code></p>
</li>
</ul>
<ul>
<li><p>用 <strong>concatenate()</strong> 函数也能达到同样的效果</p>
<p><code>In: concatenate((a, b), axis=1)</code></p>
<p><code>Out:</code></p>
<p><code>[[ 0  1  2  0  2  4]  [ 3  4  5  6  8 10]  [ 6  7  8 12 14 16]]</code></p>
</li>
</ul>
<ul>
<li><p><strong>垂直叠加</strong></p>
<ul>
<li><p><strong>vsatck()</strong> 函数</p>
<p><code>In: vstack((a, b))</code><br><code>[[ 0  1  2]</code><br> <code>[ 3  4  5]</code><br> <code>[ 6  7  8]</code><br> <code>[ 0  2  4]</code><br> <code>[ 6  8 10]</code><br> <code>[12 14 16]]</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>当参数 axis 置 0 时，<strong>concatenate()</strong> 函数也会得到同样的效果</p>
<p><code>In: concatenate((a, b), axis=0)</code><br><code>[[ 0  1  2]</code><br> <code>[ 3  4  5]</code><br> <code>[ 6  7  8]</code><br> <code>[ 0  2  4]</code><br> <code>[ 6  8 10]</code><br><code>[12 14 16]]</code></p>
</li>
</ul>
<ul>
<li><p><strong>深度叠加</strong></p>
<ul>
<li><p><strong>dstack()</strong> 函数</p>
<ul>
<li>这种方法是沿着第三个坐标轴（纵向）的方向来叠加一摞数组</li>
<li>举例来说，可以在一个图像数据的二维数组上叠加另一幅图像的数据</li>
</ul>
<p><code>In: dstack((a, b))</code><br><code>[[[ 0  0]</code><br>  <code>[ 1  2]</code><br>  <code>[ 2  4]]</code><br> <code>[[ 3  6]</code><br>  <code>[ 4  8]</code><br>  <code>[ 5 10]]</code><br> <code>[[ 6 12]</code><br>  <code>[ 7 14]</code><br>  <code>[ 8 16]]]</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>列式堆叠</strong></p>
<ul>
<li><p><strong>column_stack()</strong></p>
<p><code>In: oned = arange(2)</code><br><code>In: oned</code><br><code>[0 1]</code><br><code>In: twice_oned = 2 * oned</code><br><code>In: twice_oned</code><br><code>[0 2]</code><br><code>In: column_stack((oned, twice_oned))</code><br><code>[[0 0]</code><br> <code>[1 2]]</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>用这种方法堆叠二维数组，过程类似于 <strong>hstack()</strong> 函数</p>
<p><code>In: column_stack((a, b))</code><br><code>[[ 0  1  2  0  2  4]</code><br> <code>[ 3  4  5  6  8 10]</code><br> <code>[ 6  7  8 12 14 16]]</code></p>
<p><code>In: column_stack((a, b)) == hstack((a, b))</code><br><code>[[ True  True  True  True  True  True]</code><br> <code>[ True  True  True  True  True  True]</code><br><code>[ True  True  True  True  True  True]]</code></p>
</li>
</ul>
<ul>
<li><p><strong>行式堆叠</strong></p>
<ul>
<li><p><strong>row_stack()</strong></p>
<p><code>In: row_stack((oned, twice_oned))</code><br><code>[[0 1]</code><br> <code>[0 2]]</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>对于二维数组，row_stack() 函数相当于 <strong>vstack()</strong> 函数</p>
<p><code>In: row_stack((a, b))</code><br><code>[[ 0  1  2]</code><br> <code>[ 3  4  5]</code><br> <code>[ 6  7  8]</code><br> <code>[ 0  2  4]</code><br> <code>[ 6  8 10]</code><br> <code>[12 14 16]]</code><br><code>In: row_stack((a,b)) == vstack((a, b))</code><br><code>[[ True  True  True]</code><br> <code>[ True  True  True]</code><br> <code>[ True  True  True]</code><br> <code>[ True  True  True]</code><br> <code>[ True  True  True]</code><br><code>[ True  True  True]]</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line">a = numpy.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">b = <span class="number">2</span> * a</span><br><span class="line"></span><br><span class="line">print(<span class="string">'a:\n'</span>, a)</span><br><span class="line">print(<span class="string">'\nb\n'</span>,b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 水平叠加  hstack</span></span><br><span class="line">print(<span class="string">'\nhstack((a, b)):\n'</span>, numpy.hstack((a, b)))</span><br><span class="line">print(<span class="string">'\nnumpy.concatenate((a, b), axis=1):\n'</span>, numpy.concatenate((a, b), axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 垂直叠加  vstack</span></span><br><span class="line">print(<span class="string">'\nvstack((a, b)):\n'</span>, numpy.vstack((a, b)))</span><br><span class="line">print(<span class="string">'\nnumpy.concatenate((a, b), axis=0):\n'</span>, numpy.concatenate((a, b), axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度叠加  dstack</span></span><br><span class="line">print(<span class="string">'\ndstack((a, b))\n:'</span>, numpy.dstack((a, b)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列式堆叠 column_stack</span></span><br><span class="line">oned = numpy.arange(<span class="number">2</span>)</span><br><span class="line">twice_oned = <span class="number">2</span> * oned</span><br><span class="line">print(<span class="string">'\noned:\n'</span>, oned)</span><br><span class="line">print(<span class="string">'\ntwice_oned:\n'</span>, twice_oned)</span><br><span class="line">print(<span class="string">'\nnumpy.column_stack((oned, twice_oned):\n'</span>, numpy.column_stack((oned, twice_oned)))</span><br><span class="line">print(<span class="string">'\nnumpy.column_stack((a, b):\n'</span>, numpy.column_stack((a, b)))</span><br><span class="line">print(<span class="string">'\nnumpy.column_stack((a, b))==numpy.hstack((a, b)):\n'</span>, numpy.column_stack((a, b))==numpy.hstack((a, b)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 行式堆叠 row_stack</span></span><br><span class="line">oned = numpy.arange(<span class="number">2</span>)</span><br><span class="line">twice_oned = <span class="number">2</span> * oned</span><br><span class="line">print(<span class="string">'\noned:\n'</span>, oned)</span><br><span class="line">print(<span class="string">'\ntwice_oned:\n'</span>, twice_oned)</span><br><span class="line">print(<span class="string">'\nnumpy.row_stack((oned, twice_oned):\n'</span>, numpy.row_stack((oned, twice_oned)))</span><br><span class="line">print(<span class="string">'\nnumpy.row_stack((a, b):\n'</span>, numpy.row_stack((a, b)))</span><br><span class="line">print(<span class="string">'\nnumpy.row_stack((a, b))==numpy.vstack((a, b)):\n'</span>, numpy.row_stack((a, b))==numpy.vstack((a, b)))</span><br></pre></td></tr></table></figure>

<h4 id="2-6-2-拆分数组"><a href="#2-6-2-拆分数组" class="headerlink" title="2.6.2 拆分数组"></a>2.6.2 拆分数组</h4><p>可以从纵向、横向和深度方向来拆分数组。</p>
<ul>
<li><p><strong>横向拆分</strong></p>
<ul>
<li><p><strong>hspilt()</strong></p>
<ul>
<li>对于一个 $3 \times 3$ 数组，可以沿着横轴方向将其分解为3部分，并且各部分的大小和形状完全一致</li>
</ul>
<p><code>In: a = arange(9).reshape(3, 3)</code><br><code>In: a</code><br><code>[[0 1 2]</code><br> <code>[3 4 5]</code><br> <code>[6 7 8]]</code></p>
<p><code>In: hsplit(a, 3)</code><br><code>[array([[0],</code></p>
<pre><code>`[3],`
`[6]]),` </code></pre><p><code>array([[1],</code></p>
<pre><code>`[4],`
`[7]]),` </code></pre><p><code>array([[2],</code></p>
<pre><code>`[5],`
`[8]])]`</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li><p>这相当于调用了参数 axis=1 的 <strong>split()</strong> 函数</p>
<p><code>In: split(a, 3, axis=1)</code><br><code>[array([[0]</code>,</p>
<pre><code>`[3],`
`[6]]), `</code></pre><p><code>array([[1],</code></p>
<pre><code>`[4],`
`[7]]), `</code></pre><p><code>array([[2],</code></p>
<pre><code>`[5],`
`[8]])]`</code></pre></li>
</ul>
<ul>
<li><p><strong>纵向拆分</strong></p>
<ul>
<li><p><strong>vsplit()</strong> 函数将沿着纵轴方向分解数组</p>
<p><code>In: vsplit(a, 3)</code><br><code>[array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>当参数 axis=0 时，<strong>split()</strong> 函数也会沿着纵轴方向分解数组</p>
<p><code>In: split(a, 3, axis=0)</code><br><code>[array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]</code></p>
</li>
</ul>
<ul>
<li><p><strong>深向拆分</strong></p>
<ul>
<li><p><strong>dsplit()</strong></p>
<ul>
<li>dsplit() 函数会沿着深度方向分解数组</li>
<li>dsplit() 函数只处理三位及以上的数组</li>
</ul>
<p><code>In: c = arange(27).reshape(3, 3, 3)</code><br><code>In: c</code><br><code>[[[ 0  1  2]</code><br>  <code>[ 3  4  5]</code><br>  <code>[ 6  7  8]]</code></p>
<p> <code>[[ 9 10 11]</code><br>  <code>[12 13 14]</code><br>  <code>[15 16 17]]</code></p>
<p> <code>[[18 19 20]</code><br>  <code>[21 22 23]</code><br>  <code>[24 25 26]]]</code></p>
</li>
</ul>
</li>
</ul>
<pre><code>`In: dsplit(c, 3)`
`[array([[[ 0],`
                  `[ 3],`
                  `[ 6]],`

                  `[[ 9],`
                    `[12],`
                    `[15]],`

​                  `[[18],`
​                    `[21],`
​                    `[24]]]),`

 `array([[[ 1],`
                 `[ 4],`
                 `[ 7]],`

​               `[[10],`
                 `[13],`
​                 `[16]],`

​               `[[19],`
                 `[22],`
                 `[25]]]),` 

`array([[[ 2],`
                `[ 5],`
                `[ 8]],`

​              `[[11],`
​                `[14],`
​                `[17]],`

​              `[[20],`
​                `[23],`
​                `[26]]])]`</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line">a = numpy.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'a:\n'</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 横向拆分  hsplit()</span></span><br><span class="line">print(<span class="string">'\nnumpy.hsplit(a, 3):\n'</span>, numpy.hsplit(a, <span class="number">3</span>))</span><br><span class="line">print(<span class="string">'\nnumpy.split(a, 3, axis=1:\n'</span>, numpy.split(a, <span class="number">3</span>, axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 纵向拆分  vsplit()</span></span><br><span class="line">print(<span class="string">'\nnumpy.vsplit(a, 3):\n'</span>, numpy.vsplit(a, <span class="number">3</span>))</span><br><span class="line">print(<span class="string">'\nnumpy.split(a, 3, axis=0:\n'</span>, numpy.split(a, <span class="number">3</span>, axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 深向拆分  dsplit()    只适用于3维及以上的数组</span></span><br><span class="line">c = numpy.arange(<span class="number">27</span>).reshape(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">print(<span class="string">'\nc:\n'</span>, c)</span><br><span class="line">print(<span class="string">'\nnumpy.dsplit(c, 3):\n'</span>, numpy.dsplit(c, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h4 id="2-6-3-NumPy数组的属性"><a href="#2-6-3-NumPy数组的属性" class="headerlink" title="2.6.3 NumPy数组的属性"></a>2.6.3 NumPy数组的属性</h4><ul>
<li><p><strong>ndim</strong> 属性</p>
<ul>
<li>存储的是维度的数量</li>
</ul>
<p><code>In: b</code><br><code>[[ 0  1  2  3  4  5  6  7  8  9 10 11]</code><br> <code>[12 13 14 15 16 17 18 19 20 21 22 23]]</code><br><code>In: b.ndim</code><br><code>2</code></p>
</li>
</ul>
<ul>
<li><p><strong>size</strong>属性</p>
<ul>
<li>用来保存元素的数量</li>
</ul>
<p><code>In: b.size</code><br><code>24</code></p>
</li>
</ul>
<ul>
<li><p><strong>itemsize</strong>属性</p>
<ul>
<li>可以返回数组中各个元素所占用的字节数</li>
</ul>
<p><code>In: b.itemsize</code><br><code>8</code></p>
</li>
</ul>
<ul>
<li><p><strong>nbytes</strong> 属性</p>
<ul>
<li>返回存储整个数组所需的字节数 = itemsize * size</li>
</ul>
<p><code>In: b.nbytes</code><br><code>192</code></p>
<p><code>In: b.size * b.itemsize</code><br><code>192</code></p>
</li>
</ul>
<ul>
<li><p><strong>T</strong> 属性 </p>
<ul>
<li>转置，与 transpose() 函数相同</li>
</ul>
<p><code>In: b.resize(6,4)</code><br><code>None</code></p>
<p><code>In: b</code><br><code>[[ 0  1  2  3]</code><br> <code>[ 4  5  6  7]</code><br> <code>[ 8  9 10 11]</code><br> <code>[12 13 14 15]</code><br> <code>[16 17 18 19]</code><br> <code>[20 21 22 23]]</code></p>
<p><code>In: b.T</code><br><code>[[ 0  4  8 12 16 20]</code><br> <code>[ 1  5  9 13 17 21]</code><br> <code>[ 2  6 10 14 18 22]</code><br><code>[ 3  7 11 15 19 23]]</code></p>
</li>
</ul>
<ul>
<li><p>使用复数生成一个数组</p>
<p><code>In: b = array([1.j + 1, 2.j + 3])</code><br><code>In: b</code><br><code>[1.+1.j 3.+2.j]</code></p>
</li>
</ul>
<ul>
<li><p><strong>real</strong> 属性</p>
<ul>
<li>返回数组的实部，当数组元素全为实数时，就返回数组本身</li>
</ul>
<p><code>In: b.real</code><br><code>[1. 3.]</code></p>
</li>
</ul>
<ul>
<li><p><strong>imag</strong> 属性</p>
<ul>
<li>存放数组的虚部</li>
</ul>
<p><code>In: b.imag</code><br><code>[1. 2.]</code></p>
</li>
</ul>
<ul>
<li><p>如果数组含有复数，那么它的数据类型将自动变为复数型</p>
<p><code>In: b.dtype</code><br><code>complex128</code><br><code>In: b.dtype.str</code><br><code>&lt;c16</code></p>
</li>
</ul>
<ul>
<li><p><strong>flat</strong> 属性</p>
<ul>
<li><p>可返回一个 <strong>numpy.flatiter</strong> 对象，这是获得 <strong>flatiter</strong> 对象的唯一方法，</p>
</li>
<li><p>但我们无法访问 <strong>flatiter</strong> 的构造函数。可以使用 <strong>flat的迭代器</strong> 来遍历数组。</p>
</li>
</ul>
</li>
</ul>
<p>  <code>In: b = arange(4).reshape(2,2)</code><br>  <code>In: b</code><br>  <code>[[0 1]</code><br>   <code>[2 3]]</code><br>  <code>In: f = b.flat</code><br>  <code>In: f</code><br>  <code>&lt;numpy.flatiter object at 0x10207a200&gt;</code><br>  <code>In: for it in f: print it</code><br>  <code>0</code><br>  <code>1</code><br>  <code>2</code><br>  <code>3</code></p>
<ul>
<li><p>获取元素</p>
<p><code>In: b.flat[2]</code><br><code>2</code><br><code>In: b.flat[[1,3]]</code><br><code>[1 3]</code></p>
</li>
</ul>
<ul>
<li><p>给 flat 属性赋值。</p>
<ul>
<li>这个值将会覆盖整个数组内所有元素的值</li>
</ul>
<p><code>In: b.flat = 7</code><br><code>[[7 7]</code><br><code>[7 7]]</code></p>
<p><code>In: e.flat[[1, 3]] = 1</code><br><code>[[7 1]</code><br><code>[7 1]]</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">b = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">12</span>)</span><br><span class="line">print(<span class="string">'\n b: \n'</span>, b)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\b b.ndim: \n'</span>, b.ndim)      <span class="comment"># ndim属性存储的是维度的数量</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\b b.size: \n'</span>, b.size)      <span class="comment"># size属性用来保存元素的数量</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\b b.itemsize: \n'</span>, b.itemsize)      <span class="comment"># itemsize属性可以返回数组中各个元素所占用的字节数</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\b b.nbytes: \n'</span>, b.nbytes)      <span class="comment"># nbytes属性返回存储整个数组所需的字节数 = itemsize * size</span></span><br><span class="line">print(<span class="string">'\b b.itemsize * b.size: \n'</span>, b.itemsize * b.size)</span><br><span class="line"></span><br><span class="line">b.resize(<span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line">print(<span class="string">'\b b: \n'</span>, b)</span><br><span class="line">print(<span class="string">'\b b.T: \n'</span>, b.T)      <span class="comment"># T属性 转置</span></span><br><span class="line"></span><br><span class="line">c = np.arange(<span class="number">5</span>).reshape(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">print(<span class="string">'\b c.ndim: \n'</span>, c.ndim)      <span class="comment"># ndim属性</span></span><br><span class="line">print(<span class="string">'\b c.T: \n'</span>, c.T)      <span class="comment"># T属性 转置</span></span><br><span class="line"></span><br><span class="line">d = np.array([<span class="number">1.j</span> + <span class="number">1</span>, <span class="number">2.j</span> + <span class="number">3</span>])</span><br><span class="line">print(<span class="string">'\n d: \n'</span>, d)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n d.real: \n'</span>, d.real)      <span class="comment"># real属性返回数组的实部，当数组元素全为实数时，就返回数组本身</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n d.imag: \n'</span>, d.imag)      <span class="comment"># imag属性存放数组的虚部</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n d.dtype: \n'</span>, d.dtype)</span><br><span class="line">print(<span class="string">'\n d.dtype.str: \n'</span>, d.dtype.str)</span><br><span class="line"></span><br><span class="line">e = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">print(<span class="string">'\n e: \n'</span>, e)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n e.flat: \n'</span>, e.flat)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">flat属性可返回一个numpy.flatiter对象，这是获得flatiter对象的唯一方法，</span></span><br><span class="line"><span class="string">但我们无法访问flatiter的构造函数。可以使用flat的迭代器来遍历数组。</span></span><br><span class="line"><span class="string"> '''</span></span><br><span class="line">f = e.flat</span><br><span class="line">print(<span class="string">'\n e.flat_print: '</span>)</span><br><span class="line">[print(it) <span class="keyword">for</span> it <span class="keyword">in</span> f]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n e.flat[2]: \n'</span>, e.flat[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n e.flat[[1, 3]]: \n'</span>, e.flat[[<span class="number">1</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">e.flat = <span class="number">7</span></span><br><span class="line">print(<span class="string">'\n e.flat = 7, e: \n'</span>, e)</span><br><span class="line"></span><br><span class="line">e.flat[[<span class="number">1</span>, <span class="number">3</span>]] = <span class="number">1</span></span><br><span class="line">print(<span class="string">'\n e.flat[[1, 3]] = 1, e: \n'</span>, e)</span><br></pre></td></tr></table></figure>

<h4 id="2-6-4-数组的转换"><a href="#2-6-4-数组的转换" class="headerlink" title="2.6.4 数组的转换"></a>2.6.4 数组的转换</h4><p>可以把 NumPy 数组转换成 Python 列表，使用 <strong>tolist()</strong> 函数</p>
<ul>
<li><p><strong>转换成列表</strong></p>
<p><code>In: b</code><br><code>[1.+1.j 3.+2.j]</code><br><code>In: b.tolist()</code><br><code>[(1+1j), (3+2j)]</code></p>
</li>
</ul>
<ul>
<li><p><strong>astype()</strong> 函数</p>
<ul>
<li>可以把数组元素转换成指定类型</li>
</ul>
<p><code>In: b.astype(int):</code> </p>
<p><code>/Users/hhh/Desktop/python/python数据分析/第二章：NumPy数组/2-6-4 数组的转换.py:9: ComplexWarning: Casting complex values to real discards the imaginary part</code><br>  <code>print(b.astype(int))</code><br> <code>[1 3]</code></p>
<p> <code>In: b.astype(&#39;comlex&#39;):</code><br> <code>[1.+1.j 3.+2.j]</code></p>
</li>
</ul>
<ul>
<li><strong>提示</strong><ul>
<li>当complex类型转成int类型时，虚部将被丢弃，抛出警告</li>
<li>需要将数据类型的名称以字符串的形式传递给 astype() 函数</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">b = np.array([<span class="number">1.j</span> + <span class="number">1</span>, <span class="number">2.j</span> + <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n b: \n'</span>, b)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n b.tolist(): \n'</span>, b.tolist())</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n b.astype(int): \n'</span>, b.astype(int))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\n b.astype('comlex'): \n"</span>, b.astype(<span class="string">'complex'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="2-7-创建数组的视图和拷贝"><a href="#2-7-创建数组的视图和拷贝" class="headerlink" title="2.7 创建数组的视图和拷贝"></a>2.7 创建数组的视图和拷贝</h3><p>我们可以根据著名的 <strong>ascent</strong> 照片来创建数组，然后创建视图，随后修改它。</p>
<p>这里，ascent肖像的数组是从 <strong>SciPy</strong> 函数获得的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">	此后的代码会将取得的图片命名为 lena，是为了防止与我使用的书（《Python数据分析》（第二版））中的代码相不同。</span><br><span class="line">	这本书所使用的lena图像在新版的 SciPy （我用的是1.3.0）中已经删除，但是我们可以换成 ascent 图像，不影响学习和使用。</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.misc</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">lena = scipy.misc.ascent()</span><br><span class="line"></span><br><span class="line">acopy = lena.copy()</span><br><span class="line">aview = lena.view()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">231</span>)</span><br><span class="line">plt.title(<span class="string">'lena(befor)'</span>)</span><br><span class="line">plt.imshow(lena)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">232</span>)</span><br><span class="line">plt.title(<span class="string">'acopy(befor)'</span>)</span><br><span class="line">plt.imshow(acopy)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">233</span>)</span><br><span class="line">plt.title(<span class="string">'aview(befor)'</span>)</span><br><span class="line">plt.imshow(aview)</span><br><span class="line"></span><br><span class="line">aview.flat = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">234</span>)</span><br><span class="line">plt.title(<span class="string">'lena(after)'</span>)</span><br><span class="line">plt.imshow(lena)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">235</span>)</span><br><span class="line">plt.title(<span class="string">'acopy(after)'</span>)</span><br><span class="line">plt.imshow(acopy)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">236</span>)</span><br><span class="line">plt.title(<span class="string">'aview(after)'</span>)</span><br><span class="line">plt.imshow(aview)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建一份ascent数组的副本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acopy = lena.copy()</span><br></pre></td></tr></table></figure>
</li>
<li><p>为该数组创建一个视图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aview = lena.view()</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 flat 迭代器将视图中的所有值全部设为0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aview.flat = <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后结果如图</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%20Data%20Analysis/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20NumPy%E6%95%B0%E7%BB%84/2.png" alt="2"></p>
<p>可见，在程序部分修改视图，同时改变了原来的数组。</p>
<p><strong><em>所以一定要记住：视图不是只读的</em></strong></p>
<h3 id="2-8-花式索引"><a href="#2-8-花式索引" class="headerlink" title="2.8 花式索引"></a>2.8 花式索引</h3><p>花式索引是一种传统的索引方法，它不使用整数或者切片。</p>
<p>这里，我们利用花式索引把图片对角线上的值全部置0，相当于沿着两条交叉的对角线画两条黑线。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.misc</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">lena = scipy.misc.ascent()</span><br><span class="line"></span><br><span class="line">xmax = lena.shape[<span class="number">0</span>]</span><br><span class="line">ymax = lena.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">lena[range(xmax), range(ymax)] = <span class="number">0</span></span><br><span class="line">lena[range(xmax<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>), range(ymax)] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">plt.imshow(lena)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将第一条对角线上的值设为0</p>
<p>为了给对角线上的值置0，需要给 x 和 y 值（直角坐标系中的坐标）规定两个不同的范围</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lena[range(xmax), range(ymax)] = <span class="number">0</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>将另一条对角线上的值设为0</p>
<p>要设置另一条对角线上的值，需要规定两个不同的取值范围，但是规则不变</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lena[range(xmax<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>), range(ymax)] = <span class="number">0</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>效果</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%20Data%20Analysis/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20NumPy%E6%95%B0%E7%BB%84/3.png" alt="3"></p>
</li>
</ol>
<p>我们给 x 和 y 规定了不同的取值范围，这些范围用来索引图片数组。</p>
<p>花式索引是在一个内部的NumPy迭代器对象的基础上实现的，分3部完成：</p>
<ol>
<li>创建迭代器对象</li>
<li>将迭代器对象绑定到数组</li>
<li>经由迭代器访问数组元素，利用位置列表进行索引</li>
</ol>
<h3 id="2-9-基于位置列表的索引方法"><a href="#2-9-基于位置列表的索引方法" class="headerlink" title="2.9 基于位置列表的索引方法"></a>2.9 基于位置列表的索引方法</h3><p>下面利用 <strong>ix_()</strong> 函数将照片中的像素完全打乱。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.misc</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lena = scipy.misc.ascent()</span><br><span class="line"></span><br><span class="line">xmax = lena.shape[<span class="number">0</span>]</span><br><span class="line">ymax = lena.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffle_indices</span><span class="params">(size)</span>:</span></span><br><span class="line">    arr = np.arange(size)</span><br><span class="line">    np.random.shuffle(arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">xindices = shuffle_indices(xmax)</span><br><span class="line">np.testing.assert_equal(len(xindices), xmax)</span><br><span class="line"></span><br><span class="line">yindices = shuffle_indices(ymax)</span><br><span class="line">np.testing.assert_equal(len(yindices), ymax)</span><br><span class="line"></span><br><span class="line">plt.imshow(lena[np.ix_(xindices, yindices)])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p> <strong>ix_()</strong> ：这个函数可以根据多个序列生成一个网格，它需要一个一维序列作为参数，并返回一个由NumPy数组构成的元组。</p>
<p><code>In: ix_([0, 1], [2, 3])</code>                                                     </p>
<p><code>Out:</code> </p>
<p><code>(array([[0],</code></p>
<p>​                <code>[1]]), array([[2, 3]]))</code></p>
<p>利用位置列表索引NumPy数组的过程：</p>
<ol>
<li><p>打乱数组的索引</p>
<p>利用 <strong>numpy.random</strong> 子程序包中的 <strong>shuffle()</strong> 函数把数组中的元素按随机的索引号重新排列，使得数组产生相应变化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffle_indices</span><span class="params">(size)</span>:</span></span><br><span class="line">    arr = np.arange(size)</span><br><span class="line">    np.random.shuffle(arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>使用下面的代码画出打乱后的索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(lena[np.ix_(xindices, yindices)])</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li>视图</li>
</ol>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%20Data%20Analysis/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20NumPy%E6%95%B0%E7%BB%84/4.png" alt="4"></p>
<h3 id="2-10-用布尔型变量索引NumPy数组"><a href="#2-10-用布尔型变量索引NumPy数组" class="headerlink" title="2.10  用布尔型变量索引NumPy数组"></a>2.10  用布尔型变量索引NumPy数组</h3><p>布尔型索引是指根据布尔型数组来索引元素的方法，属于花式索引系列。</p>
<p>因为布尔型索引是花式索引的一个分类，所以它们的使用方法基本相同。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.misc</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lena = scipy.misc.ascent()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_indices</span><span class="params">(size)</span>:</span></span><br><span class="line">    arr = np.arange(size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr%<span class="number">4</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">lena1 = lena.copy()</span><br><span class="line"></span><br><span class="line">xindices = get_indices(lena.shape[<span class="number">0</span>])</span><br><span class="line">yindices = get_indices(lena.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">lena1[xindices, yindices] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.imshow(lena1)</span><br><span class="line"></span><br><span class="line">lena2 = lena.copy()</span><br><span class="line">lena2[(lena &gt; lena.max()/<span class="number">4</span>) &amp; (lena &lt; <span class="number">3</span> * lena.max()/<span class="number">4</span>)] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.imshow(lena2)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>上述代码利用一种特殊的迭代器对象来索引元素，下面进行简单说明。</p>
<ol>
<li><p>在对角线上画点。</p>
<p>这类似于花式索引，不过这里选择的是照片对照线上可以被 4 整除的那些位置上的点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_indices</span><span class="params">(size)</span>:</span></span><br><span class="line">    arr = np.arange(size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr%<span class="number">4</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   然后仅绘出选定的那些点</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lena1 = lena.copy()</span><br><span class="line"></span><br><span class="line">xindices = get_indices(lena.shape[0])</span><br><span class="line">yindices = get_indices(lena.shape[1])</span><br><span class="line"></span><br><span class="line">lena1[xindices, yindices] = 0</span><br><span class="line"></span><br><span class="line">plt.subplot(211)</span><br><span class="line">plt.imshow(lena1)</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>根据元素值的情况置0</p>
<p>选取数组之介于最大值的1/4 到 3/4 到那些元素，将其置0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lena2[(lena &gt; lena.max()/<span class="number">4</span>) &amp; (lena &lt; <span class="number">3</span> * lena.max()/<span class="number">4</span>)] = <span class="number">0</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li>两幅新照片如图</li>
</ol>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%20Data%20Analysis/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20NumPy%E6%95%B0%E7%BB%84/5.png" alt="5"></p>
<h3 id="2-11-NumPy数组的广播"><a href="#2-11-NumPy数组的广播" class="headerlink" title="2.11  NumPy数组的广播"></a>2.11  NumPy数组的广播</h3><p>当操作对象的形状不一样，NumPy会尽力进行处理。</p>
<p>例如，假设一个数组要跟一个标量相乘，这时标量需要根据数组的形状进行扩展。然后才可以执行乘法运算，这个扩展的过程叫做 <strong>广播(broadcasting)</strong>。</p>
<p>下面用代码加以说明。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.io.wavfile</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">response = request.urlopen(</span><br><span class="line">    <span class="string">'http://www.crt.com.cn/hsmx/images/hsgq.mp3'</span></span><br><span class="line">    <span class="comment"># 'http://www.thesoundarchive.com/austinpowers/smashingbaby.wav'</span></span><br><span class="line">)</span><br><span class="line">print(response.info())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WAV_FILE = <span class="string">'smashingbaby.wav'</span></span><br><span class="line"></span><br><span class="line">filehandle = open(WAV_FILE, <span class="string">'wb'</span>)</span><br><span class="line">filehandle.write(response.read())</span><br><span class="line">filehandle.close()</span><br><span class="line"></span><br><span class="line">sample_rate, data = scipy.io.wavfile.read(WAV_FILE)</span><br><span class="line">print(<span class="string">"Data type"</span>, data.dtype, <span class="string">"Shape"</span>, data.shape)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">"Original"</span>)</span><br><span class="line">plt.plot(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">newdata = data * <span class="number">0.2</span></span><br><span class="line">newdata = newdata.astype(np.uint8)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Data type"</span>, newdata.dtype, <span class="string">"Shape"</span>, newdata.shape)</span><br><span class="line"></span><br><span class="line">scipy.io.wavfile.write(<span class="string">"quiet.wav"</span>, sample_rate, newdata)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.title(<span class="string">"Quiet"</span>)</span><br><span class="line">plt.plot(newdata)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/04/python全栈/第02部分：并发编程+数据库+前端/并发编程/线程（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/04/python全栈/第02部分：并发编程+数据库+前端/并发编程/线程（一）/" itemprop="url">线程（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-04T18:43:22+08:00">
                2019-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-02部分-并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -02部分 -并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="（一）操作系统线程理论"><a href="#（一）操作系统线程理论" class="headerlink" title="（一）操作系统线程理论"></a>（一）操作系统线程理论</h2><h3 id="一、线程概念的引入背景"><a href="#一、线程概念的引入背景" class="headerlink" title="一、线程概念的引入背景"></a>一、线程概念的引入背景</h3><h4 id="1、线程"><a href="#1、线程" class="headerlink" title="1、线程"></a>1、线程</h4><p>​        之前我们已经了解了操作系统中进程的概念，程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</p>
<h4 id="2、有了进程为什么要有线程"><a href="#2、有了进程为什么要有线程" class="headerlink" title="2、有了进程为什么要有线程"></a>2、有了进程为什么要有线程</h4><p>​        进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：</p>
<ul>
<li>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</li>
<li>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</li>
</ul>
<p>　　如果这两个缺点理解比较困难的话，举个现实的例子也许你就清楚了：如果把我们上课的过程看成一个进程的话，那么我们要做的是耳朵听老师讲课，手上还要记笔记，脑子还要思考问题，这样才能高效的完成听课的任务。而如果只提供进程这个机制的话，上面这三件事将不能同时执行，同一时间只能做一件事，听的时候就不能记笔记，也不能用脑子思考，这是其一；如果老师在黑板上写演算过程，我们开始记笔记，而老师突然有一步推不下去了，阻塞住了，他在那边思考着，而我们呢，也不能干其他事，即使你想趁此时思考一下刚才没听懂的一个问题都不行，这是其二。</p>
<p>　　现在你应该明白了进程的缺陷了，而解决的办法很简单，我们完全可以让听、写、思三个独立的过程，并行起来，这样很明显可以提高听课的效率。而实际的操作系统中，也同样引入了这种类似的机制——线程。</p>
<h4 id="3、线程的出现"><a href="#3、线程的出现" class="headerlink" title="3、线程的出现"></a>3、线程的出现</h4><p>​        60年代，在OS中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入<strong>轻型进程</strong>；二是由于对称多处理机（SMP）出现，<strong>可以满足多个运行单位</strong>，而多个进程并行开销过大。</p>
<p>　　因此在80年代，出现了<strong>能独立运行的基本单位</strong>——线程（Threads）<strong>。</strong></p>
<p>　　<strong>注意：进程是资源分配的最小单位,线程是CPU调度的最小单位.</strong></p>
<p>　　　　　<strong>每一个进程中至少有一个线程。</strong></p>
<h3 id="二、进程和线程的关系"><a href="#二、进程和线程的关系" class="headerlink" title="二、进程和线程的关系"></a>二、进程和线程的关系</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/14.png" alt></p>
<p><strong>线程与进程的区别</strong>可以归纳为以下4点：</p>
<p>　　1）地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</p>
<p>　　2）通信：<a href="https://baike.baidu.com/item/进程间通信" target="_blank" rel="noopener">进程间通信</a><a href="https://baike.baidu.com/item/IPC" target="_blank" rel="noopener">IPC</a>，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要<a href="https://baike.baidu.com/item/进程同步" target="_blank" rel="noopener">进程同步</a>和互斥手段的辅助，以保证数据的一致性。</p>
<p>　　3）调度和切换：线程上下文切换比进程上下文切换要快得多。</p>
<p>　　4）在多线程操作系统中，进程不是一个可执行的实体。</p>
<p>　　<a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">通过漫画了解线程进城</a></p>
<h3 id="三、线程的特点"><a href="#三、线程的特点" class="headerlink" title="三、线程的特点"></a>三、线程的特点</h3><p>在多线程的操作系统中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。</p>
<p>　　1）轻型实体</p>
<p>　　线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。</p>
<p>　　线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCB包括以下信息：</span><br><span class="line">（1）线程状态。</span><br><span class="line">（2）当线程不运行时，被保存的现场资源。</span><br><span class="line">（3）一组执行堆栈。</span><br><span class="line">（4）存放每个线程的局部变量主存区。</span><br><span class="line">（5）访问同一个进程中的主存和其它资源。</span><br><span class="line">用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</span><br></pre></td></tr></table></figure>

<p>　　2）独立调度和分派的基本单位。</p>
<p>　　在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</p>
<p>　　3）共享进程资源。</p>
<p>　　线程在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的进程id，这意味着，线程可以访问该进程的每一个内存资源；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。</p>
<p>　　4<em>）可并发执行。</em></p>
<p>　　<em>在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</em></p>
<h3 id="四、使用线程的实际场景"><a href="#四、使用线程的实际场景" class="headerlink" title="四、使用线程的实际场景"></a>四、使用线程的实际场景</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/15.png" alt></p>
<p>​        开启一个字处理软件进程，该进程肯定需要办不止一件事情，比如监听键盘输入，处理文字，定时自动将文字保存到硬盘，这三个任务操作的都是同一块数据，因而不能用多进程。只能在一个进程里并发地开启三个线程,如果是单线程，那就只能是，键盘输入时，不能处理文字和自动保存，自动保存时又不能输入和处理文字。</p>
<h3 id="五、内存中的线程"><a href="#五、内存中的线程" class="headerlink" title="五、内存中的线程"></a>五、内存中的线程</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/16.png" alt></p>
<p>​        多个线程共享同一个进程的地址空间中的资源，是对一台计算机上多个进程的模拟，有时也称线程为轻量级的进程。</p>
<p>　　而对一台计算机上多个进程，则共享物理内存、磁盘、打印机等其他物理资源。多线程的运行也多进程的运行类似，是cpu在多个线程之间的快速切换。</p>
<p>　　不同的进程之间是充满敌意的，彼此是抢占、竞争cpu的关系，如果迅雷会和QQ抢资源。而同一个进程是由一个程序员的程序创建，所以同一进程内的线程是合作关系，一个线程可以访问另外一个线程的内存地址，大家都是共享的，一个线程干死了另外一个线程的内存，那纯属程序员脑子有问题。</p>
<p>　　类似于进程，每个线程也有自己的堆栈，不同于进程，线程库无法利用时钟中断强制线程让出CPU，可以调用thread_yield运行线程自动放弃cpu，让另外一个线程运行。</p>
<p>　　线程通常是有益的，但是带来了不小程序设计难度，线程的问题是：</p>
<p>　　1. 父进程有多个线程，那么开启的子线程是否需要同样多的线程</p>
<p>　　2. 在同一个进程中，如果一个线程关闭了文件，而另外一个线程正准备往该文件内写内容呢？</p>
<p>　　因此，在多线程的代码中，需要更多的心思来设计程序的逻辑、保护程序的数据。</p>
<h3 id="六、用户级线程和内核级线程（了解）"><a href="#六、用户级线程和内核级线程（了解）" class="headerlink" title="六、用户级线程和内核级线程（了解）"></a>六、用户级线程和内核级线程（了解）</h3><p>​        线程的实现可以分为两类：用户级线程(User-Level Thread)和内核线线程(Kernel-Level Thread)，后者又称为内核支持的线程或轻量级进程。在多线程操作系统中，各个系统的实现方式并不相同，在有的系统中实现了用户级线程，有的系统中实现了内核级线程。</p>
<h4 id="1、用户级线程"><a href="#1、用户级线程" class="headerlink" title="1、用户级线程"></a>1、用户级线程</h4><p>​        内核的切换由用户态程序自己控制内核切换,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/17.png" alt></p>
<p>​        在用户空间模拟操作系统对进程的调度，来调用一个进程中的线程，每个进程中都会有一个运行时系统，用来调度线程。此时当该进程获取cpu时，进程内再调度出一个线程去执行，同一时刻只有一个线程执行。</p>
<h4 id="2、内核级线程"><a href="#2、内核级线程" class="headerlink" title="2、内核级线程"></a>2、内核级线程</h4><p>​        内核级线程:切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/18.png" alt></p>
<h4 id="3、用户级与内核级线程的对比"><a href="#3、用户级与内核级线程的对比" class="headerlink" title="3、用户级与内核级线程的对比"></a>3、用户级与内核级线程的对比</h4><p>用户级线程和内核级线程的区别:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。</span><br><span class="line">用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。</span><br><span class="line">用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。</span><br><span class="line">在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。</span><br><span class="line">用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。</span><br></pre></td></tr></table></figure>

<p>内核线程的优缺点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：当有多个处理机时，一个进程的多个线程可以同时执行。</span><br><span class="line">缺点：由内核进行调度。</span><br></pre></td></tr></table></figure>

<p>用户级线程的优缺点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">		线程的调度不需要内核直接参与，控制简单。</span><br><span class="line">		可以在不支持线程的操作系统中实现。</span><br><span class="line">		创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。</span><br><span class="line">		允许每个进程定制自己的调度算法，线程管理比较灵活。</span><br><span class="line">		线程能够利用的表空间和堆栈空间比内核级线程多。</span><br><span class="line">		同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题。</span><br><span class="line">		</span><br><span class="line">缺点：</span><br><span class="line">		资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</span><br></pre></td></tr></table></figure>

<h4 id="4、混合实现"><a href="#4、混合实现" class="headerlink" title="4、混合实现"></a>4、混合实现</h4><p>用户级与内核级的多路复用，内核同一调度内核线程，每个内核线程对应n个用户线程</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/19.png" alt></p>
<p><strong>Linux操作系统的NPTL</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">历史</span><br><span class="line">		在内核2.6以前的调度实体都是进程，内核并没有真正支持线程。它是能过一个系统调用clone()来实现的，这个调用创建了一份调用进程的拷贝，跟fork()不同的是,这份进程拷贝完全共享了调用进程的地址空间。LinuxThread就是通过这个系统调用来提供线程在内核级的支持的(许多以前的线程实现都完全是在用户态，内核根本不知道线程的存在)。非常不幸的是，这种方法有相当多的地方没有遵循POSIX标准，特别是在信号处理，调度，进程间通信原语等方面。</span><br><span class="line"></span><br><span class="line">		很显然，为了改进LinuxThread必须得到内核的支持，并且需要重写线程库。为了实现这个需求，开始有两个相互竞争的项目：IBM启动的NGTP(Next Generation POSIX Threads)项目，以及Redhat公司的NPTL。在2003年的年中，IBM放弃了NGTP，也就是大约那时，Redhat发布了最初的NPTL。</span><br><span class="line"></span><br><span class="line">		NPTL最开始在redhat linux 9里发布，现在从RHEL3起内核2.6起都支持NPTL，并且完全成了GNU C库的一部分。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设计</span><br><span class="line">		NPTL使用了跟LinuxThread相同的办法，在内核里面线程仍然被当作是一个进程，并且仍然使用了clone()系统调用(在NPTL库里调用)。但是，NPTL需要内核级的特殊支持来实现，比如需要挂起然后再唤醒线程的线程同步原语futex.</span><br><span class="line"></span><br><span class="line">		NPTL也是一个1*1的线程库，就是说，当你使用pthread_create()调用创建一个线程后，在内核里就相应创建了一个调度实体，在linux里就是一个新进程，这个方法最大可能的简化了线程的实现。</span><br><span class="line"></span><br><span class="line">		除NPTL的1*1模型外还有一个m*n模型，通常这种模型的用户线程数会比内核的调度实体多。在这种实现里，线程库本身必须去处理可能存在的调度，这样在线程库内部的上下文切换通常都会相当的快，因为它避免了系统调用转到内核态。然而这种模型增加了线程实现的复杂性,并可能出现诸如优先级反转的问题，此外，用户态的调度如何跟内核态的调度进行协调也是很难让人满意。</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/03/python全栈/第02部分：并发编程+数据库+前端/并发编程/进程（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/03/python全栈/第02部分：并发编程+数据库+前端/并发编程/进程（二）/" itemprop="url">进程（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-03T20:37:27+08:00">
                2019-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-02部分-并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -02部分 -并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="（二）在python程序中的进程操作"><a href="#（二）在python程序中的进程操作" class="headerlink" title="（二）在python程序中的进程操作"></a>（二）在python程序中的进程操作</h2><p>​        之前我们已经了解了很多进程相关的理论知识，了解进程是什么应该不再困难了，刚刚我们已经了解了，运行中的程序就是一个进程。所有的进程都是通过它的父进程来创建的。因此，运行起来的python程序也是一个进程，那么我们也可以在程序中再创建进程。多个进程可以实现并发效果，也就是说，当我们的程序中存在多个进程的时候，在某些时候，就会让程序的执行速度变快。以我们之前所学的知识，并不能实现创建进程这个功能，所以我们就需要借助python中强大的模块。</p>
<h3 id="一、multiprocess模块"><a href="#一、multiprocess模块" class="headerlink" title="一、multiprocess模块"></a>一、multiprocess模块</h3><p>​        仔细说来，multiprocess不是一个模块而是python中一个操作、管理进程的包。 之所以叫multi是取自multiple的多功能的意思,在这个包中几乎包含了和进程有关的所有子模块。由于提供的子模块非常多，为了方便大家归类记忆，我将这部分大致分为四个部分：创建进程部分，进程同步部分，进程池部分，进程之间数据共享。</p>
<h3 id="二、multiprocess-process模块"><a href="#二、multiprocess-process模块" class="headerlink" title="二、multiprocess.process模块"></a>二、multiprocess.process模块</h3><h4 id="1、process模块介绍"><a href="#1、process模块介绍" class="headerlink" title="1、process模块介绍"></a>1、process模块介绍</h4><p>process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</span><br><span class="line"></span><br><span class="line">强调：</span><br><span class="line">1. 需要使用关键字的方式来指定参数</span><br><span class="line">2. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号</span><br><span class="line"></span><br><span class="line">参数介绍：</span><br><span class="line">group参数未使用，值始终为None</span><br><span class="line">target表示调用对象，即子进程要执行的任务</span><br><span class="line">args表示调用对象的位置参数元组，args=(1,2,&apos;egon&apos;,)</span><br><span class="line">kwargs表示调用对象的字典,kwargs=&#123;&apos;name&apos;:&apos;egon&apos;,&apos;age&apos;:18&#125;</span><br><span class="line">name为子进程的名称</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法介绍:</span><br><span class="line">p.start()：启动进程，并调用该子进程中的p.run() </span><br><span class="line">p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  </span><br><span class="line">p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</span><br><span class="line">p.is_alive():如果p仍然运行，返回True</span><br><span class="line">p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性介绍:</span><br><span class="line">p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置</span><br><span class="line">p.name:进程的名称</span><br><span class="line">p.pid：进程的pid</span><br><span class="line">p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)</span><br><span class="line">p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在Windows操作系统中由于没有fork(linux操作系统中创建进程的机制)，在创建子进程的时候会自动 import 启动它的这个文件，而在 import 的时候又执行了整个文件。因此如果将process()直接写在文件中就会无限递归创建子进程报错。所以必须把创建子进程的部分使用if __name__ ==‘__main__’ 判断保护起来，import 的时候  ，就不会递归运行了。</span><br></pre></td></tr></table></figure>

<h4 id="2、使用process模块创建进程"><a href="#2、使用process模块创建进程" class="headerlink" title="2、使用process模块创建进程"></a>2、使用process模块创建进程</h4><p>在一个python进程中开启子进程，start方法和并发效果。</p>
<p>在python中启动的第一个子进程:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line">    print(<span class="string">'我是子进程'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'执行主进程的内容了'</span>)</span><br></pre></td></tr></table></figure>

<p>查看主进程和子进程的进程号:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'子进程id ：'</span>,os.getpid(),<span class="string">'父进程id ：'</span>,os.getppid())</span><br></pre></td></tr></table></figure>

<p>一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(args,args2)</span>:</span></span><br><span class="line">    print(args,args2)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'子进程 :'</span>, os.getpid())</span><br><span class="line">    print(<span class="string">'子进程的父进程 :'</span>, os.getppid())</span><br><span class="line">    print(<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=func,args=(<span class="string">'参数'</span>,<span class="string">'参数2'</span>))   <span class="comment"># 注册，参数必须为元组类型</span></span><br><span class="line">    <span class="comment"># p是一个进程对象,还没有启动进程</span></span><br><span class="line">    p.start()       <span class="comment"># 开启了一个子进程</span></span><br><span class="line">    print(<span class="string">'*'</span>*<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">'父进程 :'</span>,os.getpid()) <span class="comment"># 查看当前进程的进程号</span></span><br><span class="line">    print(<span class="string">'父进程的父进程 :'</span>,os.getppid()) <span class="comment"># 查看当前进程的父进程，即为pyCharm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程的生命周期</span></span><br><span class="line">    <span class="comment"># 主进程</span></span><br><span class="line">    <span class="comment"># 子进程</span></span><br><span class="line">    <span class="comment"># 开启了子进程的主进程 :</span></span><br><span class="line">        <span class="comment"># 主进程自己的代码如果长,等待自己的代码执行结束,</span></span><br><span class="line">        <span class="comment"># 子进程的执行时间长,主进程会在主进程代码执行完毕之后等待子进程执行完毕之后 主进程才结束</span></span><br></pre></td></tr></table></figure>

<p>join方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># join()</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg1,arg2)</span>:</span></span><br><span class="line">    print(<span class="string">'*'</span>*arg1)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'*'</span>*arg2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=func,args=(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line">    p.start()</span><br><span class="line">    print(<span class="string">'hahahaha'</span>)</span><br><span class="line">    p.join()     <span class="comment"># 是感知一个子进程的结束,将异步的程序改为同步</span></span><br><span class="line">    print(<span class="string">'====== : 运行完了'</span>)</span><br></pre></td></tr></table></figure>

<p>进阶，多个进程同时运行（注意，子进程的执行顺序不是根据启动顺序决定的）</p>
<p>多个进程同时运行:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">        p.start()</span><br><span class="line">        p_lst.append(p)</span><br></pre></td></tr></table></figure>

<p>多个进程同时运行，再谈join方法(1):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">        p.start()</span><br><span class="line">        p_lst.append(p)</span><br><span class="line">        p.join()</span><br><span class="line">    <span class="comment"># [p.join() for p in p_lst]</span></span><br><span class="line">    print(<span class="string">'父进程在执行'</span>)</span><br></pre></td></tr></table></figure>

<p>多个进程同时运行，再谈join方法(2):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">        p.start()</span><br><span class="line">        p_lst.append(p)</span><br><span class="line">    <span class="comment"># [p.join() for p in p_lst]</span></span><br><span class="line">    print(<span class="string">'父进程在执行'</span>)</span><br></pre></td></tr></table></figure>

<p>一个实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(filename,content)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(content*<span class="number">10</span>*<span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=func,args=(<span class="string">'info%s'</span>%i,<span class="number">0</span>))</span><br><span class="line">        p_lst.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_lst:p.join()   <span class="comment"># 之前的所有进程必须在这里都执行完才能执行下面的代码</span></span><br><span class="line">    print([i <span class="keyword">for</span> i <span class="keyword">in</span> os.walk(<span class="string">r'/Users/hhh/Desktop/python/全栈/第02部分：并发编程+数据库+前端/并发编程/day37'</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程写文件</span></span><br><span class="line"><span class="comment"># 首先往文件夹中写文件</span></span><br><span class="line"><span class="comment"># 向用户展示写入文件之后文件夹中所有的文件名（此步骤应该确保所有写文件操作已经结束）———— 这就是应用场景</span></span><br></pre></td></tr></table></figure>

<p>除了上面这些开启进程的方法，还有一种以继承Process类的形式开启进程的方式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(os.getpid)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  print(<span class="string">'主：'</span>, os.getpid())</span><br><span class="line">  p1 = MyProcess()</span><br><span class="line">  p1.start()</span><br><span class="line">  p2 = MyProcess()</span><br><span class="line">  p2.start()</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 自定义类 继承Process类</span></span><br><span class="line"><span class="comment"># 必须实现一个run方法,run方法中是在子进程中执行的代码</span></span><br><span class="line"><span class="comment"># start()内部会实现run()方法</span></span><br></pre></td></tr></table></figure>

<p>传参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,arg1,arg2)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.arg1 = arg1</span><br><span class="line">        self.arg2 = arg2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.pid)</span><br><span class="line">        print(self.name)</span><br><span class="line">        print(self.arg1)</span><br><span class="line">        print(self.arg2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p1 = MyProcess(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2 = MyProcess(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    p2.start()</span><br></pre></td></tr></table></figure>

<p>进程之间的数据隔离问题:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进程 与 进程之间</span></span><br><span class="line"><span class="comment"># 几个进程之间，若不通过特殊手段，无法共享数据</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n   <span class="comment"># 声明了一个全局变量</span></span><br><span class="line">    n = <span class="number">0</span>       <span class="comment"># 重新定义了一个n</span></span><br><span class="line">    print(<span class="string">'pid : %s'</span>%os.getpid(),n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = <span class="number">100</span></span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(os.getpid(),n)</span><br></pre></td></tr></table></figure>

<h4 id="3、守护进程"><a href="#3、守护进程" class="headerlink" title="3、守护进程"></a>3、守护进程</h4><p>会随着主进程的结束而结束。</p>
<p>主进程创建守护进程</p>
<p>　　其一：守护进程会在主进程代码执行结束后就终止</p>
<p>　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children</p>
<p>注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子进程 -- &gt; 守护进程</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        print(<span class="string">'我还活着'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in func2 start'</span>)</span><br><span class="line">    time.sleep(<span class="number">8</span>)</span><br><span class="line">    print(<span class="string">'in func2 finished'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.daemon = <span class="literal">True</span>   <span class="comment"># 设置子进程为守护进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    p2 = Process(target=func2)</span><br><span class="line">    p2.start()</span><br><span class="line">    p2.terminate()     <span class="comment"># 结束一个子进程</span></span><br><span class="line">    print(p2.is_alive())  <span class="comment"># 检验一个进程是否还活着</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(p2.is_alive())  <span class="comment"># 检验一个进程是否还活着</span></span><br><span class="line">    print(p2.name)</span><br><span class="line">    <span class="comment"># i = 0</span></span><br><span class="line">    <span class="comment"># while i&lt;5:</span></span><br><span class="line">    <span class="comment">#     print('我是socket server')</span></span><br><span class="line">    <span class="comment">#     time.sleep(1)</span></span><br><span class="line">    <span class="comment">#     i+=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 守护进程 会 随着 主进程的代码（而不是主进程）执行完毕 而 结束</span></span><br><span class="line"><span class="comment"># 在主进程内结束一个子进程 p.terminate()</span></span><br><span class="line">    <span class="comment">#  结束一个进程不是在执行方法之后立即生效,需要一个操作系统响应的过程</span></span><br><span class="line"><span class="comment"># 检验一个进程是否活着的状态 p.is_alive()</span></span><br><span class="line"><span class="comment"># p.name p.pid 这个进程的名字和进程号</span></span><br></pre></td></tr></table></figure>

<h4 id="4、socket聊天开发实例"><a href="#4、socket聊天开发实例" class="headerlink" title="4、socket聊天开发实例"></a>4、socket聊天开发实例</h4><p>server端:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span><span class="params">(conn)</span>:</span></span><br><span class="line">    ret = <span class="string">'你好'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    conn.send(ret)</span><br><span class="line">    msg = conn.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    print(msg)</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br><span class="line">    sk = socket.socket()</span><br><span class="line">    sk.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line">    sk.listen()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            conn,addr = sk.accept()</span><br><span class="line">            p = Process(target=serve,args=(conn,))</span><br><span class="line">            p.start()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sk.close()</span><br></pre></td></tr></table></figure>

<p>client端:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">msg = sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(msg)</span><br><span class="line">msg2 = input(<span class="string">'&gt;&gt;&gt;'</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">sk.send(msg2)</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<h4 id="5、多进程中的其他方法"><a href="#5、多进程中的其他方法" class="headerlink" title="5、多进程中的其他方法"></a>5、多进程中的其他方法</h4><p>进程对象的其他方法 :  terminate,  is_alive</p>
<p>​        在主进程内结束一个子进程 p.terminate()<br>​             结束一个进程不是在执行方法之后立即生效,需要一个操作系统响应的过程<br>​        检验一个进程是否活着的状态 p.is_alive()</p>
<p>进程对象的其他属性 : pid和name</p>
<p>​        p.name      p.pid 这个进程的名字和进程号</p>
<h3 id="三、进程同步（multiprocess-Lock）"><a href="#三、进程同步（multiprocess-Lock）" class="headerlink" title="三、进程同步（multiprocess.Lock）"></a>三、进程同步（multiprocess.Lock）</h3><h4 id="1、锁-——-multiprocess-Lock"><a href="#1、锁-——-multiprocess-Lock" class="headerlink" title="1、锁 —— multiprocess.Lock"></a>1、锁 —— multiprocess.Lock</h4><pre><code>通过刚刚的学习，我们千方百计实现了程序的异步，让多个任务可以同时在几个进程中并发处理，他们之间的运行没有顺序，一旦开启也不受我们控制。尽管并发编程让我们能更加充分的利用IO资源，但是也给我们带来了新的问题。</code></pre><p>　　  当多个进程使用同一份数据资源的时候，就会引发数据安全或顺序混乱问题。</p>
<p>多进程抢占输出资源:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s: %s is running'</span> %(n,os.getpid()))</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    print(<span class="string">'%s:%s is done'</span> %(n,os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p=Process(target=work,args=(i,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>使用锁维护执行顺序:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由并发变成了串行,牺牲了运行效率,但避免了竞争</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(lock,n)</span>:</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    print(<span class="string">'%s: %s is running'</span> % (n, os.getpid()))</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    print(<span class="string">'%s: %s is done'</span> % (n, os.getpid()))</span><br><span class="line">    lock.release()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock=Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p=Process(target=work,args=(lock,i))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>​        上面这种情况虽然使用加锁的形式实现了顺序的执行，但是程序又重新变成串行了，这样确实会浪费了时间，却保证了数据的安全。</p>
<p>　　接下来，我们以模拟抢票为例，来看看数据安全的重要性。</p>
<p>多进程同时抢购余票:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件db的内容为：&#123;"count":1&#125;</span></span><br><span class="line"><span class="comment">#注意一定要用双引号，不然json无法识别</span></span><br><span class="line"><span class="comment">#并发运行，效率高，但竞争写同一文件，数据写入错乱</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"><span class="keyword">import</span> time,json,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    dic=json.load(open(<span class="string">'db'</span>))</span><br><span class="line">    print(<span class="string">'\033[43m剩余票数%s\033[0m'</span> %dic[<span class="string">'count'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    dic=json.load(open(<span class="string">'db'</span>))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>) <span class="comment">#模拟读数据的网络延迟</span></span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">'count'</span>] &gt;<span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">'count'</span>]-=<span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>) <span class="comment">#模拟写数据的网络延迟</span></span><br><span class="line">        json.dump(dic,open(<span class="string">'db'</span>,<span class="string">'w'</span>))</span><br><span class="line">        print(<span class="string">'\033[43m购票成功\033[0m'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    search()</span><br><span class="line">    get()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): <span class="comment">#模拟并发100个客户端抢票</span></span><br><span class="line">        p=Process(target=task)</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>使用锁来保证数据安全:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件db的内容为：&#123;"count":5&#125;</span></span><br><span class="line"><span class="comment">#注意一定要用双引号，不然json无法识别</span></span><br><span class="line"><span class="comment">#并发运行，效率高，但竞争写同一文件，数据写入错乱</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"><span class="keyword">import</span> time,json,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    dic=json.load(open(<span class="string">'db'</span>))</span><br><span class="line">    print(<span class="string">'\033[43m剩余票数%s\033[0m'</span> %dic[<span class="string">'count'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    dic=json.load(open(<span class="string">'db'</span>))</span><br><span class="line">    time.sleep(random.random()) <span class="comment">#模拟读数据的网络延迟</span></span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">'count'</span>] &gt;<span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">'count'</span>]-=<span class="number">1</span></span><br><span class="line">        time.sleep(random.random()) <span class="comment">#模拟写数据的网络延迟</span></span><br><span class="line">        json.dump(dic,open(<span class="string">'db'</span>,<span class="string">'w'</span>))</span><br><span class="line">        print(<span class="string">'\033[32m购票成功\033[0m'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'\033[31m购票失败\033[0m'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(lock)</span>:</span></span><br><span class="line">    search()</span><br><span class="line">    lock.acquire()</span><br><span class="line">    get()</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): <span class="comment">#模拟并发100个客户端抢票</span></span><br><span class="line">        p=Process(target=task,args=(lock,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。</span><br><span class="line">虽然可以用文件共享数据实现进程间通信，但问题是：</span><br><span class="line">1.效率低（共享数据基于文件，而文件是硬盘上的数据）</span><br><span class="line">2.需要自己加锁处理</span><br><span class="line"></span><br><span class="line">#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2、帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。</span><br><span class="line">队列和管道都是将数据存放于内存中</span><br><span class="line">队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，</span><br><span class="line">我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。</span><br></pre></td></tr></table></figure>

<h4 id="2、信号量——-multiprocess-Semaphore"><a href="#2、信号量——-multiprocess-Semaphore" class="headerlink" title="2、信号量—— multiprocess.Semaphore"></a>2、信号量—— multiprocess.Semaphore</h4><p>一套资源  同一时间 只能被n个人访问<br>某一段代码 同一时间 只能被n个进程执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Semaphore</span><br><span class="line"></span><br><span class="line"><span class="comment"># sem = Semaphore(4)</span></span><br><span class="line"><span class="comment"># sem.acquire()</span></span><br><span class="line"><span class="comment"># print('拿到第一把钥匙')</span></span><br><span class="line"><span class="comment"># sem.acquire()</span></span><br><span class="line"><span class="comment"># print('拿到第二把钥匙')</span></span><br><span class="line"><span class="comment"># sem.acquire()</span></span><br><span class="line"><span class="comment"># print('拿到第三把钥匙')</span></span><br><span class="line"><span class="comment"># sem.acquire()</span></span><br><span class="line"><span class="comment"># print('拿到第四把钥匙')</span></span><br><span class="line"><span class="comment"># sem.acquire()</span></span><br><span class="line"><span class="comment"># print('拿到第五把钥匙')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ktv</span><span class="params">(i,sem)</span>:</span></span><br><span class="line">    sem.acquire()    <span class="comment">#获取钥匙</span></span><br><span class="line">    print(<span class="string">'%s走进ktv'</span>%i)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">5</span>))</span><br><span class="line">    print(<span class="string">'%s走出ktv'</span>%i)</span><br><span class="line">    sem.release()   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br><span class="line">    sem = Semaphore(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        p = Process(target=ktv,args=(i,sem))</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁是只有一个进程能进行，而信号量可以允许n个进程同时进行</span></span><br><span class="line"><span class="comment"># 也是引入锁的机制，但加上计数器</span></span><br><span class="line">    <span class="comment"># 每次acquire时+1，release时-1</span></span><br></pre></td></tr></table></figure>

<h4 id="3、事件——-multiprocess-Event"><a href="#3、事件——-multiprocess-Event" class="headerlink" title="3、事件—— multiprocess.Event"></a>3、事件—— multiprocess.Event</h4><p>事件：通过一个信号 来控制 多个进程 同时 执行或者阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一个信号可以使所有的进程都进入阻塞状态</span><br><span class="line"># 也可以控制所有的进程解除阻塞</span><br><span class="line"># 一个事件被创建之后,默认是阻塞状态</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Event</span><br><span class="line"></span><br><span class="line">e = Event()  <span class="comment"># 创建了一个事件</span></span><br><span class="line">print(e.is_set())   <span class="comment"># 查看一个事件的状态,默认被设置成阻塞</span></span><br><span class="line">e.set()      <span class="comment"># 将这个事件的状态改为True</span></span><br><span class="line">print(e.is_set())</span><br><span class="line">e.wait()     <span class="comment"># 是依据e.is_set()的值来决定是否阻塞的</span></span><br><span class="line">print(<span class="number">123456</span>)</span><br><span class="line">e.clear()    <span class="comment"># 将这个事件的状态改为False</span></span><br><span class="line">print(e.is_set())</span><br><span class="line">e.wait()     <span class="comment"># 等待 事件的信号被变成True</span></span><br><span class="line">print(<span class="string">'*'</span>*<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set 和 clear</span><br><span class="line">     分别用来修改一个事件的状态 True或者False</span><br><span class="line">is_set 用来查看一个事件的状态</span><br><span class="line">wait 是依据事件的状态来决定自己是否在wait处阻塞</span><br><span class="line">     False阻塞 True不阻塞</span><br></pre></td></tr></table></figure>

<p>红绿灯事件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Event,Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cars</span><span class="params">(e,i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> e.is_set():</span><br><span class="line">        print(<span class="string">'car%i在等待'</span>%i)</span><br><span class="line">        e.wait()    <span class="comment"># 阻塞 直到得到一个 事件状态变成 True 的信号</span></span><br><span class="line">    print(<span class="string">'\033[0;32;40mcar%i通过\033[0m'</span> % i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">light</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> e.is_set():</span><br><span class="line">            e.clear()</span><br><span class="line">            print(<span class="string">'\033[31m红灯亮了\033[0m'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            e.set()</span><br><span class="line">            print(<span class="string">'\033[32m绿灯亮了\033[0m'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if not car.is_alive():</span></span><br><span class="line">        <span class="comment">#     break</span></span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    e = Event()</span><br><span class="line">    traffic = Process(target=light,args=(e,))</span><br><span class="line">    traffic.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        car = Process(target=cars, args=(e,i))</span><br><span class="line">        car.start()</span><br><span class="line">        time.sleep(random.random())</span><br></pre></td></tr></table></figure>

<h3 id="四、进程间通信——-队列（multiprocess-Queue）"><a href="#四、进程间通信——-队列（multiprocess-Queue）" class="headerlink" title="四、进程间通信—— 队列（multiprocess.Queue）"></a>四、进程间通信—— 队列（multiprocess.Queue）</h3><h4 id="1、进程间通信"><a href="#1、进程间通信" class="headerlink" title="1、进程间通信"></a>1、进程间通信</h4><p><strong>IPC</strong>(Inter-Process Communication)</p>
<h4 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h4><h5 id="（1）概念介绍"><a href="#（1）概念介绍" class="headerlink" title="（1）概念介绍"></a>（1）概念介绍</h5><p>创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Queue([maxsize]) </span><br><span class="line">创建共享的进程队列。</span><br><span class="line">参数 ：maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。</span><br><span class="line">底层队列使用管道和锁定实现。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">方法介绍:</span><br><span class="line">Queue([maxsize]) </span><br><span class="line">创建共享的进程队列。maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。底层队列使用管道和锁定实现。另外，还需要运行支持线程以便队列中的数据传输到底层管道中。 </span><br><span class="line">Queue的实例q具有以下方法：</span><br><span class="line"></span><br><span class="line">q.get( [ block [ ,timeout ] ] ) </span><br><span class="line">返回q中的一个项目。如果q为空，此方法将阻塞，直到队列中有项目可用为止。block用于控制阻塞行为，默认为True. 如果设置为False，将引发Queue.Empty异常（定义在Queue模块中）。timeout是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可用，将引发Queue.Empty异常。</span><br><span class="line"></span><br><span class="line">q.get_nowait( ) </span><br><span class="line">同q.get(False)方法。</span><br><span class="line"></span><br><span class="line">q.put(item [, block [,timeout ] ] ) </span><br><span class="line">将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常（定义在Queue库模块中）。timeout指定在阻塞模式中等待可用空间的时间长短。超时后将引发Queue.Full异常。</span><br><span class="line"></span><br><span class="line">q.qsize() </span><br><span class="line">返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发NotImplementedError异常。</span><br><span class="line"></span><br><span class="line">q.empty() </span><br><span class="line">如果调用此方法时 q为空，返回True。如果其他进程或线程正在往队列中添加项目，结果是不可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。</span><br><span class="line"></span><br><span class="line">q.full() </span><br><span class="line">如果q已满，返回为True. 由于线程的存在，结果也可能是不可靠的（参考q.empty（）方法）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">其他方法(了解):</span><br><span class="line">q.close() </span><br><span class="line">关闭队列，防止队列中加入更多数据。调用此方法时，后台线程将继续写入那些已入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将自动调用此方法。关闭队列不会在队列使用者中生成任何类型的数据结束信号或异常。例如，如果某个使用者正被阻塞在get（）操作上，关闭生产者中的队列不会导致get（）方法返回错误。</span><br><span class="line"></span><br><span class="line">q.cancel_join_thread() </span><br><span class="line">不会再进程退出时自动连接后台线程。这可以防止join_thread()方法阻塞。</span><br><span class="line"></span><br><span class="line">q.join_thread() </span><br><span class="line">连接队列的后台线程。此方法用于在调用q.close()方法后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread()方法可以禁止这种行为。</span><br></pre></td></tr></table></figure>

<h5 id="（2）代码实例"><a href="#（2）代码实例" class="headerlink" title="（2）代码实例"></a>（2）代码实例</h5><p>单看队列用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">multiprocessing模块支持进程间通信的两种主要形式:管道和队列</span></span><br><span class="line"><span class="string">都是基于消息传递实现的,但是队列接口</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line">q=Queue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#put ,get ,put_nowait,get_nowait,full,empty</span></span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># q.put(3)   # 如果队列已经满了，程序就会停在这里，等待数据被别人取走，再将数据放入队列。</span></span><br><span class="line">           <span class="comment"># 如果队列中的数据一直不被取走，程序就会永远停在这里。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q.put_nowait(<span class="number">3</span>) <span class="comment"># 可以使用put_nowait，如果队列满了不会阻塞，但是会因为队列满了而报错。</span></span><br><span class="line"><span class="keyword">except</span>: <span class="comment"># 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去，但是会丢掉这个消息。</span></span><br><span class="line">    print(<span class="string">'队列已经满了'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此，我们再放入数据之前，可以先看一下队列的状态，如果已经满了，就不继续put了。</span></span><br><span class="line">print(q.full()) <span class="comment">#满了</span></span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="comment"># print(q.get()) # 同put方法一样，如果队列已经空了，那么继续取就会出现阻塞。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q.get_nowait(<span class="number">3</span>) <span class="comment"># 可以使用get_nowait，如果队列满了不会阻塞，但是会因为没取到值而报错。</span></span><br><span class="line"><span class="keyword">except</span>: <span class="comment"># 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去。</span></span><br><span class="line">    print(<span class="string">'队列已经空了'</span>)</span><br><span class="line"></span><br><span class="line">print(q.empty()) <span class="comment">#空了</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子还没有加入进程通信，只是先来看看队列为我们提供的方法，以及这些方法的使用和现象。</p>
<p>子进程发送数据给父进程:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue,Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(q.get())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p = Process(target=produce,args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    c = Process(target=consume, args=(q,))</span><br><span class="line">    c.start()</span><br></pre></td></tr></table></figure>

<p>上面是一个queue的简单应用，使用队列q对象调用get函数来取得队列中最先进入的数据。 接下来看一个稍微复杂一些的例子：</p>
<p>批量生产数据放入队列再批量获取结果 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向queue中输入数据的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inputQ</span><span class="params">(queue)</span>:</span></span><br><span class="line">    info = str(os.getpid()) + <span class="string">'(put):'</span> + str(time.asctime())</span><br><span class="line">    queue.put(info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向queue中输出数据的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outputQ</span><span class="params">(queue)</span>:</span></span><br><span class="line">    info = queue.get()</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'%s%s\033[32m%s\033[0m'</span>%(str(os.getpid()), <span class="string">'(get):'</span>,info))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Main</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    multiprocessing.freeze_support()</span><br><span class="line">    record1 = []   <span class="comment"># store input processes</span></span><br><span class="line">    record2 = []   <span class="comment"># store output processes</span></span><br><span class="line">    queue = multiprocessing.Queue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入进程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        process = multiprocessing.Process(target=inputQ,args=(queue,))</span><br><span class="line">        process.start()</span><br><span class="line">        record1.append(process)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出进程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        process = multiprocessing.Process(target=outputQ,args=(queue,))</span><br><span class="line">        process.start()</span><br><span class="line">        record2.append(process)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> record1:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> record2:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure>

<h5 id="（3）生产者消费者模型"><a href="#（3）生产者消费者模型" class="headerlink" title="（3）生产者消费者模型"></a>（3）生产者消费者模型</h5><p><em>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度</em></p>
<p><strong>为什么要使用生产者和消费者模式</strong></p>
<p><em>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</em></p>
<p><strong>什么是生产者消费者模式</strong></p>
<p><em>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</em></p>
<p><strong>基于队列实现生产者消费者模型</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'\033[45m%s 吃 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">'包子%s'</span> %i</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'\033[44m%s 生产了 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure>

<p>此时的问题是主进程永远不会结束，原因是：生产者p在生产完后就结束了，但是消费者c在取空了q之后，则一直处于死循环中且卡在q.get()这一步。</p>
<p>解决方式无非是让生产者在生产完毕后，往队列中再发一个结束信号，这样消费者在接收到结束信号后就可以break出死循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改良版——生产者消费者模型</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:<span class="keyword">break</span> <span class="comment">#收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'\033[45m%s 吃 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">'包子%s'</span> %i</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'\033[44m%s 生产了 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment">#发送结束信号</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure>

<p>注意：结束信号None，不一定要由生产者发，主进程里同样可以发，但主进程需要等生产者结束后才应该发送该信号</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主进程在生产者生产完毕后发送结束信号None</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:<span class="keyword">break</span> <span class="comment">#收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'\033[45m%s 吃 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">'包子%s'</span> %i</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'\033[44m%s 生产了 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment">#发送结束信号</span></span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure>

<p>但上述解决方式，在有多个生产者和多个消费者时，我们则需要用一个很low的方式去解决</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多个消费者的例子：有几个消费者就需要发送几次结束信号</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:<span class="keyword">break</span> <span class="comment">#收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'\033[45m%s 吃 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(name,q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">'%s%s'</span> %(name,i)</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'\033[44m%s 生产了 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(<span class="string">'包子'</span>,q))</span><br><span class="line">    p2=Process(target=producer,args=(<span class="string">'骨头'</span>,q))</span><br><span class="line">    p3=Process(target=producer,args=(<span class="string">'泔水'</span>,q))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line">    c2=Process(target=consumer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    c1.start()</span><br><span class="line"></span><br><span class="line">    p1.join() <span class="comment">#必须保证生产者全部生产完毕,才应该发送结束信号</span></span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment">#有几个消费者就应该发送几次结束信号None</span></span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment">#发送结束信号</span></span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>JoinableQueue([maxsize])</strong><br>创建可连接的共享进程队列。这就像是一个Queue对象，但队列允许项目的使用者通知生产者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。</p>
<p>方法介绍:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JoinableQueue的实例p除了与Queue对象相同的方法之外，还具有以下方法：</span><br><span class="line"></span><br><span class="line">q.task_done() </span><br><span class="line">使用者使用此方法发出信号，表示q.get()返回的项目已经被处理。如果调用此方法的次数大于从队列中删除的项目数量，将引发ValueError异常。</span><br><span class="line"></span><br><span class="line">q.join() </span><br><span class="line">生产者将使用此方法进行阻塞，直到队列中所有项目均被处理。阻塞将持续到为队列中的每个项目均调用q.task_done()方法为止。 </span><br><span class="line">下面的例子说明如何建立永远运行的进程，使用和处理队列上的项目。生产者将项目放入队列，并等待它们被处理。</span><br></pre></td></tr></table></figure>

<p>JoinableQueue队列实现消费之生产者模型:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,JoinableQueue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'\033[45m%s 吃 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line">        q.task_done() <span class="comment">#向q.join()发送一次信号,证明一个数据已经被取走了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(name,q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">'%s%s'</span> %(name,i)</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'\033[44m%s 生产了 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line">    q.join() <span class="comment">#生产完毕，使用此方法进行阻塞，直到队列中所有项目均被处理。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q=JoinableQueue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(<span class="string">'包子'</span>,q))</span><br><span class="line">    p2=Process(target=producer,args=(<span class="string">'骨头'</span>,q))</span><br><span class="line">    p3=Process(target=producer,args=(<span class="string">'泔水'</span>,q))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line">    c2=Process(target=consumer,args=(q,))</span><br><span class="line">    c1.daemon=<span class="literal">True</span></span><br><span class="line">    c2.daemon=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p_l=[p1,p2,p3,c1,c2]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_l:</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    print(<span class="string">'主'</span>) </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#主进程等---&gt;p1,p2,p3等----&gt;c1,c2</span></span><br><span class="line">    <span class="comment">#p1,p2,p3结束了,证明c1,c2肯定全都收完了p1,p2,p3发到队列的数据</span></span><br><span class="line">    <span class="comment">#因而c1,c2也没有存在的价值了,不需要继续阻塞在进程中影响主进程了。应该随着主进程的结束而结束,所以设置成守护进程就可以了。</span></span><br></pre></td></tr></table></figure>

<p>另一个相似的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,JoinableQueue</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q,name)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        food = q.get()</span><br><span class="line">        print(<span class="string">'\033[31m%s消费了%s\033[0m'</span> % (name,food))</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        q.task_done()     <span class="comment"># count - 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(name,food,q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        f = <span class="string">'%s生产了%s%s'</span>%(name,food,i)</span><br><span class="line">        print(f)</span><br><span class="line">        q.put(f)</span><br><span class="line">    q.join()    <span class="comment"># 阻塞  直到一个队列中的所有数据 全部被处理完毕</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__  == <span class="string">'__main__'</span>:</span><br><span class="line">    q = JoinableQueue(<span class="number">20</span>)</span><br><span class="line">    p1 = Process(target=producer,args=(<span class="string">'Egon'</span>,<span class="string">'包子'</span>,q))</span><br><span class="line">    p2 = Process(target=producer, args=(<span class="string">'wusir'</span>,<span class="string">'泔水'</span>, q))</span><br><span class="line">    c1 = Process(target=consumer, args=(q,<span class="string">'alex'</span>))</span><br><span class="line">    c2 = Process(target=consumer, args=(q,<span class="string">'jinboss'</span>))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    c1.daemon = <span class="literal">True</span>   <span class="comment"># 设置为守护进程 主进程中的代码执行完毕之后,子进程自动结束</span></span><br><span class="line">    c2.daemon = <span class="literal">True</span></span><br><span class="line">    c1.start()</span><br><span class="line">    c2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()      <span class="comment"># 感知一个进程的结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  在消费者这一端:</span></span><br><span class="line">    <span class="comment"># 每次获取一个数据</span></span><br><span class="line">    <span class="comment"># 处理一个数据</span></span><br><span class="line">    <span class="comment"># 发送一个记号 : 标志一个数据被处理成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在生产者这一端:</span></span><br><span class="line">    <span class="comment"># 每一次生产一个数据,</span></span><br><span class="line">    <span class="comment"># 且每一次生产的数据都放在队列中</span></span><br><span class="line">    <span class="comment"># 在队列中刻上一个记号</span></span><br><span class="line">    <span class="comment"># 当生产者全部生产完毕之后,</span></span><br><span class="line">    <span class="comment"># join信号 : 已经停止生产数据了</span></span><br><span class="line">                <span class="comment"># 且要等待之前被刻上的记号都被消费完</span></span><br><span class="line">                <span class="comment"># 当数据都被处理完时,join阻塞结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># consumer 中把所有的任务消耗完</span></span><br><span class="line"><span class="comment"># producer 端 的 join感知到,停止阻塞</span></span><br><span class="line"><span class="comment"># 所有的producer进程结束</span></span><br><span class="line"><span class="comment"># 主进程中的p.join结束</span></span><br><span class="line"><span class="comment"># 主进程中代码结束</span></span><br><span class="line"><span class="comment"># 守护进程(消费者的进程)结束</span></span><br></pre></td></tr></table></figure>

<h4 id="3、管道"><a href="#3、管道" class="headerlink" title="3、管道"></a>3、管道</h4><p>管道可以实现不同进程间的通信。</p>
<p>当管道内无数据时，再接收的话会引发阻塞。</p>
<p>（可通过发送None，通过判断来结束）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pipe,Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(conn1,conn2)</span>:</span></span><br><span class="line">    conn2.close()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span> :</span><br><span class="line">            msg = conn1.recv()</span><br><span class="line">            print(msg)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            conn1.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    conn1, conn2 = Pipe()</span><br><span class="line">    Process(target=func,args = (conn1,conn2)).start()</span><br><span class="line">    conn1.close()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        conn2.send(<span class="string">'吃了么'</span>)</span><br><span class="line">    conn2.close()</span><br></pre></td></tr></table></figure>

<h3 id="五、继承之间的数据共享"><a href="#五、继承之间的数据共享" class="headerlink" title="五、继承之间的数据共享"></a>五、继承之间的数据共享</h3><p>展望未来，基于消息传递的并发编程是大势所趋</p>
<p>即便是使用线程，推荐做法也是将程序设计为大量独立的线程集合，通过消息队列交换数据。</p>
<p>这样极大地减少了对使用锁定和其他同步手段的需求，还可以扩展到分布式系统中。</p>
<p><strong>但进程间应该尽量避免通信，即便需要通信，也应该选择进程安全的工具来避免加锁带来的问题。</strong></p>
<p><strong><em>以后我们会尝试使用数据库来解决现在进程之间的数据共享问题。</em></strong></p>
<p>Manager模块介绍:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进程间数据是独立的，可以借助于队列或管道实现通信，二者都是基于消息传递的</span><br><span class="line">虽然进程间数据独立，但可以通过Manager实现数据共享，事实上Manager的功能远不止于此</span><br><span class="line"></span><br><span class="line">A manager object returned by Manager() controls a server process which holds Python objects and allows other processes to manipulate them using proxies.</span><br><span class="line"></span><br><span class="line">A manager returned by Manager() will support types list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array.</span><br></pre></td></tr></table></figure>

<p>Manager例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager,Process,Lock</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(d,lock)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> lock: <span class="comment">#不加锁而操作共享的数据,肯定会出现数据错乱</span></span><br><span class="line">        d[<span class="string">'count'</span>]-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock=Lock()</span><br><span class="line">    <span class="keyword">with</span> Manager() <span class="keyword">as</span> m:</span><br><span class="line">        dic=m.dict(&#123;<span class="string">'count'</span>:<span class="number">100</span>&#125;)</span><br><span class="line">        p_l=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">            p=Process(target=work,args=(dic,lock))</span><br><span class="line">            p_l.append(p)</span><br><span class="line">            p.start()</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> p_l:</span><br><span class="line">            p.join()</span><br><span class="line">        print(dic)</span><br></pre></td></tr></table></figure>

<h3 id="六、进程池和multiprocess-Pool模块"><a href="#六、进程池和multiprocess-Pool模块" class="headerlink" title="六、进程池和multiprocess.Pool模块"></a>六、进程池和multiprocess.Pool模块</h3><h4 id="1、进程池"><a href="#1、进程池" class="headerlink" title="1、进程池"></a>1、进程池</h4><p>为什么要有进程池?进程池的概念。</p>
<p>​        在程序实际处理问题过程中，忙时会有成千上万的任务需要被执行，闲时可能只有零星任务。那么在成千上万个任务需要被执行的时候，我们就需要去创建成千上万个进程么？首先，创建进程需要消耗时间，销毁进程也需要消耗时间。第二即便开启了成千上万的进程，操作系统也不能让他们同时执行，这样反而会影响程序的效率。因此我们不能无限制的根据任务开启或者结束进程。那么我们要怎么做呢？</p>
<p>​        在这里，要给大家介绍一个进程池的概念，定义一个池子，在里面放上固定数量的进程，有需求来了，就拿一个池中的进程来处理任务，等到处理完毕，进程并不关闭，而是将进程再放回进程池中继续等待任务。如果有很多任务需要执行，池中的进程数量不够，任务就要等待之前的进程执行任务完毕归来，拿到空闲进程才能继续执行。也就是说，池中进程的数量是固定的，那么同一时间最多有固定数量的进程在运行。这样不会增加操作系统的调度难度，还节省了开闭进程的时间，也一定程度上能够实现并发效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">为什么会有进程池的概念</span><br><span class="line">    效率</span><br><span class="line">    每开启进程,开启属于这个进程的内存空间</span><br><span class="line">    寄存器 堆栈 文件</span><br><span class="line">    进程过多 操作系统的调度</span><br><span class="line"></span><br><span class="line">进程池</span><br><span class="line">    python中的 先创建一个属于进程的池子</span><br><span class="line">    这个池子指定能存放n个进程</span><br><span class="line">    先将这些进程创建好</span><br></pre></td></tr></table></figure>

<h4 id="2、multiprocess-Pool模块"><a href="#2、multiprocess-Pool模块" class="headerlink" title="2、multiprocess.Pool模块"></a>2、multiprocess.Pool模块</h4><h5 id="（1）概念介绍-1"><a href="#（1）概念介绍-1" class="headerlink" title="（1）概念介绍"></a>（1）概念介绍</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pool([numprocess  [,initializer [, initargs]]]):创建进程池</span><br></pre></td></tr></table></figure>

<p>参数介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 numprocess:要创建的进程数，如果省略，将默认使用cpu_count()的值</span><br><span class="line">2 initializer：是每个工作进程启动时要执行的可调用对象，默认为None</span><br><span class="line">3 initargs：是要传给initializer的参数组</span><br></pre></td></tr></table></figure>

<p>主要方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.apply(func [, args [, kwargs]]):在一个池工作进程中执行func(*args,**kwargs),然后返回结果。</span><br><span class="line">&apos;&apos;&apos;需要强调的是：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async()&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">p.apply_async(func [, args [, kwargs]]):在一个池工作进程中执行func(*args,**kwargs),然后返回结果。</span><br><span class="line">&apos;&apos;&apos;此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。&apos;&apos;&apos;</span><br><span class="line">   </span><br><span class="line">p.close():关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成</span><br><span class="line"></span><br><span class="line">P.jion():等待所有工作进程退出。此方法只能在close（）或teminate()之后调用</span><br></pre></td></tr></table></figure>

<p>其他方法(了解):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法apply_async()和map_async（）的返回值是AsyncResul的实例obj。实例具有以下方法</span><br><span class="line">obj.get():返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发一场。如果远程操作中引发了异常，它将在调用此方法时再次被引发。</span><br><span class="line">obj.ready():如果调用完成，返回True</span><br><span class="line">obj.successful():如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常</span><br><span class="line">obj.wait([timeout]):等待结果变为可用。</span><br><span class="line">obj.terminate()：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数</span><br></pre></td></tr></table></figure>

<h5 id="（2）代码实例-1"><a href="#（2）代码实例-1" class="headerlink" title="（2）代码实例"></a>（2）代码实例</h5><p><strong>进程池和多进程效率对比</strong></p>
<p>p.map进程池和进程效率测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool,Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    pool = Pool(<span class="number">5</span>)               <span class="comment"># 5个进程</span></span><br><span class="line">    pool.map(func,range(<span class="number">100</span>))    <span class="comment"># 100个任务，第二个参数必须为可迭代对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pool.map(func,range(100))  相当于：</span></span><br><span class="line">    <span class="comment"># for i in range(100):</span></span><br><span class="line">        <span class="comment"># p = Process(target=func,args=(i,))</span></span><br><span class="line">        <span class="comment"># p.start()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool,Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(n+<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    pool = Pool(<span class="number">5</span>)               <span class="comment"># 5个进程</span></span><br><span class="line">    pool.map(func,range(<span class="number">100</span>))    <span class="comment"># 100个任务</span></span><br><span class="line">    pool.map(func2,[(<span class="string">'alex'</span>,<span class="number">1</span>),<span class="string">'egon'</span>])    <span class="comment"># 100个任务</span></span><br><span class="line">    t1 = time.time() - start</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    p_lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        p = Process(target=func,args=(i,))</span><br><span class="line">        p_lst.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_lst :p.join()</span><br><span class="line">    t2 = time.time() - start</span><br><span class="line">    print(t1,t2)</span><br></pre></td></tr></table></figure>

<p><strong>同步和异步</strong></p>
<p>进程池的同步调用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s run'</span> %os.getpid())</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p=Pool(<span class="number">3</span>) <span class="comment">#进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务</span></span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res=p.apply(work,args=(i,)) <span class="comment"># 同步调用，直到本次任务执行完毕拿到res，等待任务work执行的过程中可能有阻塞也可能没有阻塞</span></span><br><span class="line">                                    <span class="comment"># 但不管该任务是否存在阻塞，同步调用都会在原地等着</span></span><br><span class="line">    print(res_l)</span><br></pre></td></tr></table></figure>

<p>进程池的异步调用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s run'</span> %os.getpid())</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p=Pool(<span class="number">3</span>) <span class="comment">#进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务</span></span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res=p.apply_async(work,args=(i,)) <span class="comment"># 异步运行，根据进程池中有的进程数，每次最多3个子进程在异步执行</span></span><br><span class="line">                                          <span class="comment"># 返回结果之后，将结果放入列表，归还进程，之后再执行新的任务</span></span><br><span class="line">                                          <span class="comment"># 需要注意的是，进程池中的三个进程不会同时开启或者同时结束</span></span><br><span class="line">                                          <span class="comment"># 而是执行完一个就释放一个进程，这个进程就去接收新的任务。  </span></span><br><span class="line">        res_l.append(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 异步apply_async用法：如果使用异步提交的任务，主进程需要使用jion，等待进程池内任务都处理完，然后可以用get收集结果</span></span><br><span class="line">    <span class="comment"># 否则，主进程结束，进程池可能还没来得及执行，也就跟着一起结束了</span></span><br><span class="line">    p.close()		<span class="comment"># 结束进程池接收任务</span></span><br><span class="line">    p.join()</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> res_l:</span><br><span class="line">        print(res.get()) <span class="comment">#使用get来获取apply_aync的结果,如果是apply,则没有get方法,因为apply是同步执行,立刻获取结果,也根本无需get</span></span><br></pre></td></tr></table></figure>

<p><strong>练习</strong></p>
<p>server：进程池版socket并发聊天</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send(<span class="string">b'hello'</span>)</span><br><span class="line">    print(conn.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    sk = socket.socket()</span><br><span class="line">    sk.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line">    sk.listen()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, addr = sk.accept()</span><br><span class="line">        p.apply_async(func,args=(conn,))</span><br><span class="line">    sk.close()</span><br></pre></td></tr></table></figure>

<p>client:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">ret = sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(ret)</span><br><span class="line">msg = input(<span class="string">'&gt;&gt;&gt;'</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">sk.send(msg)</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>发现：并发开启多个客户端，服务端同一时间只有4个不同的pid，只能结束一个客户端，另外一个客户端才会进来.</p>
<p><strong>进程池的返回值</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> i*i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res = p.apply(func,args=(i,))   <span class="comment"># apply的结果就是func的返回值</span></span><br><span class="line">        print(res)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> i*i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res = p.apply_async(func,args=(i,))   <span class="comment"># apply的结果就是func的返回值</span></span><br><span class="line">        print(res.get()) <span class="comment">#阻塞 等着 func的计算结果的过程是同步的，即使异步提交</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> i*i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    res_l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res = p.apply_async(func,args=(i,))   <span class="comment"># apply的结果就是func的返回值</span></span><br><span class="line">        res_l.append(res)</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> res_l:</span><br><span class="line">        print(res.get()) <span class="comment">#等着 func的计算结果</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> i*i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    ret = p.map(func,range(<span class="number">100</span>))</span><br><span class="line">    print(ret)</span><br><span class="line">	<span class="comment"># map 自带join和close的</span></span><br></pre></td></tr></table></figure>

<p><strong>回调函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需要回调函数的场景：进程池中任何一个任务一旦处理完了，就立即告知主进程：我好了额，你可以处理我的结果了。主进程则调用一个函数去处理该结果，该函数即回调函数</span><br><span class="line"></span><br><span class="line">我们可以把耗时间（阻塞）的任务放到进程池中，然后指定回调函数（主进程负责执行），这样主进程在执行回调函数时就省去了I/O的过程，直接拿到的是任务的结果。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回调函数</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'in func1'</span>,os.getpid())</span><br><span class="line">    <span class="keyword">return</span> n*n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(nn)</span>:</span></span><br><span class="line">    print(<span class="string">'in func2'</span>,os.getpid())</span><br><span class="line">    print(nn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'主进程 :'</span>,os.getpid())</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p.apply_async(func1,args=(<span class="number">10</span>,),callback=func2)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<p>使用多进程请求多个url来减少网络等待浪费的时间:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="comment"># 200 网页正常的返回</span></span><br><span class="line"><span class="comment"># 404 网页找不到</span></span><br><span class="line"><span class="comment"># 502 504</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url)</span>:</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> url,response.content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_back</span><span class="params">(args)</span>:</span></span><br><span class="line">    url,content = args</span><br><span class="line">    print(url,len(content))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url_lst = [</span><br><span class="line">        <span class="string">'https://www.cnblogs.com/'</span>,</span><br><span class="line">        <span class="string">'http://www.baidu.com'</span>,</span><br><span class="line">        <span class="string">'https://www.sogou.com/'</span>,</span><br><span class="line">        <span class="string">'http://www.sohu.com/'</span>,</span><br><span class="line">    ]</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> url_lst:</span><br><span class="line">        p.apply_async(get,args=(url,),callback=call_back)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;进程%s&gt; get %s'</span> %(os.getpid(),url))</span><br><span class="line">    respone=requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> respone.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'url'</span>:url,<span class="string">'text'</span>:respone.text&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pasrse_page</span><span class="params">(res)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;进程%s&gt; parse %s'</span> %(os.getpid(),res[<span class="string">'url'</span>]))</span><br><span class="line">    parse_res=<span class="string">'url:&lt;%s&gt; size:[%s]\n'</span> %(res[<span class="string">'url'</span>],len(res[<span class="string">'text'</span>]))</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'db.txt'</span>,<span class="string">'a'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(parse_res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    urls=[</span><br><span class="line">        <span class="string">'https://www.baidu.com'</span>,</span><br><span class="line">        <span class="string">'https://www.python.org'</span>,</span><br><span class="line">        <span class="string">'https://www.openstack.org'</span>,</span><br><span class="line">        <span class="string">'https://help.github.com/'</span>,</span><br><span class="line">        <span class="string">'http://www.sina.com.cn/'</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    p=Pool(<span class="number">3</span>)</span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        res=p.apply_async(get_page,args=(url,),callback=pasrse_page)</span><br><span class="line">        res_l.append(res)</span><br><span class="line"></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print([res.get() <span class="keyword">for</span> res <span class="keyword">in</span> res_l]) <span class="comment">#拿到的是get_page的结果,其实完全没必要拿该结果,该结果已经传给回调函数处理了</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">打印结果:</span></span><br><span class="line"><span class="string">&lt;进程3388&gt; get https://www.baidu.com</span></span><br><span class="line"><span class="string">&lt;进程3389&gt; get https://www.python.org</span></span><br><span class="line"><span class="string">&lt;进程3390&gt; get https://www.openstack.org</span></span><br><span class="line"><span class="string">&lt;进程3388&gt; get https://help.github.com/</span></span><br><span class="line"><span class="string">&lt;进程3387&gt; parse https://www.baidu.com</span></span><br><span class="line"><span class="string">&lt;进程3389&gt; get http://www.sina.com.cn/</span></span><br><span class="line"><span class="string">&lt;进程3387&gt; parse https://www.python.org</span></span><br><span class="line"><span class="string">&lt;进程3387&gt; parse https://help.github.com/</span></span><br><span class="line"><span class="string">&lt;进程3387&gt; parse http://www.sina.com.cn/</span></span><br><span class="line"><span class="string">&lt;进程3387&gt; parse https://www.openstack.org</span></span><br><span class="line"><span class="string">[&#123;'url': 'https://www.baidu.com', 'text': '&lt;!DOCTYPE html&gt;\r\n...',...&#125;]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>爬虫实例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url,pattern)</span>:</span></span><br><span class="line">    <span class="comment"># response=urlopen(url).read().decode('utf-8')</span></span><br><span class="line">    response = requests.get(url).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> pattern,response   <span class="comment"># 正则表达式编译结果 网页内容</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(info)</span>:</span></span><br><span class="line">    pattern,page_content=info</span><br><span class="line">    res=re.findall(pattern,page_content)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">        dic=&#123;</span><br><span class="line">            <span class="string">'index'</span>:item[<span class="number">0</span>].strip(),</span><br><span class="line">            <span class="string">'title'</span>:item[<span class="number">1</span>].strip(),</span><br><span class="line">            <span class="string">'actor'</span>:item[<span class="number">2</span>].strip(),</span><br><span class="line">            <span class="string">'time'</span>:item[<span class="number">3</span>].strip(),</span><br><span class="line">        &#125;</span><br><span class="line">        print(dic)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    regex = <span class="string">r'&lt;dd&gt;.*?&lt;.*?class="board-index.*?&gt;(\d+)&lt;/i&gt;.*?title="(.*?)".*?class="movie-item-info".*?&lt;p class="star"&gt;(.*?)&lt;/p&gt;.*?&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;'</span></span><br><span class="line">    pattern1=re.compile(regex,re.S)</span><br><span class="line">    url_dic=&#123;<span class="string">'http://maoyan.com/board/7'</span>:pattern1&#125;</span><br><span class="line">    p=Pool()</span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> url,pattern <span class="keyword">in</span> url_dic.items():</span><br><span class="line">        res=p.apply_async(get_page,args=(url,pattern),callback=parse_page)</span><br><span class="line">        res_l.append(res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res_l:</span><br><span class="line">        i.get()</span><br></pre></td></tr></table></figure>

<p><strong>如果在主进程中等待进程池中所有任务都执行完毕后，再统一处理结果，则无需回调函数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无需回调函数</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p=Pool()</span><br><span class="line"></span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res=p.apply_async(work,args=(i,))</span><br><span class="line">        res_l.append(res)</span><br><span class="line"></span><br><span class="line">    p.close()</span><br><span class="line">    p.join() <span class="comment">#等待进程池中所有进程执行完毕</span></span><br><span class="line"></span><br><span class="line">    nums=[]</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> res_l:</span><br><span class="line">        nums.append(res.get()) <span class="comment">#拿到所有结果</span></span><br><span class="line">    print(nums) <span class="comment">#主进程拿到所有的处理结果,可以在主进程中进行统一进行处理</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/dev/library/concurrent.futures.html" target="_blank" rel="noopener"><strong>进程池的其他实现方式：https://docs.python.org/dev/library/concurrent.futures.html</strong></a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/03/python全栈/第02部分：并发编程+数据库+前端/并发编程/进程（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/03/python全栈/第02部分：并发编程+数据库+前端/并发编程/进程（一）/" itemprop="url">进程（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-03T01:27:51+08:00">
                2019-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-02部分-并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -02部分 -并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="（一）理论知识"><a href="#（一）理论知识" class="headerlink" title="（一）理论知识"></a>（一）理论知识</h2><h3 id="一、操作系统背景知识"><a href="#一、操作系统背景知识" class="headerlink" title="一、操作系统背景知识"></a>一、操作系统背景知识</h3><p>​        <strong>顾名思义，进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。</strong></p>
<p>​        <strong>进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统提供的最古老也是最重要的抽象概念之一。操作系统的其他所有内容都是围绕进程的概念展开的。</strong></p>
<p>​        <strong>所以想要真正了解进程，必须事先了解操作系统，点击进入</strong>    </p>
<p>PS：即使可以利用的cpu只有一个（早期的计算机确实如此），也能保证支持（伪）并发的能力。将一个单独的cpu变成多个虚拟的cpu（多道技术：时间多路复用和空间多路复用+硬件上支持隔离），没有进程的抽象，现代计算机将不复存在。</p>
<p><strong>必备的理论基础：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#一 操作系统的作用：</span><br><span class="line">    1：隐藏丑陋复杂的硬件接口，提供良好的抽象接口</span><br><span class="line">    2：管理、调度进程，并且将多个进程对硬件的竞争变得有序</span><br><span class="line"></span><br><span class="line">#二 多道技术：</span><br><span class="line">    1.产生背景：针对单核，实现并发</span><br><span class="line">    ps：</span><br><span class="line">    现在的主机一般是多核，那么每个核都会利用多道技术</span><br><span class="line">    有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个</span><br><span class="line">    cpu中的任意一个，具体由操作系统调度算法决定。</span><br><span class="line">    </span><br><span class="line">    2.空间上的复用：如内存中同时有多道程序</span><br><span class="line">    3.时间上的复用：复用一个cpu的时间片</span><br><span class="line">       强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样</span><br><span class="line">            才能保证下次切换回来时，能基于上次切走的位置继续运行</span><br></pre></td></tr></table></figure>

<h3 id="二、什么是进程"><a href="#二、什么是进程" class="headerlink" title="二、什么是进程"></a>二、什么是进程</h3><p>​        <strong>进程（Process）</strong>是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是<a href="https://baike.baidu.com/item/操作系统" target="_blank" rel="noopener">操作系统</a>结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
<p>​        <strong>狭义定义：</strong>进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</p>
<p>​        <strong>广义定义：</strong>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是<a href="https://baike.baidu.com/item/操作系统/192" target="_blank" rel="noopener">操作系统</a>动态执行的<a href="https://baike.baidu.com/item/基本单元" target="_blank" rel="noopener">基本单元</a>，在传统的<a href="https://baike.baidu.com/item/操作系统" target="_blank" rel="noopener">操作系统</a>中，进程既是基本的<a href="https://baike.baidu.com/item/分配单元" target="_blank" rel="noopener">分配单元</a>，也是基本的执行单元。</p>
<h4 id="1、进程的概念"><a href="#1、进程的概念" class="headerlink" title="1、进程的概念"></a>1、进程的概念</h4><p>​        第一，进程是一个实体。每一个进程都有它自己的地址空间（每个进程的地址空间是相互独立的），一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。</p>
<p>​        第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。</p>
<p>​        进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。</p>
<h4 id="2、操作系统引入进程的概念的原因"><a href="#2、操作系统引入进程的概念的原因" class="headerlink" title="2、操作系统引入进程的概念的原因"></a>2、操作系统引入进程的概念的原因</h4><p>从理论角度看，是对正在运行的程序过程的抽象；<br>        从实现角度看，是一种数据结构，目的在于清晰地刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序。</p>
<h4 id="3、进程的特征"><a href="#3、进程的特征" class="headerlink" title="3、进程的特征"></a>3、进程的特征</h4><ul>
<li><strong>动态性：</strong>进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。</li>
<li><strong>并发性：</strong>任何进程都可以同其他进程一起并发执行</li>
<li><strong>独立性：</strong>进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；</li>
<li><strong>异步性：</strong>由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进<br>结构特征：进程由程序、数据和进程控制块三部分组成</li>
</ul>
<p>​        多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</p>
<h4 id="4、进程与程序中的区别"><a href="#4、进程与程序中的区别" class="headerlink" title="4、进程与程序中的区别"></a>4、进程与程序中的区别</h4><p>​        程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。<br>​        而进程是程序在处理机上的一次执行过程，它是一个动态的概念。<br>​        程序可以作为一种软件资料长期存在，而进程是有一定生命期的。<br>​        程序是永久的，进程是暂时的。</p>
<p><strong>注意：</strong></p>
<p>​        <strong>同一个程序执行两次，就会在操作系统中出现两个进程，所以我们可以同时运行一个软件，分别做不同的事情也不会混乱。</strong></p>
<h3 id="三、进程调度"><a href="#三、进程调度" class="headerlink" title="三、进程调度"></a>三、进程调度</h3><p>​        要想多个进程交替运行，操作系统必须对这些进程进行调度，这个调度也不是随即进行的，而是需要遵循一定的法则，由此就有了进程的调度算法。</p>
<h4 id="1、先来先服务的调度算法"><a href="#1、先来先服务的调度算法" class="headerlink" title="1、先来先服务的调度算法"></a>1、先来先服务的调度算法</h4><p>​        先来先服务（FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。由此可知，本算法适合于CPU繁忙型作业，而不利于I/O繁忙型的作业（进程）。</p>
<h4 id="2、短作业优先调度算法"><a href="#2、短作业优先调度算法" class="headerlink" title="2、短作业优先调度算法"></a>2、短作业优先调度算法</h4><p>​        短作业（进程）优先调度算法（SJ/PF）是指对短作业或短进程优先调度的算法，该算法既可用于作业调度，也可用于进程调度。但其对长作业不利；不能保证紧迫性作业（进程）被及时处理；作业的长短只是被估算出来的。</p>
<h4 id="3、时间片轮转法"><a href="#3、时间片轮转法" class="headerlink" title="3、时间片轮转法"></a>3、时间片轮转法</h4><p>​        时间片轮转(Round Robin，RR)法的基本思路是让每个进程在就绪队列中的等待时间与享受服务的时间成比例。在时间片轮转法中，需要将CPU的处理时间分成固定大小的时间片，例如，几十毫秒至几百毫秒。如果一个进程在被调度选中之后用完了系统规定的时间片，但又未完成要求的任务，则它自行释放自己所占有的CPU而排到就绪队列的末尾，等待下一次调度。同时，进程调度程序又去调度当前就绪队列中的第一个进程。<br>​      显然，轮转法只能用来调度分配一些可以抢占的资源。这些可以抢占的资源可以随时被剥夺，而且可以将它们再分配给别的进程。CPU是可抢占资源的一种。但打印机等资源是不可抢占的。由于作业调度是对除了CPU之外的所有系统硬件资源的分配，其中包含有不可抢占资源，所以作业调度不使用轮转法。<br>​        在轮转法中，时间片长度的选取非常重要。首先，时间片长度的选择会直接影响到系统的开销和响应时间。如果时间片长度过短，则调度程序抢占处理机的次数增多。这将使进程上下文切换次数也大大增加，从而加重系统开销。反过来，如果时间片长度选择过长，例如，一个时间片能保证就绪队列中所需执行时间最长的进程能执行完毕，则轮转法变成了先来先服务法。时间片长度的选择是根据系统对响应时间的要求和就绪队列中所允许最大的进程数来确定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在轮转法中，加入到就绪队列的进程有3种情况：</span><br><span class="line">      一种是分给它的时间片用完，但进程还未完成，回到就绪队列的末尾等待下次调度去继续执行。</span><br><span class="line">      另一种情况是分给该进程的时间片并未用完，只是因为请求I/O或由于进程的互斥与同步关系而被阻塞。当阻塞解除之后再回到就绪队列。</span><br><span class="line">      第三种情况就是新创建进程进入就绪队列。</span><br><span class="line">      如果对这些进程区别对待，给予不同的优先级和时间片从直观上看，可以进一步改善系统服务质量和效率。例如，我们可把就绪队列按照进程到达就绪队列的类型和进程被阻塞时的阻塞原因分成不同的就绪队列，每个队列按FCFS原则排列，各队列之间的进程享有不同的优先级，但同一队列内优先级相同。这样，当一个进程在执行完它的时间片之后，或从睡眠中被唤醒以及被创建之后，将进入不同的就绪队列。</span><br></pre></td></tr></table></figure>

<h4 id="4、多级反馈队列"><a href="#4、多级反馈队列" class="headerlink" title="4、多级反馈队列"></a>4、多级反馈队列</h4><p>​        前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。<br>​        而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。</span><br><span class="line">(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</span><br><span class="line">(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</span><br><span class="line"></span><br><span class="line">(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</span><br></pre></td></tr></table></figure>

<h3 id="四、进程的并行与并发"><a href="#四、进程的并行与并发" class="headerlink" title="四、进程的并行与并发"></a>四、进程的并行与并发</h3><p><strong>并行</strong> : 并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ）</p>
<p><strong>并发</strong> : 并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。</p>
<p><strong>区别</strong>:</p>
<p><strong>并行</strong>是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。<br><strong>并发</strong>是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。</p>
<h3 id="五、同步异步阻塞非阻塞"><a href="#五、同步异步阻塞非阻塞" class="headerlink" title="五、同步异步阻塞非阻塞"></a>五、同步异步阻塞非阻塞</h3><h4 id="1、状态介绍"><a href="#1、状态介绍" class="headerlink" title="1、状态介绍"></a>1、状态介绍</h4><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/10.png" alt></p>
<p>​        在了解其他概念之前，我们首先要了解进程的几个状态。在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行和阻塞。</p>
<p>　　<strong>（1）就绪(Ready)状态</strong></p>
<p>　　当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。</p>
<p>　　<strong>（2）执行/运行（Running）状态</strong></p>
<p>​        当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。</p>
<p>　　<strong>（3）阻塞(Blocked)状态</strong></p>
<p>​        正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/11.png" alt></p>
<h4 id="2、同步和异步"><a href="#2、同步和异步" class="headerlink" title="2、同步和异步"></a>2、同步和异步</h4><p>​        所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</p>
<p>　    所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">比如我去银行办理业务，可能会有两种方式：</span><br><span class="line">第一种 ：选择排队等候；</span><br><span class="line">第二种 ：选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了；</span><br><span class="line"></span><br><span class="line">第一种：前者(排队等候)就是同步等待消息通知，也就是我要一直在等待银行办理业务情况；</span><br><span class="line"></span><br><span class="line">第二种：后者(等待别人通知)就是异步等待消息通知。在异步消息处理中，等待消息通知者(在这个例子中就是等待办理业务的人)往往注册一个回调机制，在所等待的事件被触发时由触发机制(在这里是柜台的人)通过某种机制(在这里是写在小纸条上的号码，喊号)找到等待该事件的人。</span><br></pre></td></tr></table></figure>

<h4 id="3、阻塞与非阻塞"><a href="#3、阻塞与非阻塞" class="headerlink" title="3、阻塞与非阻塞"></a>3、阻塞与非阻塞</h4><p>​        阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">		继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。</span><br><span class="line">		相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。</span><br><span class="line"></span><br><span class="line">		注意：同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。</span><br></pre></td></tr></table></figure>

<h4 id="4、同步-异步-与-阻塞-非阻塞"><a href="#4、同步-异步-与-阻塞-非阻塞" class="headerlink" title="4、同步/异步 与 阻塞/非阻塞"></a>4、同步/异步 与 阻塞/非阻塞</h4><ol>
<li><p><strong>同步阻塞形式</strong></p>
<p>​        效率最低。拿上面的例子来说，就是你专心排队，什么别的事都不做。</p>
</li>
<li><p><strong>异步阻塞形式</strong></p>
<p>​        如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发（通知），也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面；</p>
<p>​        <strong>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</strong></p>
</li>
<li><p><strong>同步非阻塞形式</strong></p>
<p>​        实际上是效率低下的。</p>
<p>　　想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。</p>
</li>
<li><p><strong>异步非阻塞形式</strong></p>
<p>​        效率更高，</p>
<p>　　因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。</p>
<p>　　比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p>
</li>
</ol>
<p>​        很多人会把同步和阻塞混淆，是因为很多时候同步操作会以阻塞的形式表现出来，同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞。</p>
<h3 id="六、进程的创建与结束"><a href="#六、进程的创建与结束" class="headerlink" title="六、进程的创建与结束"></a>六、进程的创建与结束</h3><h4 id="1、进程的创建"><a href="#1、进程的创建" class="headerlink" title="1、进程的创建"></a>1、进程的创建</h4><p>​        但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。</p>
<p>　　而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程：</p>
<p>　　1. 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）</p>
<p>　　2. 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等）</p>
<p>　　3. 用户的交互式请求，而创建一个新进程（如用户双击暴风影音）</p>
<p>　　4. 一个批处理作业的初始化（只在大型机的批处理系统中应用）</p>
<p>　　无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建进程：</span><br><span class="line">1. 在UNIX中该系统调用是：fork，fork会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件（在shell解释器进程中，执行一个命令就会创建一个子进程）</span><br><span class="line"></span><br><span class="line">　　2. 在windows中该系统调用是：CreateProcess，CreateProcess既处理进程的创建，也负责把正确的程序装入新进程。</span><br><span class="line"></span><br><span class="line">　　关于创建子进程，UNIX和windows</span><br><span class="line"></span><br><span class="line">　　1.相同的是：进程创建后，父进程和子进程有各自不同的地址空间（多道技术要求物理层面实现进程之间内存的隔离），任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。</span><br><span class="line"></span><br><span class="line">　　2.不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，从一开始父进程与子进程的地址空间就是不同的。</span><br></pre></td></tr></table></figure>

<h4 id="2、进程的结束"><a href="#2、进程的结束" class="headerlink" title="2、进程的结束"></a>2、进程的结束</h4><ol>
<li><p>正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）</p>
</li>
<li><p>出错退出（自愿，python a.py中a.py不存在）</p>
</li>
<li><p>严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try…except…）</p>
</li>
<li><p>被其他进程杀死（非自愿，如kill -9）</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/02/python全栈/第02部分：并发编程+数据库+前端/并发编程/操作系统的发展史/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/02/python全栈/第02部分：并发编程+数据库+前端/并发编程/操作系统的发展史/" itemprop="url">操作系统的发展史</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-02T22:21:10+08:00">
                2019-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-02部分-并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -02部分 -并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="一、手工操作——穿孔卡片"><a href="#一、手工操作——穿孔卡片" class="headerlink" title="一、手工操作——穿孔卡片"></a>一、手工操作——穿孔卡片</h2><p>1946年第一台计算机诞生–20世纪50年代中期，计算机工作还在采用手工操作方式。此时还没有操作系统的概念。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01.png" alt> <img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02.png" alt></p>
<p>​        程序员将对应于程序和数据的已穿孔的纸带（或卡片）装入输入机，然后启动输入机把程序和数据输入计算机内存，接着通过控制台开关启动程序针对数据运行；计算完毕，打印机输出计算结果；用户取走结果并卸下纸带（或卡片）后，才让下一个用户上机。</p>
<p>手工操作方式两个特点：</p>
<p>　　（1）用户独占全机。不会出现因资源已被其他用户占用而等待的现象，但资源的利用率低。</p>
<p>　　（2）CPU 等待手工操作。CPU的利用不充分。</p>
<p>​      20世纪50年代后期，出现<a href="https://baike.baidu.com/item/人机矛盾" target="_blank" rel="noopener">人机矛盾</a>：手工操作的慢速度和计算机的高速度之间形成了尖锐矛盾，手工操作方式已严重损害了系统资源的利用率（使资源利用率降为百分之几，甚至更低），不能容忍。唯一的解决办法：只有摆脱人的手工操作，实现作业的自动过渡。这样就出现了成<a href="https://baike.baidu.com/item/批处理" target="_blank" rel="noopener">批处理</a>。</p>
<h2 id="二、批处理——磁带存储"><a href="#二、批处理——磁带存储" class="headerlink" title="二、批处理——磁带存储"></a>二、批处理——磁带存储</h2><p>​        批处理系统：加载在计算机上的一个<a href="https://baike.baidu.com/item/系统软件" target="_blank" rel="noopener">系统软件</a>，在它的控制下，计算机能够自动地、成批地处理一个或多个用户的作业（这作业包括程序、数据和命令）。</p>
<h3 id="1、联机批处理系统"><a href="#1、联机批处理系统" class="headerlink" title="1、联机批处理系统"></a>1、联机批处理系统</h3><p>首先出现的是联机批处理系统，即作业的输入/输出由CPU来处理。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/03.png" alt></p>
<p>​        主机与输入机之间增加一个存储设备——<strong>磁带</strong>，在运行于主机上的监督程序的自动控制下，计算机可自动完成：成批地把输入机上的用户作业读入磁带，依次把磁带上的用户作业读入主机内存并执行并把计算结果向输出机输出。完成了上一批作业后，监督程序又从输入机上输入另一批作业，保存在磁带上，并按上述步骤重复处理。</p>
<p>​        监督程序不停地处理各个作业，从而实现了作业到作业的自动转接，减少了作业建立时间和手工操作时间，有效克服了人机矛盾，提高了计算机的利用率。</p>
<p>​        但是，在作业输入和结果输出时，主机的高速CPU仍处于空闲状态，等待慢速的输入/输出设备完成工作： 主机处于“忙等”状态。</p>
<h3 id="2、脱机批处理系统"><a href="#2、脱机批处理系统" class="headerlink" title="2、脱机批处理系统"></a>2、脱机批处理系统</h3><p>​        为克服与缓解：高速主机与慢速外设的矛盾，提高CPU的利用率，又引入了<a href="https://baike.baidu.com/item/脱机批处理系统" target="_blank" rel="noopener">脱机批处理系统</a>，即输入/输出脱离主机控制。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/04.png" alt></p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/05.png" alt></p>
<p>​        卫星机：一台不与主机直接相连而专门用于与输入/输出设备打交道的。</p>
<p>　　其功能是：</p>
<p>　　（1）从输入机上读取用户作业并放到输入磁带上。</p>
<p>　　（2）从输出磁带上读取执行结果并传给输出机。</p>
<p>​        这样，主机不是直接与慢速的输入/输出设备打交道，而是与速度相对较快的磁带机发生关系，有效缓解了主机与设备的矛盾。主机与卫星机可并行工作，二者分工明确，可以充分发挥主机的高速计算能力。</p>
<p>​        脱机批处理系统:20世纪60年代应用十分广泛，它极大缓解了人机矛盾及主机与外设的矛盾。</p>
<p>　　不足：每次主机内存中仅存放一道作业，每当它运行期间发出输入/输出（I/O）请求后，高速的CPU便处于等待低速的I/O完成状态，致使CPU空闲。</p>
<p>​        为改善CPU的利用率，又引入了多道程序系统。</p>
<h2 id="三、多道程序系统"><a href="#三、多道程序系统" class="headerlink" title="三、多道程序系统"></a>三、多道程序系统</h2><h3 id="1、多道程序设计技术"><a href="#1、多道程序设计技术" class="headerlink" title="1、多道程序设计技术"></a>1、多道程序设计技术</h3><p>​        所谓多道程序设计技术，就是指允许多个程序同时进入内存并运行。即同时把多个程序放入内存，并允许它们交替在CPU中运行，它们共享系统中的各种硬、软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/06.png" alt></p>
<p>​        在A程序计算时，I/O空闲， A程序I/O操作时，CPU空闲（B程序也是同样）；必须A工作完成后，B才能进入内存中开始工作，两者是串行的，全部完成共需时间=T1+T2。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/07.png" alt></p>
<p>​        将A、B两道程序同时存放在内存中，它们在系统的控制下，可相互穿插、交替地在CPU上运行：当A程序因请求I/O操作而放弃CPU时，B程序就可占用CPU运行，这样 CPU不再空闲，而正进行A I/O操作的I/O设备也不空闲，显然，CPU和I/O设备都处于“忙”状态，大大提高了资源的利用率，从而也提高了系统的效率，A、B全部完成所需时间&lt;&lt;T1+T2。</p>
<p>​      多道程序设计技术不仅使CPU得到充分利用，同时改善I/O设备和内存的利用率，从而提高了整个系统的资源利用率和系统吞吐量（单位时间内处理作业（程序）的个数），最终提高了整个系统的效率。</p>
<p>​        单处理机系统中多道程序运行时的特点：</p>
<p>　　（1）多道：计算机内存中同时存放几道相互独立的程序；</p>
<p>　　（2）宏观上并行：同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕；</p>
<p>　　（3）微观上串行：实际上，各道程序轮流地用CPU，并交替运行。</p>
<p>​        <strong>多道程序系统的出现，标志着操作系统渐趋成熟的阶段，先后出现了作业调度管理、处理机管理、存储器管理、外部设备管理、文件系统管理等功能。</strong></p>
<p>​        <strong>由于多个程序同时在计算机中运行，开始有了空间隔离的概念，只有内存空间的隔离，才能让数据更加安全、稳定。</strong></p>
<p>​        <strong>出了空间隔离之外，多道技术还第一次体现了时空复用的特点，遇到IO操作就切换程序，使得cpu的利用率提高了，计算机的工作效率也随之提高。</strong></p>
<h3 id="2、多道批处理系统"><a href="#2、多道批处理系统" class="headerlink" title="2、多道批处理系统"></a>2、多道批处理系统</h3><p>​        20世纪60年代中期，在前述的批处理系统中，引入多道程序设计技术后形成多道批处理系统（简称：批处理系统）。</p>
<p>　　它有两个特点：</p>
<p>　　（1）多道：系统内可同时容纳多个作业。这些作业放在外存中，组成一个后备队列，系统按一定的调度原则每次从后备作业队列中选取一个或多个作业进入内存运行，运行作业结束、退出运行和后备作业进入运行均由系统自动实现，从而在系统中形成一个自动转接的、连续的作业流。</p>
<p>　　（2）成批：在系统运行过程中，不允许用户与其作业发生交互作用，即：作业一旦进入系统，用户就不能直接干预其作业的运行。</p>
<p>　　批处理系统的追求目标：提高系统资源利用率和系统吞吐量，以及作业流程的自动化。</p>
<p>　　批处理系统的一个重要缺点：不提供人机交互能力，给用户使用计算机带来不便。</p>
<p>　　虽然用户独占全机资源，并且直接控制程序的运行，可以随时了解程序运行情况。但这种工作方式因独占全机造成资源效率极低。</p>
<p>　　一种新的追求目标：既能保证计算机效率，又能方便用户使用计算机。 20世纪60年代中期，计算机技术和软件技术的发展使这种追求成为可能。</p>
<h2 id="四、分时系统"><a href="#四、分时系统" class="headerlink" title="四、分时系统"></a>四、分时系统</h2><p>​        由于CPU速度不断提高和采用分时技术，一台计算机可同时连接多个用户终端，而每个用户可在自己的终端上联机使用计算机，好像自己独占机器一样。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/08.png" alt></p>
<p>​        分时技术：把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。</p>
<p>　　若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮时再继续其运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的印象是，好象他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。</p>
<p>​        具有上述特征的计算机系统称为分时系统，它允许多个用户同时联机使用计算机。</p>
<p>　　特点：</p>
<p>　　（1）多路性。若干个用户同时使用一台计算机。微观上看是各用户轮流使用计算机；宏观上看是各用户并行工作。</p>
<p>　　（2）交互性。用户可根据系统对请求的响应结果，进一步向系统提出新的请求。这种能使用户与系统进行人机对话的工作方式，明显地有别于批处理系统，因而，分时系统又被称为交互式系统。</p>
<p>　　（3）独立性。用户之间可以相互独立操作，互不干扰。系统保证各用户程序运行的完整性，不会发生相互混淆或破坏现象。</p>
<p>　　（4）及时性。系统可对用户的输入及时作出响应。分时系统性能的主要指标之一是响应时间，它是指：从终端发出命令到系统予以应答所需的时间。</p>
<p>　　<strong>分时系统的主要目标</strong>：对用户响应的及时性，即不至于用户等待每一个命令的处理时间过长。</p>
<p>​        分时系统可以同时接纳数十个甚至上百个用户，由于内存空间有限，往往采用对换（又称交换）方式的存储方法。即将未“轮到”的作业放入磁盘，一旦“轮到”，再将其调入内存；而时间片用完后，又将作业存回磁盘（俗称“滚进”、“滚出“法），使同一存储区域轮流为多个用户服务。</p>
<p>​        多用户分时系统是当今计算机操作系统中最普遍使用的一类操作系统。</p>
<p>​      <strong>注意：分时系统的分时间片工作，在没有遇到IO操作的时候就用完了自己的时间片被切走了，这样的切换工作其实并没有提高cpu的效率，反而使得计算机的效率降低了。但是我们牺牲了一点效率，却实现了多个程序共同执行的效果，这样你就可以在计算机上一边听音乐一边聊qq了。</strong></p>
<h2 id="五、实时系统"><a href="#五、实时系统" class="headerlink" title="五、实时系统"></a>五、实时系统</h2><p>​        虽然多道批处理系统和分时系统能获得较令人满意的资源利用率和系统响应时间，但却不能满足实时控制与实时信息处理两个应用领域的需求。于是就产生了实时系统，即系统能够及时响应随机发生的外部事件，并在严格的时间范围内完成对该事件的处理。</p>
<p>​        实时系统在一个特定的应用中常作为一种控制设备来使用。</p>
<p>　　  实时系统可分成两类：</p>
<p>　　  （1）实时控制系统。当用于飞机飞行、导弹发射等的自动控制时，要求计算机能尽快处理测量系统测得的数据，及时地对飞机或导弹进行控制，或将有关信息通过显示终端提供给决策人员。当用于轧钢、石化等工业生产过程控制时，也要求计算机能及时处理由各类传感器送来的数据，然后控制相应的执行机构。</p>
<p>　　  （2）实时信息处理系统。当用于预定飞机票、查询有关航班、航线、票价等事宜时，或当用于银行系统、情报检索系统时，都要求计算机能对终端设备发来的服务请求及时予以正确的回答。此类对响应及时性的要求稍弱于第一类。</p>
<p>　　<strong>实时操作系统的主要特点</strong>：</p>
<p>　　（1）及时响应。每一个信息接收、分析处理和发送的过程必须在严格的时间限制内完成。</p>
<p>　　（2）高可靠性。需采取冗余措施，双机系统前后台工作，也包括必要的保密措施等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分时系统和实时系统的比较：</span><br><span class="line">分时——现在流行的PC，服务器都是采用这种运行模式，即把CPU的运行分成若干时间片分别处理不同的运算请求 linux系统</span><br><span class="line">实时——一般用于单片机上、PLC等，比如电梯的上下控制中，对于按键等动作要求进行实时处理</span><br></pre></td></tr></table></figure>

<h2 id="六、通用操作系统"><a href="#六、通用操作系统" class="headerlink" title="六、通用操作系统"></a>六、通用操作系统</h2><p>​        操作系统的三种基本类型：多道批处理系统、分时系统、实时系统。</p>
<p>　　<strong>通用操作系统：具有多种类型操作特征的操作系统。可以同时兼有多道批处理、分时、实时处理的功能，或其中两种以上的功能。</strong></p>
<p>　　例如：实时处理+批处理=实时批处理系统。首先保证优先处理实时任务，插空进行批处理作业。常把实时任务称为前台作业，批作业称为后台作业。</p>
<p>　　再如：分时处理+批处理=分时批处理系统。即：时间要求不强的作业放入“后台”（批处理）处理，需频繁交互的作业在“前台”（分时）处理，处理机优先运行“前台”作业。</p>
<p>　　从上世纪60年代中期，国际上开始研制一些大型的通用操作系统。这些系统试图达到功能齐全、可适应各种应用范围和操作方式变化多端的环境的目标。但是，这些系统过于复杂和庞大，不仅付出了巨大的代价，且在解决其可靠性、可维护性和可理解性方面都遇到很大的困难。</p>
<p>　　相比之下，UNIX操作系统却是一个例外。这是一个通用的多用户分时交互型的操作系统。它首先建立的是一个精干的核心，而其功能却足以与许多大型的操作系统相媲美，在核心层以外，可以支持庞大的软件系统。它很快得到应用和推广，并不断完善，对现代操作系统有着重大的影响。</p>
<p>　　至此，操作系统的基本概念、功能、基本结构和组成都已形成并渐趋完善。</p>
<h2 id="七、操作系统的进一步发展"><a href="#七、操作系统的进一步发展" class="headerlink" title="七、操作系统的进一步发展"></a>七、操作系统的进一步发展</h2><p>​        进入20世纪80年代，大规模集成电路工艺技术的飞跃发展，微处理机的出现和发展，掀起了计算机大发展大普及的浪潮。一方面迎来了个人计算机的时代，同时又向计算机网络、分布式处理、巨型计算机和智能化方向发展。于是，操作系统有了进一步的发展，如：个人计算机操作系统、网络操作系统、分布式操作系统等。</p>
<h3 id="1、个人计算机操作系统"><a href="#1、个人计算机操作系统" class="headerlink" title="1、个人计算机操作系统"></a>1、个人计算机操作系统</h3><p>​        个人计算机上的操作系统是联机交互的单用户操作系统，它提供的联机交互功能与通用分时系统提供的功能很相似。</p>
<p>　　由于是个人专用，因此一些功能会简单得多。然而，由于个人计算机的应用普及，对于提供更方便友好的用户接口和丰富功能的文件系统的要求会愈来愈迫切。</p>
<h3 id="2、网络操作系统"><a href="#2、网络操作系统" class="headerlink" title="2、网络操作系统"></a>2、网络操作系统</h3><p>​        计算机网络：通过通信设施，将地理上分散的、具有自治功能的多个计算机系统互连起来，实现信息交换、资源共享、互操作和协作处理的系统。</p>
<p>　　网络操作系统：在原来各自计算机操作系统上，按照网络体系结构的各个协议标准增加网络管理模块，其中包括：通信、资源共享、系统安全和各种网络应用服务。</p>
<h3 id="3、分布式操作系统"><a href="#3、分布式操作系统" class="headerlink" title="3、分布式操作系统"></a>3、分布式操作系统</h3><p>​        表面上看，分布式系统与计算机网络系统没有多大区别。分布式操作系统也是通过通信网络，将地理上分散的具有自治功能的数据处理系统或计算机系统互连起来，实现信息交换和资源共享，协作完成任务。——硬件连接相同。</p>
<p>　　但有如下一些明显的区别：</p>
<p>　　（1）分布式系统要求一个统一的操作系统，实现系统操作的统一性。</p>
<p>　　（2）分布式操作系统管理分布式系统中的所有资源，它负责全系统的资源分配和调度、任务划分、信息传输和控制协调工作，并为用户提供一个统一的界面。</p>
<p>　　（3）用户通过这一界面，实现所需要的操作和使用系统资源，至于操作定在哪一台计算机上执行，或使用哪台计算机的资源，则是操作系统完成的，用户不必知道，此谓：系统的透明性。</p>
<p>　　（4）分布式系统更强调分布式计算和处理，因此对于多机合作和系统重构、坚强性和容错能力有更高的要求，希望系统有：更短的响应时间、高吞吐量和高可靠性。</p>
<h2 id="八、操作系统的作用"><a href="#八、操作系统的作用" class="headerlink" title="八、操作系统的作用"></a>八、操作系统的作用</h2><p>​        现代的计算机系统主要是由一个或者多个处理器，主存，硬盘，键盘，鼠标，显示器，打印机，网络接口及其他输入输出设备组成。</p>
<p>　　一般而言，现代计算机系统是一个复杂的系统。</p>
<p>　　其一：如果每位应用程序员都必须掌握该系统所有的细节，那就不可能再编写代码了（严重影响了程序员的开发效率：全部掌握这些细节可能需要一万年….）</p>
<p>　　其二：并且管理这些部件并加以优化使用，是一件极富挑战性的工作，于是，计算安装了一层软件（系统软件），称为操作系统。它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型，并管理刚才提到的所有设备。</p>
<p>　　<strong>总结：</strong></p>
<p>　　<strong>程序员无法把所有的硬件操作细节都了解到，管理这些硬件并且加以优化使用是非常繁琐的工作，这个繁琐的工作就是操作系统来干的，有了他，程序员就从这些繁琐的工作中解脱了出来，只需要考虑自己的应用软件的编写就可以了，应用软件直接使用操作系统提供的功能来间接使用硬件。</strong></p>
<p>　　<strong>精简的说的话，操作系统就是一个协调、管理和控制计算机硬件资源和软件资源的控制程序。操作系统所处的位置如图</strong></p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/09.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">细说的话，操作系统应该分成两部分功能：</span><br><span class="line">#一：隐藏了丑陋的硬件调用接口，为应用程序员提供调用硬件资源的更好，更简单，更清晰的模型（系统调用接口）。应用程序员有了这些接口后，就不用再考虑操作硬件的细节，专心开发自己的应用程序即可。</span><br><span class="line">例如：操作系统提供了文件这个抽象概念，对文件的操作就是对磁盘的操作，有了文件我们无需再去考虑关于磁盘的读写控制（比如控制磁盘转动，移动磁头读写数据等细节），</span><br><span class="line"></span><br><span class="line">#二：将应用程序对硬件资源的竞态请求变得有序化</span><br><span class="line">例如：很多应用软件其实是共享一套计算机硬件，比方说有可能有三个应用程序同时需要申请打印机来输出内容，那么a程序竞争到了打印机资源就打印，然后可能是b竞争到打印机资源，也可能是c，这就导致了无序，打印机可能打印一段a的内容然后又去打印c...,操作系统的一个功能就是将这种无序变得有序。</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/29/python全栈/第01部分：基础+模块+面向对象+网络编程/网络编程/计算机网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/29/python全栈/第01部分：基础+模块+面向对象+网络编程/网络编程/计算机网络/" itemprop="url">计算机网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-29T22:57:50+08:00">
                2019-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-01部分-网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -01部分 -网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="（一）计算机网络的发展及基础网络概念"><a href="#（一）计算机网络的发展及基础网络概念" class="headerlink" title="（一）计算机网络的发展及基础网络概念"></a>（一）计算机网络的发展及基础网络概念</h2><h3 id="一、早期：联机"><a href="#一、早期：联机" class="headerlink" title="一、早期：联机"></a>一、早期：联机</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11.png" alt></p>
<h3 id="二、以太网：局域网与交换机"><a href="#二、以太网：局域网与交换机" class="headerlink" title="二、以太网：局域网与交换机"></a>二、以太网：局域网与交换机</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/12.png" alt></p>
<p>交换机——解决多台电脑的通信问题(广播、单播、组播)</p>
<h4 id="1、广播"><a href="#1、广播" class="headerlink" title="1、广播"></a>1、广播</h4><p>​        主机之间“一对所有”的通讯模式，网络对其中每一台主机发出的信号都进行无条件复制并转发，<strong>所有主机都可以接收到所有信息（不管你是否需要）</strong>，由于其不用路径选择，所以其网络成本可以很低廉。有线电视网就是典型的广播型网络，我们的电视机实际上是接受到所有频道的信号，但只将一个频道的信号还原成画面。在数据网络中也允许广播的存在，但其被限制在二层交换机的局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机。</p>
<p>​        <a href="https://baike.baidu.com/item/广播风暴/3574878?fr=aladdin" target="_blank" rel="noopener">广播风暴</a>：简单的讲是指当广播数据充斥网络无法处理，并占用大量<a href="https://baike.baidu.com/item/网络带宽/6120475" target="_blank" rel="noopener">网络带宽</a>，导致正常业务不能运行，甚至彻底瘫痪，这就发生了“广播风暴”。一个<a href="https://baike.baidu.com/item/数据帧/10571824" target="_blank" rel="noopener">数据帧</a>或包被传输到本地<a href="https://baike.baidu.com/item/网段/11026985" target="_blank" rel="noopener">网段</a> （由<a href="https://baike.baidu.com/item/广播域/5293530" target="_blank" rel="noopener">广播域</a>定义）上的每个<a href="https://baike.baidu.com/item/节点/865052" target="_blank" rel="noopener">节点</a>就是广播；由于<a href="https://baike.baidu.com/item/网络拓扑/4804125" target="_blank" rel="noopener">网络拓扑</a>的设计和连接问题，或其他原因导致广播在网段内大量复制，传播<a href="https://baike.baidu.com/item/数据帧/10571824" target="_blank" rel="noopener">数据帧</a>，导致网络性能下降，甚至<a href="https://baike.baidu.com/item/网络瘫痪/5928979" target="_blank" rel="noopener">网络瘫痪</a>，这就是广播风暴。</p>
<h4 id="2、ip地址与ip协议"><a href="#2、ip地址与ip协议" class="headerlink" title="2、ip地址与ip协议"></a>2、ip地址与ip协议</h4><ul>
<li>规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示</li>
<li>范围0.0.0.0-255.255.255.255</li>
<li>一个ip地址通常写成四段十进制数，例：172.16.10.1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip保留地址：</span><br><span class="line"></span><br><span class="line">a类网   10.0.0.0~10.255.255.255</span><br><span class="line"></span><br><span class="line">b类网   172.16.0.0~172.31.255.255</span><br><span class="line"></span><br><span class="line">c类网   192.168.0.0~192.168.255.255</span><br></pre></td></tr></table></figure>

<h4 id="3、mac地址"><a href="#3、mac地址" class="headerlink" title="3、mac地址"></a>3、mac地址</h4><p>​        head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址。</p>
<p>　　mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）</p>
<h4 id="4、arp协议——查询IP地址和MAC地址的对应关系"><a href="#4、arp协议——查询IP地址和MAC地址的对应关系" class="headerlink" title="4、arp协议——查询IP地址和MAC地址的对应关系"></a>4、arp协议——查询IP地址和MAC地址的对应关系</h4><p>​        地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。</p>
<p>　　主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址。</p>
<p>　　收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p>
<p>　　地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。</p>
<h3 id="三、广域网与路由器"><a href="#三、广域网与路由器" class="headerlink" title="三、广域网与路由器"></a>三、广域网与路由器</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/13.png" alt></p>
<h4 id="1、网关"><a href="#1、网关" class="headerlink" title="1、网关"></a>1、网关</h4><p>​        大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送消息，也必须经过一道“关口”，这道关口就是网关。顾名思义网关（Gateway）就是一个网络连接到另一个网络的“关口”。也就是网络关卡。</p>
<p>​        网关(Gateway)又称网间连接器、协议转换器。默认网关在网络层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连 [1]  。</p>
<p>​        网关ip：局域网内的机器访问公网ip，就通过网关访问</p>
<h4 id="2、路由器"><a href="#2、路由器" class="headerlink" title="2、路由器"></a>2、路由器</h4><p>​        路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。 路由器是互联网络的枢纽，”交通警察”。目前路由器已经广泛应用于各行各业，各种不同档次的产品已成为实现各种骨干网内部连接、骨干网间互联和骨干网与互联网互联互通业务的主力军。路由和交换机之间的主要区别就是交换机发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换机在移动信息的过程中需使用不同的控制信息，所以说两者实现各自功能的方式是不同的。</p>
<p>　　路由器（Router）又称网关设备（Gateway）是用于连接多个逻辑上分开的网络，所谓逻辑网络是代表一个单独的网络或者一个子网。当数据从一个子网传输到另一个子网时，可通过路由器的路由功能来完成。因此，路由器具有判断网络地址和选择IP路径的功能，它能在多网络互联环境中，建立灵活的连接，可用完全不同的数据分组和介质访问方法连接各种子网，路由器只接受源站或其他路由器的信息，属网络层的一种互联设备。</p>
<h4 id="3、局域网"><a href="#3、局域网" class="headerlink" title="3、局域网"></a>3、局域网</h4><p>​        局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。</p>
<h3 id="三、子网掩码"><a href="#三、子网掩码" class="headerlink" title="三、子网掩码"></a>三、子网掩码</h3><p>​    所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p>
<p>　　<strong>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。</strong>方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">比如，已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，</span><br><span class="line"></span><br><span class="line">172.16.10.1：10101100.00010000.00001010.000000001</span><br><span class="line">255255.255.255.0:11111111.11111111.11111111.00000000</span><br><span class="line">AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">172.16.10.2：10101100.00010000.00001010.00000010</span><br><span class="line">255255.255.255.0:11111111.11111111.11111111.00000000</span><br><span class="line">AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</span><br><span class="line">结果都是172.16.10.0，因此它们在同一个子网络。</span><br></pre></td></tr></table></figure>

<p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p>
<h3 id="四、tcp协议和udp协议"><a href="#四、tcp协议和udp协议" class="headerlink" title="四、tcp协议和udp协议"></a>四、tcp协议和udp协议</h3><p>​        用于应用程序之间的通信。如果说ip地址和mac地址帮我们确定唯一的一台机器，那么我们怎么找到一台机器上的一个软件呢？</p>
<h4 id="1、端口"><a href="#1、端口" class="headerlink" title="1、端口"></a>1、端口</h4><p>​        我们知道，一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。</p>
<p>​        在计算机上，每一个需要网络通信的程序，都会开一个端口。在同一时间只会有一个程序占用一个端口，不可能在同一时间有两个及以上程序占用同一个端口。所以通过端口来找到程序。</p>
<p>​        端口的范围： 0 - 65535， 一般我们使用8000之后的端口。靠前的端口有可能是系统默认使用的。</p>
<p>​        IP —— 确定唯一一台机器</p>
<p>​        端口 —— 确定唯一一台程序</p>
<p>​        IP+端口 —— 找到唯一的一台机器上的唯一的一个程序</p>
<h4 id="2、TCP协议"><a href="#2、TCP协议" class="headerlink" title="2、TCP协议"></a>2、TCP协议</h4><p>​        当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。</p>
<p>​        全双工：双方都能互相收发消息。</p>
<p>　　这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/14.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tcp的三次握手:</span><br><span class="line">			TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK[1]，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接。[1] </span><br><span class="line">TCP三次握手的过程如下：</span><br><span class="line">客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。</span><br><span class="line">服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。</span><br><span class="line">客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。</span><br><span class="line">三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tcp的四次挥手:</span><br><span class="line">建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。</span><br><span class="line">(1) 某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。</span><br><span class="line">(2) 接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。</span><br><span class="line">注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</span><br><span class="line">(3) 一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。</span><br><span class="line">(4) 接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。[1] </span><br><span class="line">既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。</span><br><span class="line">注意：</span><br><span class="line">(1) “通常”是指，某些情况下，步骤1的FIN随数据一起发送，另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。[2] </span><br><span class="line">(2) 在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的，这称为“半关闭”（half-close）。</span><br><span class="line">(3) 当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN。</span><br><span class="line">无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。[2]</span><br></pre></td></tr></table></figure>

<h4 id="3、UDP协议"><a href="#3、UDP协议" class="headerlink" title="3、UDP协议"></a>3、UDP协议</h4><p>　　当应用程序希望通过UDP与一个应用程序通信时，传输数据之前源端和终端不建立连接。</p>
<p>　　当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。</p>
<h3 id="五、tcp和udp的对比"><a href="#五、tcp和udp的对比" class="headerlink" title="五、tcp和udp的对比"></a>五、tcp和udp的对比</h3><p>​        TCP—传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>​        UDP—用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快</p>
<p>​        tcp：打电话</p>
<p>​        udp：发短信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">更多：</span><br><span class="line">		现在Internet上流行的协议是TCP/IP协议，该协议中对低于1024的端口都有确切的定义，他们对应着Internet上一些常见的服务。这些常见的服务可以分为使用TCP端口（面向连接）和使用UDP端口（面向无连接）两种。 </span><br><span class="line">		说到TCP和UDP,首先要明白“连接”和“无连接”的含义，他们的关系可以用一个形象地比喻来说明，就是打电话和写信。两个人如果要通话，首先要建立连接——即打电话时的拨号，等待响应后——即接听电话后，才能相互传递信息，最后还要断开连接——即挂电话。写信就比较简单了，填写好收信人的地址后将信投入邮筒，收信人就可以收到了。从这个分析可以看出，建立连接可以在需要痛心地双方建立一个传递信息的通道，在发送方发送请求连接信息接收方响应后，由于是在接受方响应后才开始传递信息，而且是在一个通道中传送，因此接受方能比较完整地收到发送方发出的信息，即信息传递的可靠性比较高。但也正因为需要建立连接，使资源开销加大（在建立连接前必须等待接受方响应，传输信息过程中必须确认信息是否传到及断开连接时发出相应的信号等），独占一个通道，在断开连接钱不能建立另一个连接，即两人在通话过程中第三方不能打入电话。而无连接是一开始就发送信息（严格说来，这是没有开始、结束的），只是一次性的传递，是先不需要接受方的响应，因而在一定程度上也无法保证信息传递的可靠性了，就像写信一样，我们只是将信寄出去，却不能保证收信人一定可以收到。 </span><br><span class="line">		TCP是面向连接的，有比较高的可靠性， 一些要求比较高的服务一般使用这个协议，如FTP、Telnet、SMTP、HTTP、POP3等。</span><br><span class="line">而UDP是面向无连接的，使用这个协议的常见服务有DNS、SNMP、QQ等。对于QQ必须另外说明一下，QQ2003以前是只使用UDP协议的，其服务器使用8000端口，侦听是否有信息传来，客户端使用4000端口，向外发送信息（这也就不难理解在一般的显IP的QQ版本中显示好友的IP地址信息中端口常为4000或其后续端口的原因了），即QQ程序既接受服务又提供服务，在以后的QQ版本中也支持使用TCP协议了。</span><br></pre></td></tr></table></figure>

<h2 id="（二）互联网协议与osi模型"><a href="#（二）互联网协议与osi模型" class="headerlink" title="（二）互联网协议与osi模型"></a>（二）互联网协议与osi模型</h2><p>互联网协议按照功能不同分为osi七层或tcp/ip五层或tcp/ip四层</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.png" alt></p>
<h3 id="一、每层运行常见物理设备"><a href="#一、每层运行常见物理设备" class="headerlink" title="一、每层运行常见物理设备"></a>一、每层运行常见物理设备</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/16.png" alt></p>
<h3 id="二、每层运行常见的协议"><a href="#二、每层运行常见的协议" class="headerlink" title="二、每层运行常见的协议"></a>二、每层运行常见的协议</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/17.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/python全栈/第01部分：基础+模块+面向对象+网络编程/模块/常用模块（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/python全栈/第01部分：基础+模块+面向对象+网络编程/模块/常用模块（一）/" itemprop="url">常用模块（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-24T00:25:31+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-01部分-模块和包/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -01部分 -模块和包</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="（一）认识模块"><a href="#（一）认识模块" class="headerlink" title="（一）认识模块"></a>（一）认识模块</h2><h3 id="一、什么是模块"><a href="#一、什么是模块" class="headerlink" title="一、什么是模块"></a>一、什么是模块</h3><h4 id="1、什么是模块"><a href="#1、什么是模块" class="headerlink" title="1、什么是模块"></a>1、什么是模块</h4><p>常见的场景：一个模块就是一个包含了python定义和声明的文件，文件名就是模块名字加上.py的后缀。</p>
<p>   但其实import加载的模块分为四个通用类别：　</p>
<ol>
<li>使用python编写的代码（.py文件）</li>
<li>已被编译为共享库或DLL的C或C++扩展</li>
<li>包好一组模块的包</li>
<li>使用C编写并链接到python解释器的内置模块</li>
</ol>
<h4 id="2、为何要使用模块"><a href="#2、为何要使用模块" class="headerlink" title="2、为何要使用模块"></a>2、为何要使用模块</h4><p>​        如果你退出python解释器然后重新进入，那么你之前定义的函数或者变量都将丢失，因此我们通常将程序写到文件中以便永久保存下来，需要时就通过python test.py方式去执行，此时test.py被称为脚本script。</p>
<p>​        随着程序的发展，功能越来越多，为了方便管理，我们通常将程序分成一个个的文件，这样做程序的结构更清晰，方便管理。这时我们不仅仅可以把这些文件当做脚本去执行，还可以把他们当做模块来导入到其他的模块中，实现了功能的重复利用</p>
<h3 id="二、模块的导入和使用"><a href="#二、模块的导入和使用" class="headerlink" title="二、模块的导入和使用"></a>二、模块的导入和使用</h3><p>见 “模块和包”</p>
<h2 id="（二）常用模块（一）"><a href="#（二）常用模块（一）" class="headerlink" title="（二）常用模块（一）"></a>（二）常用模块（一）</h2><h3 id="一、collections模块"><a href="#一、collections模块" class="headerlink" title="一、collections模块"></a>一、collections模块</h3><p>在内置数据类型（dict、list、set、tuple）的基础上，collections模块还提供了几个额外的数据类型：Counter、deque、defaultdict、namedtuple和OrderedDict等。</p>
<ol>
<li>namedtuple: 生成可以使用名字来访问元素内容的tuple</li>
<li>deque: 双端队列，可以快速的从另外一侧追加和推出对象</li>
<li>Counter: 计数器，主要用来计数 </li>
<li>OrderedDict: 有序字典 </li>
<li>defaultdict: 带有默认值的字典</li>
</ol>
<h4 id="1、namedtuple"><a href="#1、namedtuple" class="headerlink" title="1、namedtuple"></a>1、namedtuple</h4><p>我们知道tuple可以表示不变集合，例如，一个点的二维坐标就可以表示成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = (<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>但是，看到(1, 2)，很难看出这个tuple是用来表示一个坐标的。</p>
<p>这时，namedtuple就派上了用场：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point = namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.y</span><br></pre></td></tr></table></figure>

<p>类似的，如果要用坐标和半径表示一个圆，也可以用namedtuple定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#namedtuple('名称', [属性list]):</span></span><br><span class="line">Circle = namedtuple(<span class="string">'Circle'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'r'</span>])</span><br></pre></td></tr></table></figure>

<h4 id="2、deque"><a href="#2、deque" class="headerlink" title="2、deque"></a>2、deque</h4><p>​        使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。</p>
<p>​         deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="string">'x'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.appendleft(<span class="string">'y'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="string">'y'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'x'</span>])</span><br></pre></td></tr></table></figure>

<p>deque除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>
<h4 id="3、OrderedDict"><a href="#3、OrderedDict" class="headerlink" title="3、OrderedDict"></a>3、OrderedDict</h4><p>使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。</p>
<p>如果要保持Key的顺序，可以用<code>OrderedDict</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d <span class="comment"># dict的Key是无序的</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od = OrderedDict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od <span class="comment"># OrderedDict的Key是有序的</span></span><br><span class="line">OrderedDict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br></pre></td></tr></table></figure>

<p>注意，<code>OrderedDict</code>的Key会按照插入的顺序排列，不是Key本身排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>od = OrderedDict()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od[<span class="string">'z'</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od[<span class="string">'y'</span>] = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od[<span class="string">'x'</span>] = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od.keys() <span class="comment"># 按照插入的Key的顺序返回</span></span><br><span class="line">[<span class="string">'z'</span>, <span class="string">'y'</span>, <span class="string">'x'</span>]</span><br></pre></td></tr></table></figure>

<h4 id="4、defaultdict"><a href="#4、defaultdict" class="headerlink" title="4、defaultdict"></a>4、defaultdict</h4><p>有如下值集合 [<code>11</code>,<code>22</code>,<code>33</code>,<code>44</code>,<code>55</code>,<code>66</code>,<code>77</code>,<code>88</code>,<code>99</code>,<code>90.</code>..]，将所有大于 66的值保存至字典的第一个key中，将小于 66的值保存至第二个key的值中。<br>即： {k1: 大于66, k2: 小于66}</p>
<p><strong>原生字典解决方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">values = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>,<span class="number">90</span>]</span><br><span class="line"></span><br><span class="line">my_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span>  values:</span><br><span class="line">    <span class="keyword">if</span> value&gt;<span class="number">66</span>:</span><br><span class="line">        <span class="keyword">if</span> my_dict.has_key(<span class="string">'k1'</span>):</span><br><span class="line">            my_dict[<span class="string">'k1'</span>].append(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            my_dict[<span class="string">'k1'</span>] = [value]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> my_dict.has_key(<span class="string">'k2'</span>):</span><br><span class="line">            my_dict[<span class="string">'k2'</span>].append(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            my_dict[<span class="string">'k2'</span>] = [value]</span><br></pre></td></tr></table></figure>

<p><strong>defaultdict字典解决方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">values = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>,<span class="number">90</span>]</span><br><span class="line"></span><br><span class="line">my_dict = defaultdict(list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span>  values:</span><br><span class="line">    <span class="keyword">if</span> value&gt;<span class="number">66</span>:</span><br><span class="line">        my_dict[<span class="string">'k1'</span>].append(value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        my_dict[<span class="string">'k2'</span>].append(value)</span><br></pre></td></tr></table></figure>

<p>使用<code>dict</code>时，如果引用的Key不存在，就会抛出<code>KeyError</code>。如果希望key不存在时，返回一个默认值，就可以用<code>defaultdict</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(<span class="keyword">lambda</span>: <span class="string">'N/A'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key1'</span>] = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key1'</span>] <span class="comment"># key1存在</span></span><br><span class="line"><span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key2'</span>] <span class="comment"># key2不存在，返回默认值</span></span><br><span class="line"><span class="string">'N/A'</span></span><br></pre></td></tr></table></figure>

<h4 id="5、Counter"><a href="#5、Counter" class="headerlink" title="5、Counter"></a>5、Counter</h4><p>Counter类的目的是用来跟踪值出现的次数。它是一个无序的容器类型，以字典的键值对形式存储，其中元素作为key，其计数作为value。计数值可以是任意的Interger（包括0和负数）。Counter类和其他语言的bags或multisets很相似。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = Counter(<span class="string">'abcdeabcdabcaba'</span>)</span><br><span class="line"><span class="keyword">print</span> c</span><br><span class="line">输出：Counter(&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">4</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'e'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="二、时间模块"><a href="#二、时间模块" class="headerlink" title="二、时间模块"></a>二、时间模块</h3><p>和时间有关系的我们就要用到时间模块。在使用模块之前，应该首先导入这个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#常用方法</span><br><span class="line">1.time.sleep(secs)</span><br><span class="line">(线程)推迟指定的时间运行。单位为秒。</span><br><span class="line">2.time.time()</span><br><span class="line">获取当前时间戳</span><br></pre></td></tr></table></figure>

<h4 id="1、表示时间的三种方式"><a href="#1、表示时间的三种方式" class="headerlink" title="1、表示时间的三种方式"></a>1、表示时间的三种方式</h4><p>在Python中，通常有这三种方式来表示时间：时间戳、元组(struct_time)、格式化的时间字符串：</p>
<ol>
<li><p>时间戳(timestamp) ：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">python中时间日期格式化符号：</span><br><span class="line">%y 两位数的年份表示（00-99）</span><br><span class="line">%Y 四位数的年份表示（000-9999）</span><br><span class="line">%m 月份（01-12）</span><br><span class="line">%d 月内中的一天（0-31）</span><br><span class="line">%H 24小时制小时数（0-23）</span><br><span class="line">%I 12小时制小时数（01-12）</span><br><span class="line">%M 分钟数（00=59）</span><br><span class="line">%S 秒（00-59）</span><br><span class="line">%a 本地简化星期名称</span><br><span class="line">%A 本地完整星期名称</span><br><span class="line">%b 本地简化的月份名称</span><br><span class="line">%B 本地完整的月份名称</span><br><span class="line">%c 本地相应的日期表示和时间表示</span><br><span class="line">%j 年内的一天（001-366）</span><br><span class="line">%p 本地A.M.或P.M.的等价符</span><br><span class="line">%U 一年中的星期数（00-53）星期天为星期的开始</span><br><span class="line">%w 星期（0-6），星期天为星期的开始</span><br><span class="line">%W 一年中的星期数（00-53）星期一为星期的开始</span><br><span class="line">%x 本地相应的日期表示</span><br><span class="line">%X 本地相应的时间表示</span><br><span class="line">%Z 当前时区的名称</span><br><span class="line">%% %号本身</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>格式化的时间字符串(Format String)： ‘1999-12-06’</p>
<table>
<thead>
<tr>
<th align="left">索引（Index）</th>
<th>属性（Attribute）</th>
<th align="left">值（Values）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td>tm_year（年）</td>
<td align="left">比如2011</td>
</tr>
<tr>
<td align="left">1</td>
<td>tm_mon（月）</td>
<td align="left">1 - 12</td>
</tr>
<tr>
<td align="left">2</td>
<td>tm_mday（日）</td>
<td align="left">1 - 31</td>
</tr>
<tr>
<td align="left">3</td>
<td>tm_hour（时）</td>
<td align="left">0 - 23</td>
</tr>
<tr>
<td align="left">4</td>
<td>tm_min（分）</td>
<td align="left">0 - 59</td>
</tr>
<tr>
<td align="left">5</td>
<td>tm_sec（秒）</td>
<td align="left">0 - 60</td>
</tr>
<tr>
<td align="left">6</td>
<td>tm_wday（weekday）</td>
<td align="left">0 - 6（0表示周一）</td>
</tr>
<tr>
<td align="left">7</td>
<td>tm_yday（一年中的第几天）</td>
<td align="left">1 - 366</td>
</tr>
<tr>
<td align="left">8</td>
<td>tm_isdst（是否是夏令时）</td>
<td align="left">默认为0</td>
</tr>
</tbody></table>
</li>
</ol>
<p>首先，我们先导入time模块，来认识一下python中表示时间的几种格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入时间模块</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#时间戳</span></span><br><span class="line">&gt;&gt;&gt;time.time()</span><br><span class="line"><span class="number">1500875844.800804</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间字符串</span></span><br><span class="line">&gt;&gt;&gt;time.strftime(<span class="string">"%Y-%m-%d %X"</span>)</span><br><span class="line"><span class="string">'2017-07-24 13:54:37'</span></span><br><span class="line">&gt;&gt;&gt;time.strftime(<span class="string">"%Y-%m-%d %H-%M-%S"</span>)</span><br><span class="line"><span class="string">'2017-07-24 13-55-04'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间元组:localtime将一个时间戳转换为当前时区的struct_time</span></span><br><span class="line">time.localtime()</span><br><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">7</span>, tm_mday=<span class="number">24</span>,</span><br><span class="line">　　　　　　　　　　tm_hour=<span class="number">13</span>, tm_min=<span class="number">59</span>, tm_sec=<span class="number">37</span>, </span><br><span class="line">                 tm_wday=<span class="number">0</span>, tm_yday=<span class="number">205</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong><em>小结：</em></strong></p>
<p>时间戳是计算机能够识别的时间；时间字符串是人能够看懂的时间；元组则是用来操作时间的</p>
<h4 id="2、几种格式之间的转换"><a href="#2、几种格式之间的转换" class="headerlink" title="2、几种格式之间的转换"></a>2、几种格式之间的转换</h4><p><img src="https://images2015.cnblogs.com/blog/827651/201707/827651-20170724144151992-1508626640.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#时间戳--&gt;结构化时间</span></span><br><span class="line"><span class="comment">#time.gmtime(时间戳)    #UTC时间，与英国伦敦当地时间一致</span></span><br><span class="line"><span class="comment">#time.localtime(时间戳) #当地时间。例如我们现在在北京执行这个方法：与UTC时间相差8小时，UTC时间+8小时 = 北京时间 </span></span><br><span class="line">&gt;&gt;&gt;time.gmtime(<span class="number">1500000000</span>)</span><br><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">7</span>, tm_mday=<span class="number">14</span>, tm_hour=<span class="number">2</span>, tm_min=<span class="number">40</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">4</span>, tm_yday=<span class="number">195</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt;time.localtime(<span class="number">1500000000</span>)</span><br><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">7</span>, tm_mday=<span class="number">14</span>, tm_hour=<span class="number">10</span>, tm_min=<span class="number">40</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">4</span>, tm_yday=<span class="number">195</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结构化时间--&gt;时间戳　</span></span><br><span class="line"><span class="comment">#time.mktime(结构化时间)</span></span><br><span class="line">&gt;&gt;&gt;time_tuple = time.localtime(<span class="number">1500000000</span>)</span><br><span class="line">&gt;&gt;&gt;time.mktime(time_tuple)</span><br><span class="line"><span class="number">1500000000.0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#结构化时间--&gt;字符串时间</span></span><br><span class="line"><span class="comment">#time.strftime("格式定义","结构化时间")  结构化时间参数若不传，则显示当前时间</span></span><br><span class="line">&gt;&gt;&gt;time.strftime(<span class="string">"%Y-%m-%d %X"</span>)</span><br><span class="line"><span class="string">'2017-07-24 14:55:36'</span></span><br><span class="line">&gt;&gt;&gt;time.strftime(<span class="string">"%Y-%m-%d"</span>,time.localtime(<span class="number">1500000000</span>))</span><br><span class="line"><span class="string">'2017-07-14'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#字符串时间--&gt;结构化时间</span></span><br><span class="line"><span class="comment">#time.strptime(时间字符串,字符串对应格式)</span></span><br><span class="line">&gt;&gt;&gt;time.strptime(<span class="string">"2017-03-16"</span>,<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">3</span>, tm_mday=<span class="number">16</span>, tm_hour=<span class="number">0</span>, tm_min=<span class="number">0</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">3</span>, tm_yday=<span class="number">75</span>, tm_isdst=<span class="number">-1</span>)</span><br><span class="line">&gt;&gt;&gt;time.strptime(<span class="string">"07/24/2017"</span>,<span class="string">"%m/%d/%Y"</span>)</span><br><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">7</span>, tm_mday=<span class="number">24</span>, tm_hour=<span class="number">0</span>, tm_min=<span class="number">0</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">205</span>, tm_isdst=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/827651/201707/827651-20170724144235883-1963884021.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#结构化时间 --&gt; %a %b %d %H:%M:%S %Y串</span></span><br><span class="line"><span class="comment">#time.asctime(结构化时间) 如果不传参数，直接返回当前时间的格式化串</span></span><br><span class="line">&gt;&gt;&gt;time.asctime(time.localtime(<span class="number">1500000000</span>))</span><br><span class="line"><span class="string">'Fri Jul 14 10:40:00 2017'</span></span><br><span class="line">&gt;&gt;&gt;time.asctime()</span><br><span class="line"><span class="string">'Mon Jul 24 15:18:33 2017'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间戳 --&gt; %a %b %d %H:%M:%S %Y串</span></span><br><span class="line"><span class="comment">#time.ctime(时间戳)  如果不传参数，直接返回当前时间的格式化串</span></span><br><span class="line">&gt;&gt;&gt;time.ctime()</span><br><span class="line"><span class="string">'Mon Jul 24 15:19:07 2017'</span></span><br><span class="line">&gt;&gt;&gt;time.ctime(<span class="number">1500000000</span>)</span><br><span class="line"><span class="string">'Fri Jul 14 10:40:00 2017'</span></span><br></pre></td></tr></table></figure>

<p>计算时间差：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">true_time=time.mktime(time.strptime(<span class="string">'2017-09-11 08:30:00'</span>,<span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br><span class="line">time_now=time.mktime(time.strptime(<span class="string">'2017-09-12 11:00:00'</span>,<span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br><span class="line">dif_time=time_now-true_time</span><br><span class="line">struct_time=time.gmtime(dif_time)</span><br><span class="line">print(<span class="string">'过去了%d年%d月%d天%d小时%d分钟%d秒'</span>%(struct_time.tm_year<span class="number">-1970</span>,struct_time.tm_mon<span class="number">-1</span>,</span><br><span class="line">                                       struct_time.tm_mday<span class="number">-1</span>,struct_time.tm_hour,</span><br><span class="line">                                       struct_time.tm_min,struct_time.tm_sec))</span><br></pre></td></tr></table></figure>

<h3 id="三、random模块"><a href="#三、random模块" class="headerlink" title="三、random模块"></a>三、random模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#随机小数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.random()      <span class="comment"># 大于0且小于1之间的小数</span></span><br><span class="line"><span class="number">0.7664338663654585</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.uniform(<span class="number">1</span>,<span class="number">3</span>) <span class="comment">#大于1小于3的小数</span></span><br><span class="line"><span class="number">1.6270147180533838</span></span><br><span class="line"><span class="comment">#恒富：发红包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#随机整数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">1</span>,<span class="number">5</span>)  <span class="comment"># 大于等于1且小于等于5之间的整数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randrange(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>) <span class="comment"># 大于等于1且小于10之间的奇数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#随机选择一个返回</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.choice([<span class="number">1</span>,<span class="string">'23'</span>,[<span class="number">4</span>,<span class="number">5</span>]])  <span class="comment"># #1或者23或者[4,5]</span></span><br><span class="line"><span class="comment">#随机选择多个返回，返回的个数为函数的第二个参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.sample([<span class="number">1</span>,<span class="string">'23'</span>,[<span class="number">4</span>,<span class="number">5</span>]],<span class="number">2</span>) <span class="comment"># #列表元素任意2个组合</span></span><br><span class="line">[[<span class="number">4</span>, <span class="number">5</span>], <span class="string">'23'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#打乱列表顺序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(item) <span class="comment"># 打乱次序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item</span><br><span class="line">[<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(item)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>生成随机验证码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">v_code</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    code = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"></span><br><span class="line">        num=random.randint(<span class="number">0</span>,<span class="number">9</span>)</span><br><span class="line">        alf=chr(random.randint(<span class="number">65</span>,<span class="number">90</span>))</span><br><span class="line">        add=random.choice([num,alf])</span><br><span class="line">        code=<span class="string">""</span>.join([code,str(add)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line">print(v_code())</span><br></pre></td></tr></table></figure>

<h3 id="四、os模块"><a href="#四、os模块" class="headerlink" title="四、os模块"></a>四、os模块</h3><p>os模块是与操作系统交互的一个接口</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">os.makedirs(<span class="string">'dirname1/dirname2'</span>)    可生成多层递归目录</span><br><span class="line">os.removedirs(<span class="string">'dirname1'</span>)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</span><br><span class="line">os.mkdir(<span class="string">'dirname'</span>)    生成单级目录；相当于shell中mkdir dirname</span><br><span class="line">os.rmdir(<span class="string">'dirname'</span>)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</span><br><span class="line">os.listdir(<span class="string">'dirname'</span>)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</span><br><span class="line">os.remove()  删除一个文件</span><br><span class="line">os.rename(<span class="string">"oldname"</span>,<span class="string">"newname"</span>)  重命名文件/目录</span><br><span class="line">os.stat(<span class="string">'path/filename'</span>)  获取文件/目录信息</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">"bash command"</span>)  运行shell命令，直接显示</span><br><span class="line">os.popen(<span class="string">"bash command).read()  运行shell命令，获取执行结果</span></span><br><span class="line"><span class="string">os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径</span></span><br><span class="line"><span class="string">os.chdir("</span>dirname<span class="string">")  改变当前脚本工作目录；相当于shell下cd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">os.path</span></span><br><span class="line"><span class="string">os.path.abspath(path) 返回path规范化的绝对路径</span></span><br><span class="line"><span class="string">os.path.split(path) 将path分割成目录和文件名二元组返回 </span></span><br><span class="line"><span class="string">os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素 </span></span><br><span class="line"><span class="string">os.path.basename(path) 返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span></span><br><span class="line"><span class="string">os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False</span></span><br><span class="line"><span class="string">os.path.isabs(path)  如果path是绝对路径，返回True</span></span><br><span class="line"><span class="string">os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False</span></span><br><span class="line"><span class="string">os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False</span></span><br><span class="line"><span class="string">os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span></span><br><span class="line"><span class="string">os.path.getatime(path)  返回path所指向的文件或者目录的最后访问时间</span></span><br><span class="line"><span class="string">os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间</span></span><br><span class="line"><span class="string">os.path.getsize(path) 返回path的大小</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>os.stat(‘path/filename’)  获取文件/目录信息 的结构说明</p>
<p>stat结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stat 结构:</span><br><span class="line"></span><br><span class="line">st_mode: inode 保护模式</span><br><span class="line">st_ino: inode 节点号。</span><br><span class="line">st_dev: inode 驻留的设备。</span><br><span class="line">st_nlink: inode 的链接数。</span><br><span class="line">st_uid: 所有者的用户ID。</span><br><span class="line">st_gid: 所有者的组ID。</span><br><span class="line">st_size: 普通文件以字节为单位的大小；包含等待某些特殊文件的数据。</span><br><span class="line">st_atime: 上次访问的时间。</span><br><span class="line">st_mtime: 最后一次修改的时间。</span><br><span class="line">st_ctime: 由操作系统报告的&quot;ctime&quot;。在某些系统上（如Unix）是最新的元数据更改的时间，在其它系统上（如Windows）是创建时间（详细信息参见平台的文档）。</span><br></pre></td></tr></table></figure>

<p>os模块的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os.sep    输出操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot;</span><br><span class="line">os.linesep    输出当前平台使用的行终止符，win下为&quot;\r\n&quot;,Linux下为&quot;\n&quot;</span><br><span class="line">os.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:</span><br><span class="line">os.name    输出字符串指示当前使用平台。win-&gt;&apos;nt&apos;; Linux-&gt;&apos;posix&apos;</span><br></pre></td></tr></table></figure>

<h3 id="五、sys模块"><a href="#五、sys模块" class="headerlink" title="五、sys模块"></a>五、sys模块</h3><p>sys模块是与python解释器交互的一个接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sys.argv           命令行参数List，第一个元素是程序本身路径</span><br><span class="line">sys.exit(n)        退出程序，正常退出时exit(0),错误退出sys.exit(1)</span><br><span class="line">sys.version        获取Python解释程序的版本信息</span><br><span class="line">sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</span><br><span class="line">sys.platform       返回操作系统平台名称</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> SystemExit <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>

<h3 id="六、序列化模块"><a href="#六、序列化模块" class="headerlink" title="六、序列化模块"></a>六、序列化模块</h3><p>什么叫序列化——将原本的字典、列表等内容转换成一个字符串的过程就叫做<strong>序列化</strong>。</p>
<p>为什么要有序列化模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">比如，我们在python代码中计算的一个数据需要给另外一段程序使用，那我们怎么给？</span><br><span class="line">现在我们能想到的方法就是存在文件里，然后另一个python程序再从文件里读出来。</span><br><span class="line">但是我们都知道，对于文件来说是没有字典这个概念的，所以我们只能将数据转换成字典放到文件中。</span><br><span class="line">你一定会问，将字典转换成一个字符串很简单，就是str(dic)就可以办到了，为什么我们还要学习序列化模块呢？</span><br><span class="line">没错序列化的过程就是从dic 变成str(dic)的过程。现在你可以通过str(dic)，将一个名为dic的字典转换成一个字符串，</span><br><span class="line">但是你要怎么把一个字符串转换成字典呢？</span><br><span class="line">聪明的你肯定想到了eval()，如果我们将一个字符串类型的字典str_dic传给eval，就会得到一个返回的字典类型了。</span><br><span class="line">eval()函数十分强大，但是eval是做什么的？e官方demo解释为：将字符串str当成有效的表达式来求值并返回计算结果。</span><br><span class="line">ＢＵＴ！强大的函数有代价。安全性是其最大的缺点。</span><br><span class="line">想象一下，如果我们从文件中读出的不是一个数据结构，而是一句&quot;删除文件&quot;类似的破坏性语句，那么后果实在不堪设设想。</span><br><span class="line">而使用eval就要担这个风险。</span><br><span class="line">所以，我们并不推荐用eval方法来进行反序列化操作(将str转换成python中的数据结构)</span><br></pre></td></tr></table></figure>

<p><strong>序列化的目的</strong></p>
<p>1、以某种存储形式使自定义<a href="https://baike.baidu.com/item/对象持久化" target="_blank" rel="noopener">对象持久化</a>；</p>
<p>2、将对象从一个地方传递到另一个地方。</p>
<p>3、使程序更具维护性。</p>
<p><img src="https://images2017.cnblogs.com/blog/827651/201708/827651-20170805234418803-1378181341.png" alt></p>
<p>用于序列化的两个模块</p>
<ul>
<li>json，用于字符串 和 python数据类型间进行转换</li>
<li>pickle，用于python特有的类型 和 python的数据类型间进行转换</li>
</ul>
<h4 id="1、json"><a href="#1、json" class="headerlink" title="1、json"></a>1、json</h4><p>Json模块提供了四个功能：dumps、dump、loads、load</p>
<p><strong>loads和dumps</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>,<span class="string">'k3'</span>:<span class="string">'v3'</span>&#125;</span><br><span class="line">str_dic = json.dumps(dic)  <span class="comment">#序列化：将一个字典转换成一个字符串</span></span><br><span class="line">print(type(str_dic),str_dic)  <span class="comment">#&lt;class 'str'&gt; &#123;"k3": "v3", "k1": "v1", "k2": "v2"&#125;</span></span><br><span class="line"><span class="comment">#注意，json转换完的字符串类型的字典中的字符串是由""表示的</span></span><br><span class="line"></span><br><span class="line">dic2 = json.loads(str_dic)  <span class="comment">#反序列化：将一个字符串格式的字典转换成一个字典</span></span><br><span class="line"><span class="comment">#注意，要用json的loads功能处理的字符串类型的字典中的字符串必须由""表示</span></span><br><span class="line">print(type(dic2),dic2)  <span class="comment">#&lt;class 'dict'&gt; &#123;'k1': 'v1', 'k2': 'v2', 'k3': 'v3'&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list_dic = [<span class="number">1</span>,[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],<span class="number">3</span>,&#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>&#125;]</span><br><span class="line">str_dic = json.dumps(list_dic) <span class="comment">#也可以处理嵌套的数据类型 </span></span><br><span class="line">print(type(str_dic),str_dic) <span class="comment">#&lt;class 'str'&gt; [1, ["a", "b", "c"], 3, &#123;"k1": "v1", "k2": "v2"&#125;]</span></span><br><span class="line">list_dic2 = json.loads(str_dic)</span><br><span class="line">print(type(list_dic2),list_dic2) <span class="comment">#&lt;class 'list'&gt; [1, ['a', 'b', 'c'], 3, &#123;'k1': 'v1', 'k2': 'v2'&#125;]</span></span><br></pre></td></tr></table></figure>

<p><strong>load和dump</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">f = open(<span class="string">'json_file'</span>,<span class="string">'w'</span>)</span><br><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>,<span class="string">'k3'</span>:<span class="string">'v3'</span>&#125;</span><br><span class="line">json.dump(dic,f)  <span class="comment">#dump方法接收一个文件句柄，直接将字典转换成json字符串写入文件</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'json_file'</span>)</span><br><span class="line">dic2 = json.load(f)  <span class="comment">#load方法接收一个文件句柄，直接将文件中的json字符串转换成数据结构返回</span></span><br><span class="line">f.close()</span><br><span class="line">print(type(dic2),dic2)</span><br></pre></td></tr></table></figure>

<p><strong>ensure_ascii关键字参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">f = open(<span class="string">'file'</span>,<span class="string">'w'</span>)</span><br><span class="line">json.dump(&#123;<span class="string">'国籍'</span>:<span class="string">'中国'</span>&#125;,f)</span><br><span class="line">ret = json.dumps(&#123;<span class="string">'国籍'</span>:<span class="string">'中国'</span>&#125;)</span><br><span class="line">f.write(ret+<span class="string">'\n'</span>)</span><br><span class="line">json.dump(&#123;<span class="string">'国籍'</span>:<span class="string">'美国'</span>&#125;,f,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">ret = json.dumps(&#123;<span class="string">'国籍'</span>:<span class="string">'美国'</span>&#125;,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">f.write(ret+<span class="string">'\n'</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p><strong>其他参数说明</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Serialize obj to a JSON formatted str.(字符串表示的json对象) </span><br><span class="line">Skipkeys：默认值是False，如果dict的keys内的数据不是python的基本类型(str,unicode,int,long,float,bool,None)，设置为False时，就会报TypeError的错误。此时设置成True，则会跳过这类key </span><br><span class="line">ensure_ascii:，当它为True的时候，所有非ASCII码字符显示为\uXXXX序列，只需在dump时将ensure_ascii设置为False即可，此时存入json的中文即可正常显示。) </span><br><span class="line">If check_circular is false, then the circular reference check for container types will be skipped and a circular reference will result in an OverflowError (or worse). </span><br><span class="line">If allow_nan is false, then it will be a ValueError to serialize out of range float values (nan, inf, -inf) in strict compliance of the JSON specification, instead of using the JavaScript equivalents (NaN, Infinity, -Infinity). </span><br><span class="line">indent：应该是一个非负的整型，如果是0就是顶格分行显示，如果为空就是一行最紧凑显示，否则会换行且按照indent的数值显示前面的空白分行显示，这样打印出来的json数据也叫pretty-printed json </span><br><span class="line">separators：分隔符，实际上是(item_separator, dict_separator)的一个元组，默认的就是(‘,’,’:’)；这表示dictionary内keys之间用“,”隔开，而KEY和value之间用“：”隔开。 </span><br><span class="line">default(obj) is a function that should return a serializable version of obj or raise TypeError. The default simply raises TypeError. </span><br><span class="line">sort_keys：将数据根据keys的值进行排序。 </span><br><span class="line">To use a custom JSONEncoder subclass (e.g. one that overrides the .default() method to serialize additional types), specify it with the cls kwarg; otherwise JSONEncoder is used.</span><br></pre></td></tr></table></figure>

<p><strong>json的格式化输出</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">data = &#123;<span class="string">'username'</span>:[<span class="string">'李华'</span>,<span class="string">'二愣子'</span>],<span class="string">'sex'</span>:<span class="string">'male'</span>,<span class="string">'age'</span>:<span class="number">16</span>&#125;</span><br><span class="line">json_dic2 = json.dumps(data,sort_keys=<span class="literal">True</span>,indent=<span class="number">2</span>,separators=(<span class="string">','</span>,<span class="string">':'</span>),ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">print(json_dic2)</span><br></pre></td></tr></table></figure>

<h4 id="2、pickle"><a href="#2、pickle" class="headerlink" title="2、pickle"></a>2、pickle</h4><p>pickle模块提供了四个功能：dumps、dump(序列化，存）、loads（反序列化，读）、load  （不仅可以序列化字典，列表…<strong>可以把python中任意的数据类型序列化</strong>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>,<span class="string">'k3'</span>:<span class="string">'v3'</span>&#125;</span><br><span class="line">str_dic = pickle.dumps(dic)</span><br><span class="line">print(str_dic)  <span class="comment">#一串二进制内容</span></span><br><span class="line"></span><br><span class="line">dic2 = pickle.loads(str_dic)</span><br><span class="line">print(dic2)    <span class="comment">#字典</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">struct_time  = time.localtime(<span class="number">1000000000</span>)</span><br><span class="line">print(struct_time)</span><br><span class="line">f = open(<span class="string">'pickle_file'</span>,<span class="string">'wb'</span>)</span><br><span class="line">pickle.dump(struct_time,f)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'pickle_file'</span>,<span class="string">'rb'</span>)</span><br><span class="line">struct_time2 = pickle.load(f)</span><br><span class="line">print(struct_time2.tm_year)</span><br></pre></td></tr></table></figure>

<p>这时候机智的你又要说了，既然pickle如此强大，为什么还要学json呢？<br>这里我们要说明一下，json是一种所有的语言都可以识别的数据结构。<br>如果我们将一个字典或者序列化成了一个json存在文件里，那么java代码或者js代码也可以拿来用。<br>但是如果我们用pickle进行序列化，其他语言就不能读懂这是什么了～<br>所以，如果你序列化的内容是列表或者字典，我们非常推荐你使用json模块<br>但如果出于某种原因你不得不序列化其他的数据类型，而未来你还会用python对这个数据进行反序列化的话，那么就可以使用pickle</p>
<h3 id="七、re模块"><a href="#七、re模块" class="headerlink" title="七、re模块"></a>七、re模块</h3><p>讲正题之前我们先来看一个例子：<a href="https://reg.jd.com/reg/person?ReturnUrl=https%3A//www.jd.com/" target="_blank" rel="noopener">https://reg.jd.com/reg/person?ReturnUrl=https%3A//www.jd.com/</a></p>
<p>这是京东的注册页面，打开页面我们就看到这些要求输入个人信息的提示。<br>假如我们随意的在手机号码这一栏输入一个11111111111，它会提示我们格式有误。<br>这个功能是怎么实现的呢？<br>假如现在你用python写一段代码，类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phone_number = input(<span class="string">'please input your phone number ： '</span>)</span><br></pre></td></tr></table></figure>

<p>你怎么判断这个phone_number是合法的呢？</p>
<p>根据手机号码一共11位并且是只以13、14、15、18开头的数字这些特点，我们用python写了如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    phone_number = input(<span class="string">'please input your phone number ： '</span>)</span><br><span class="line">    <span class="keyword">if</span> len(phone_number) == <span class="number">11</span> \</span><br><span class="line">            <span class="keyword">and</span> phone_number.isdigit()\</span><br><span class="line">            <span class="keyword">and</span> (phone_number.startswith(<span class="string">'13'</span>) \</span><br><span class="line">            <span class="keyword">or</span> phone_number.startswith(<span class="string">'14'</span>) \</span><br><span class="line">            <span class="keyword">or</span> phone_number.startswith(<span class="string">'15'</span>) \</span><br><span class="line">            <span class="keyword">or</span> phone_number.startswith(<span class="string">'18'</span>)):</span><br><span class="line">        print(<span class="string">'是合法的手机号码'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'不是合法的手机号码'</span>)</span><br></pre></td></tr></table></figure>

<p>这是你的写法，现在我要展示一下我的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">phone_number = input(<span class="string">'please input your phone number ： '</span>)</span><br><span class="line"><span class="keyword">if</span> re.match(<span class="string">'^(13|14|15|18)[0-9]&#123;9&#125;$'</span>,phone_number):</span><br><span class="line">        print(<span class="string">'是合法的手机号码'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'不是合法的手机号码'</span>)</span><br></pre></td></tr></table></figure>

<p>对比上面的两种写法，此时此刻，我要问你你喜欢哪种方法呀？你肯定还是会说第一种，为什么呢？因为第一种不用学呀！<br>但是如果现在有一个文件，我让你从整个文件里匹配出所有的手机号码。你用python给我写个试试？<br>但是学了今天的技能之后，分分钟帮你搞定！</p>
<p>今天我们要学习python里的<strong>re模块和正则表达式</strong>，学会了这个就可以帮我们解决刚刚的疑问。正则表达式不仅在python领域，在整个编程届都占有举足轻重的地位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正则表达式和re模块:</span><br><span class="line">不管以后你是不是去做python开发，只要你是一个程序员就应该了解正则表达式的基本使用。如果未来你要在爬虫领域发展，你就更应该好好学习这方面的知识。</span><br><span class="line">但是你要知道，re模块本质上和正则表达式没有一毛钱的关系。re模块和正则表达式的关系 类似于 time模块和时间的关系</span><br><span class="line">你没有学习python之前，也不知道有一个time模块，但是你已经认识时间了 12:30就表示中午十二点半（这个时间可好，一般这会儿就该下课了）。</span><br><span class="line">时间有自己的格式，年月日时分秒，12个月，365天......已经成为了一种规则。你也早就牢记于心了。time模块只不过是python提供给我们的可以方便我们操作时间的一个工具而已</span><br></pre></td></tr></table></figure>

<p><strong>正则表达式</strong>本身也和python没有什么关系，就是<strong>匹配字符串内容的一种规则</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">官方定义：正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</span><br></pre></td></tr></table></figure>

<h4 id="（1）正则表达式"><a href="#（1）正则表达式" class="headerlink" title="（1）正则表达式"></a>（1）正则表达式</h4><p>​        一说规则我已经知道你很晕了，现在就让我们先来看一些实际的应用。<em>在线测试工具 <a href="http://tool.chinaz.com/regex/" target="_blank" rel="noopener">http://tool.chinaz.com/regex/</a></em></p>
<p>​        首先你要知道的是，谈到正则，就只和字符串相关了。在我给你提供的工具中，你输入的每一个字都是一个字符串。<br>其次，如果在一个位置的一个值，不会出现什么变化，那么是不需要规则的。<br>　　比如你要用”1”去匹配”1”，或者用”2”去匹配”2”，直接就可以匹配上。这连python的字符串操作都可以轻松做到。<br>那么在之后我们更多要考虑的是在<strong>同一个位置上</strong>可以出现的字符的范围。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字符组 ： [字符组]</span><br><span class="line">在同一个位置可能出现的各种字符组成了一个字符组，在正则表达式中用[]表示</span><br><span class="line">字符分为很多类，比如数字、字母、标点等等。</span><br><span class="line">假如你现在要求一个位置&quot;只能出现一个数字&quot;,那么这个位置上的字符只能是0、1、2...9这10个数之一。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><code>正则</code></th>
<th><code>待匹配字符</code></th>
<th><code>匹配结果</code></th>
<th><code>说明</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>[0123456789]</code></td>
<td><code>8</code></td>
<td><code>True</code></td>
<td><code>在一个字符组里枚举合法的所有字符，字符组里的任意一个字符和&quot;待匹配字符&quot;相同都视为可以匹配</code></td>
</tr>
<tr>
<td><code>[0123456789]</code></td>
<td><code>a</code></td>
<td><code>False</code></td>
<td><code>由于字符组中没有&quot;a&quot;字符，所以不能匹配</code></td>
</tr>
<tr>
<td><code>[0-9]</code></td>
<td><code>7</code></td>
<td><code>True</code></td>
<td><code>也可以用-表示范围,[0-9]就和[0123456789]是一个意思</code></td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td><code>s</code></td>
<td><code>True</code></td>
<td><code>同样的如果要匹配所有的小写字母，直接用[a-z]就可以表示</code></td>
</tr>
<tr>
<td><code>[A-Z]</code></td>
<td><code>B</code></td>
<td><code>True</code></td>
<td><code>[A-Z]就表示所有的大写字母</code></td>
</tr>
<tr>
<td><code>[0-9a-fA-F]</code></td>
<td><code>e</code></td>
<td><code>True</code></td>
<td><code>可以匹配数字，大小写形式的a～f，用来验证十六进制字符</code></td>
</tr>
</tbody></table>
<p><strong><em>字符：</em></strong></p>
<table>
<thead>
<tr>
<th><code>元字符</code></th>
<th><code>匹配内容</code></th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词的结尾</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结尾</td>
</tr>
<tr>
<td>\W</td>
<td><code>匹配非字母或数字或下划线</code></td>
</tr>
<tr>
<td>\D</td>
<td><code>匹配非数字</code></td>
</tr>
<tr>
<td>\S</td>
<td><code>匹配非空白符</code></td>
</tr>
<tr>
<td>a|b</td>
<td><code>匹配字符a或字符b</code></td>
</tr>
<tr>
<td>()</td>
<td><code>匹配括号内的表达式，也表示一个组</code></td>
</tr>
<tr>
<td>[…]</td>
<td><code>匹配字符组中的字符</code></td>
</tr>
<tr>
<td>[^…]</td>
<td><code>匹配除了字符组中字符的所有字符</code></td>
</tr>
</tbody></table>
<p><strong><em>量词：</em></strong></p>
<table>
<thead>
<tr>
<th><code>量词</code></th>
<th><code>用法说明</code></th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<h5 id="1、"><a href="#1、" class="headerlink" title="1、. ^ $"></a>1、. ^ $</h5><table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>海.</td>
<td>海燕海娇海东</td>
<td>海燕海娇海东</td>
<td>匹配所有”海.”的字符</td>
</tr>
<tr>
<td>^海.</td>
<td>海燕海娇海东</td>
<td>海燕</td>
<td>只从开头匹配”海.”</td>
</tr>
<tr>
<td>海.$</td>
<td>海燕海娇海东</td>
<td>海东</td>
<td>只匹配结尾的”海.$”</td>
</tr>
</tbody></table>
<h5 id="2、"><a href="#2、" class="headerlink" title="2、* + ? { }"></a>2、* + ? { }</h5><table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>李.?</td>
<td>李杰和李莲英和李二棍子</td>
<td>李杰 李莲 李二</td>
<td><code>?表示重复零次或一次，即只匹配&quot;李&quot;后面一个任意字符</code></td>
</tr>
<tr>
<td>李.*</td>
<td>李杰和李莲英和李二棍子</td>
<td>李杰和李莲英和李二棍子</td>
<td><code>*表示重复零次或多次，即匹配&quot;李&quot;后面0或多个任意字符</code></td>
</tr>
<tr>
<td>李.+</td>
<td>李杰和李莲英和李二棍子</td>
<td>李杰和李莲英和李二棍子</td>
<td><code>+表示重复一次或多次，即只匹配&quot;李&quot;后面1个或多个任意字符</code></td>
</tr>
<tr>
<td>李.{1,2}</td>
<td>李杰和李莲英和李二棍子</td>
<td>李杰和 李莲英 李二棍</td>
<td><code>{1,2}匹配1到2次任意字符</code></td>
</tr>
</tbody></table>
<p><strong><em>注意：</em></strong></p>
<p>前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配</p>
<table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>李.*?</td>
<td>李杰和李莲英和李二棍子</td>
<td>李 李 李</td>
<td>惰性匹配</td>
</tr>
</tbody></table>
<h5 id="3、字符集［］［-］"><a href="#3、字符集［］［-］" class="headerlink" title="3、字符集［］［^］"></a>3、字符集［］［^］</h5><table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>李[杰莲英二棍子]*</td>
<td>李杰和李莲英和李二棍子</td>
<td>李杰 李莲英 李二棍子</td>
<td><code>表示匹配&quot;李&quot;字后面[杰莲英二棍子]的字符任意次</code></td>
</tr>
<tr>
<td>李[^和]*</td>
<td>李杰和李莲英和李二棍子</td>
<td>李杰 李莲英 李二棍子</td>
<td><code>表示匹配一个不是&quot;和&quot;的字符任意次</code></td>
</tr>
<tr>
<td>[\d]</td>
<td>456bdha3</td>
<td>4 5 6 3</td>
<td><code>表示匹配任意一个数字，匹配到4个结果</code></td>
</tr>
<tr>
<td>[\d]+</td>
<td>456bdha3</td>
<td>456 3</td>
<td><code>表示匹配任意个数字，匹配到2个结果</code></td>
</tr>
</tbody></table>
<h5 id="4、分组-与-或-｜［-］"><a href="#4、分组-与-或-｜［-］" class="headerlink" title="4、分组 ()与 或 ｜［^］"></a>4、分组 ()与 或 ｜［^］</h5><p>身份证号码是一个长度为15或18个字符的字符串，如果是15位则全部由数字组成，首位不能为0；如果是18位，则前17位全部是数字，末位可能是数字或x，下面我们尝试用正则来表示：</p>
<table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^[1-9]\d{13,16}[0-9x]$</td>
<td>110101198001017032</td>
<td>110101198001017032</td>
<td>表示可以匹配一个正确的身份证号</td>
</tr>
<tr>
<td>^[1-9]\d{13,16}[0-9x]$</td>
<td>1101011980010170</td>
<td>1101011980010170</td>
<td><code>表示也可以匹配这串数字，但这并不是一个正确的身份证号码，它是一个16位的数字</code></td>
</tr>
<tr>
<td>^[1-9]\d{14}(\d{2}[0-9x])?$</td>
<td>1101011980010170</td>
<td>False</td>
<td><code>现在不会匹配错误的身份证号了()表示分组，将\d{2}[0-9x]分成一组，就可以整体约束他们出现的次数为0-1次</code></td>
</tr>
<tr>
<td>^([1-9]\d{16}[0-9x]|[1-9]\d{14})$</td>
<td>110105199812067023</td>
<td>110105199812067023</td>
<td><code>表示先匹配[1-9]\d{16}[0-9x]如果没有匹配上就匹配[1-9]\d{14}</code></td>
</tr>
</tbody></table>
<h5 id="5、转义符"><a href="#5、转义符" class="headerlink" title="5、转义符 \"></a>5、转义符 \</h5><p>在正则表达式中，有很多有特殊意义的是元字符，比如\n和\s等，如果要在正则中匹配正常的”\n”而不是”换行符”就需要对”\“进行转义，变成’\\‘。</p>
<p>在python中，无论是正则表达式，还是待匹配的内容，都是以字符串的形式出现的，在字符串中\也有特殊的含义，本身还需要转义。所以如果匹配一次”\n”,字符串中要写成’\\n’，那么正则里就要写成”\\\\n”,这样就太麻烦了。这个时候我们就用到了r’\n’这个概念，此时的正则是r’\\n’就可以了。</p>
<table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>\n</td>
<td>False</td>
<td><code>因为在正则表达式中\是有特殊意义的字符，所以要匹配\n本身，用表达式\n无法匹配</code></td>
</tr>
<tr>
<td>\\n</td>
<td>\n</td>
<td>True</td>
<td><code>转义\之后变成\\，即可匹配</code></td>
</tr>
<tr>
<td>“\\\\n”</td>
<td>‘\\n’</td>
<td>True</td>
<td><code>如果在python中，字符串中的&#39;\&#39;也需要转义，所以每一个字符串&#39;\&#39;又需要转义一次</code></td>
</tr>
<tr>
<td>r’\\n’</td>
<td>r’\n’</td>
<td>True</td>
<td><code>在字符串之前加r，让整个字符串不转义</code></td>
</tr>
</tbody></table>
<h5 id="6、贪婪匹配"><a href="#6、贪婪匹配" class="headerlink" title="6、贪婪匹配"></a>6、贪婪匹配</h5><p>贪婪匹配：在满足匹配时，匹配尽可能长的字符串，默认情况下，采用贪婪匹配</p>
<table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;.*&gt;</td>
<td><script>...<script></td>
<td><script>...<script></td>
<td><code>默认为贪婪匹配模式，会匹配尽量长的字符串</code></td>
</tr>
<tr>
<td><.*?></td>
<td>r'\d'</td>
<td><script> <script></td>
<td><code>加上？为将贪婪匹配模式转为非贪婪匹配模式，会匹配尽量短的字符串</code></td>
</tr>
</tbody></table>
<p>几个常用的非贪婪匹配Pattern：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*? 重复任意次，但尽可能少重复</span><br><span class="line">+? 重复1次或更多次，但尽可能少重复</span><br><span class="line">?? 重复0次或1次，但尽可能少重复</span><br><span class="line">&#123;n,m&#125;? 重复n到m次，但尽可能少重复</span><br><span class="line">&#123;n,&#125;? 重复n次以上，但尽可能少重复</span><br></pre></td></tr></table></figure>

<p>. * ? 的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">. 是任意字符</span><br><span class="line">* 是取 0 至 无限长度</span><br><span class="line">? 是非贪婪模式。</span><br><span class="line">  何在一起就是 取尽量少的任意字符，一般不会这么单独写，他大多用在：</span><br><span class="line">  .*?x</span><br><span class="line"></span><br><span class="line">就是取前面任意长度的字符，直到一个x出现</span><br></pre></td></tr></table></figure>

<h4 id="（2）re模块下的常用方法"><a href="#（2）re模块下的常用方法" class="headerlink" title="（2）re模块下的常用方法"></a>（2）re模块下的常用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.findall(<span class="string">'a'</span>, <span class="string">'eva egon yuan'</span>)  <span class="comment"># 返回所有满足匹配条件的结果,放在列表里</span></span><br><span class="line">print(ret) <span class="comment">#结果 : ['a', 'a']</span></span><br><span class="line"></span><br><span class="line">ret = re.search(<span class="string">'a'</span>, <span class="string">'eva egon yuan'</span>).group()</span><br><span class="line">print(ret) <span class="comment">#结果 : 'a'</span></span><br><span class="line"><span class="comment"># 函数会在字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以</span></span><br><span class="line"><span class="comment"># 通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。</span></span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">'a'</span>, <span class="string">'abc'</span>).group()  <span class="comment"># 同search,不过尽在字符串开始处进行匹配</span></span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment">#结果 : 'a'</span></span><br><span class="line"></span><br><span class="line">ret = re.split(<span class="string">'[ab]'</span>, <span class="string">'abcd'</span>)  <span class="comment"># 先按'a'分割得到''和'bcd',在对''和'bcd'分别按'b'分割</span></span><br><span class="line">print(ret)  <span class="comment"># ['', '', 'cd']</span></span><br><span class="line"></span><br><span class="line">ret = re.sub(<span class="string">'\d'</span>, <span class="string">'H'</span>, <span class="string">'eva3egon4yuan4'</span>, <span class="number">1</span>)<span class="comment">#将数字替换成'H'，参数1表示只替换1个</span></span><br><span class="line">print(ret) <span class="comment">#evaHegon4yuan4</span></span><br><span class="line"></span><br><span class="line">ret = re.subn(<span class="string">'\d'</span>, <span class="string">'H'</span>, <span class="string">'eva3egon4yuan4'</span>)<span class="comment">#将数字替换成'H'，返回元组(替换的结果,替换了多少次)</span></span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">obj = re.compile(<span class="string">'\d&#123;3&#125;'</span>)  <span class="comment">#将正则表达式编译成为一个 正则表达式对象，规则要匹配的是3个数字</span></span><br><span class="line">ret = obj.search(<span class="string">'abc123eeee'</span>) <span class="comment">#正则表达式对象调用search，参数为待匹配的字符串</span></span><br><span class="line">print(ret.group())  <span class="comment">#结果 ： 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">ret = re.finditer(<span class="string">'\d'</span>, <span class="string">'ds3sy4784a'</span>)   <span class="comment">#finditer返回一个存放匹配结果的迭代器</span></span><br><span class="line">print(ret)  <span class="comment"># &lt;callable_iterator object at 0x10195f940&gt;</span></span><br><span class="line">print(next(ret).group())  <span class="comment">#查看第一个结果</span></span><br><span class="line">print(next(ret).group())  <span class="comment">#查看第二个结果</span></span><br><span class="line">print([i.group() <span class="keyword">for</span> i <span class="keyword">in</span> ret])  <span class="comment">#查看剩余的左右结果</span></span><br></pre></td></tr></table></figure>

<p><strong><em>注意：</em></strong></p>
<ol>
<li><p>findall的优先级查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">ret = re.findall(&apos;www.(baidu|oldboy).com&apos;, &apos;www.oldboy.com&apos;)</span><br><span class="line">print(ret)  # [&apos;oldboy&apos;]     这是因为findall会优先把匹配结果组里内容返回,如果想要匹配结果,取消权限即可</span><br><span class="line"></span><br><span class="line">ret = re.findall(&apos;www.(?:baidu|oldboy).com&apos;, &apos;www.oldboy.com&apos;)</span><br><span class="line">print(ret)  # [&apos;www.oldboy.com&apos;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>split的优先级查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ret=re.split(&quot;\d+&quot;,&quot;eva3egon4yuan&quot;)</span><br><span class="line">print(ret) #结果 ： [&apos;eva&apos;, &apos;egon&apos;, &apos;yuan&apos;]</span><br><span class="line"></span><br><span class="line">ret=re.split(&quot;(\d+)&quot;,&quot;eva3egon4yuan&quot;)</span><br><span class="line">print(ret) #结果 ： [&apos;eva&apos;, &apos;3&apos;, &apos;egon&apos;, &apos;4&apos;, &apos;yuan&apos;]</span><br><span class="line"></span><br><span class="line">#在匹配部分加上（）之后所切出的结果是不同的，</span><br><span class="line">#没有（）的没有保留所匹配的项，但是有（）的却能够保留了匹配的项，</span><br><span class="line">#这个在某些需要保留匹配部分的使用过程是非常重要的。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="（3）综合练习与扩展"><a href="#（3）综合练习与扩展" class="headerlink" title="（3）综合练习与扩展"></a>（3）综合练习与扩展</h4><h5 id="1、匹配标签"><a href="#1、匹配标签" class="headerlink" title="1、匹配标签"></a>1、匹配标签</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = re.search(<span class="string">"&lt;(?P&lt;tag_name&gt;\w+)&gt;\w+&lt;/(?P=tag_name)&gt;"</span>,<span class="string">"&lt;h1&gt;hello&lt;/h1&gt;"</span>)</span><br><span class="line"><span class="comment">#还可以在分组中利用?&lt;name&gt;的形式给分组起名字</span></span><br><span class="line"><span class="comment">#获取的匹配结果可以直接用group('名字')拿到对应的值</span></span><br><span class="line">print(ret.group(<span class="string">'tag_name'</span>))  <span class="comment">#结果 ：h1</span></span><br><span class="line">print(ret.group())  <span class="comment">#结果 ：&lt;h1&gt;hello&lt;/h1&gt;</span></span><br><span class="line"></span><br><span class="line">ret = re.search(<span class="string">r"&lt;(\w+)&gt;\w+&lt;/\1&gt;"</span>,<span class="string">"&lt;h1&gt;hello&lt;/h1&gt;"</span>)</span><br><span class="line"><span class="comment">#如果不给组起名字，也可以用\序号来找到对应的组，表示要找的内容和前面的组内容一致</span></span><br><span class="line"><span class="comment">#获取的匹配结果可以直接用group(序号)拿到对应的值</span></span><br><span class="line">print(ret.group(<span class="number">1</span>))</span><br><span class="line">print(ret.group())  <span class="comment">#结果 ：&lt;h1&gt;hello&lt;/h1&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2、匹配整数"><a href="#2、匹配整数" class="headerlink" title="2、匹配整数"></a>2、匹配整数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret=re.findall(<span class="string">r"\d+"</span>,<span class="string">"1-2*(60+(-40.35/5)-(-4*3))"</span>)</span><br><span class="line">print(ret) <span class="comment">#['1', '2', '60', '40', '35', '5', '4', '3']</span></span><br><span class="line">ret=re.findall(<span class="string">r"-?\d+\.\d*|(-?\d+)"</span>,<span class="string">"1-2*(60+(-40.35/5)-(-4*3))"</span>)</span><br><span class="line">print(ret) <span class="comment">#['1', '-2', '60', '', '5', '-4', '3']</span></span><br><span class="line">ret.remove(<span class="string">""</span>)</span><br><span class="line">print(ret) <span class="comment">#['1', '-2', '60', '5', '-4', '3']</span></span><br></pre></td></tr></table></figure>

<h5 id="3、数字匹配"><a href="#3、数字匹配" class="headerlink" title="3、数字匹配"></a>3、数字匹配</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、 匹配一段文本中的每行的邮箱</span><br><span class="line">      http://blog.csdn.net/make164492212/article/details/51656638</span><br><span class="line"></span><br><span class="line">2、 匹配一段文本中的每行的时间字符串，比如：‘1990-07-12’；</span><br><span class="line"></span><br><span class="line">   分别取出1年的12个月（^(0?[1-9]|1[0-2])$）、</span><br><span class="line">   一个月的31天：^((0?[1-9])|((1|2)[0-9])|30|31)$</span><br><span class="line"></span><br><span class="line">3、 匹配qq号。(腾讯QQ号从10000开始)  ［1,9］[0,9]&#123;4,&#125;</span><br><span class="line"></span><br><span class="line">4、 匹配一个浮点数。       ^(-?\d+)(\.\d+)?$   或者  -?\d+\.?\d*</span><br><span class="line"></span><br><span class="line">5、 匹配汉字。             ^[\u4e00-\u9fa5]&#123;0,&#125;$ </span><br><span class="line"></span><br><span class="line">6、 匹配出所有整数</span><br></pre></td></tr></table></figure>

<h5 id="4、爬虫练习"><a href="#4、爬虫练习" class="headerlink" title="4、爬虫练习"></a>4、爬虫练习</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPage</span><span class="params">(url)</span>:</span></span><br><span class="line"></span><br><span class="line">    response=requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsePage</span><span class="params">(s)</span>:</span></span><br><span class="line">    </span><br><span class="line">    com=re.compile(<span class="string">'&lt;div class="item"&gt;.*?&lt;div class="pic"&gt;.*?&lt;em .*?&gt;(?P&lt;id&gt;\d+).*?&lt;span class="title"&gt;(?P&lt;title&gt;.*?)&lt;/span&gt;'</span></span><br><span class="line">                   <span class="string">'.*?&lt;span class="rating_num" .*?&gt;(?P&lt;rating_num&gt;.*?)&lt;/span&gt;.*?&lt;span&gt;(?P&lt;comment_num&gt;.*?)评价&lt;/span&gt;'</span>,re.S)</span><br><span class="line"></span><br><span class="line">    ret=com.finditer(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">"id"</span>:i.group(<span class="string">"id"</span>),</span><br><span class="line">            <span class="string">"title"</span>:i.group(<span class="string">"title"</span>),</span><br><span class="line">            <span class="string">"rating_num"</span>:i.group(<span class="string">"rating_num"</span>),</span><br><span class="line">            <span class="string">"comment_num"</span>:i.group(<span class="string">"comment_num"</span>),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(num)</span>:</span></span><br><span class="line"></span><br><span class="line">    url=<span class="string">'https://movie.douban.com/top250?start=%s&amp;filter='</span>%num</span><br><span class="line">    response_html=getPage(url)</span><br><span class="line">    ret=parsePage(response_html)</span><br><span class="line">    print(ret)</span><br><span class="line">    f=open(<span class="string">"move_info7"</span>,<span class="string">"a"</span>,encoding=<span class="string">"utf8"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> ret:</span><br><span class="line">        print(obj)</span><br><span class="line">        data=json.dumps(obj,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        f.write(data+<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        main(count)</span><br><span class="line">        count+=<span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>简化版：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPage</span><span class="params">(url)</span>:</span></span><br><span class="line">    response = urlopen(url)</span><br><span class="line">    <span class="keyword">return</span> response.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsePage</span><span class="params">(s)</span>:</span></span><br><span class="line">    com = re.compile(</span><br><span class="line">        <span class="string">'&lt;div class="item"&gt;.*?&lt;div class="pic"&gt;.*?&lt;em .*?&gt;(?P&lt;id&gt;\d+).*?&lt;span class="title"&gt;(?P&lt;title&gt;.*?)&lt;/span&gt;'</span></span><br><span class="line">        <span class="string">'.*?&lt;span class="rating_num" .*?&gt;(?P&lt;rating_num&gt;.*?)&lt;/span&gt;.*?&lt;span&gt;(?P&lt;comment_num&gt;.*?)评价&lt;/span&gt;'</span>, re.S)</span><br><span class="line"></span><br><span class="line">    ret = com.finditer(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">"id"</span>: i.group(<span class="string">"id"</span>),</span><br><span class="line">            <span class="string">"title"</span>: i.group(<span class="string">"title"</span>),</span><br><span class="line">            <span class="string">"rating_num"</span>: i.group(<span class="string">"rating_num"</span>),</span><br><span class="line">            <span class="string">"comment_num"</span>: i.group(<span class="string">"comment_num"</span>),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(num)</span>:</span></span><br><span class="line">    url = <span class="string">'https://movie.douban.com/top250?start=%s&amp;filter='</span> % num</span><br><span class="line">    response_html = getPage(url)</span><br><span class="line">    ret = parsePage(response_html)</span><br><span class="line">    print(ret)</span><br><span class="line">    f = open(<span class="string">"move_info7"</span>, <span class="string">"a"</span>, encoding=<span class="string">"utf8"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> ret:</span><br><span class="line">        print(obj)</span><br><span class="line">        data = str(obj)</span><br><span class="line">        f.write(data + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    main(count)</span><br><span class="line">    count += <span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>flags：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flags有很多可选值：</span><br><span class="line"></span><br><span class="line">re.I(IGNORECASE)忽略大小写，括号内是完整的写法</span><br><span class="line">re.M(MULTILINE)多行模式，改变^和$的行为</span><br><span class="line">re.S(DOTALL)点可以匹配任意字符，包括换行符</span><br><span class="line">re.L(LOCALE)做本地化识别的匹配，表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境，不推荐使用</span><br><span class="line">re.U(UNICODE) 使用\w \W \s \S \d \D使用取决于unicode定义的字符属性。在python3中默认使用该flag</span><br><span class="line">re.X(VERBOSE)冗长模式，该模式下pattern字符串可以是多行的，忽略空白字符，并可以添加注释</span><br></pre></td></tr></table></figure>

</script></td></tr></tbody></table>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/23/数据结构笔记/第一章-绪论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/23/数据结构笔记/第一章-绪论/" itemprop="url">第一章 绪论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-23T16:21:57+08:00">
                2019-07-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="（一）-什么是数据结构"><a href="#（一）-什么是数据结构" class="headerlink" title="（一） 什么是数据结构"></a>（一） 什么是数据结构</h2><p>一、计算机解决一个具体的问题时，大致需要经过下列几个步骤：</p>
<ul>
<li>抽象出数学模型</li>
<li>设计解决模型的算法</li>
<li>编出程序</li>
<li>测试、调整，得到最终答案</li>
</ul>
<p><strong>寻求数学模型的实质：</strong></p>
<p>分析问题，从中提取操作的对象，并找出这些操作对象之间含有的关系。然后用数学的语言加以描述。</p>
<p>二、数据结构</p>
<p>数据结构是一门研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作等的学科。</p>
<p>三、程序设计的实质</p>
<p>对确定问题选择一种好的结构，加上设计一种好的算法。</p>
<h2 id="（二）基本概念和术语"><a href="#（二）基本概念和术语" class="headerlink" title="（二）基本概念和术语"></a>（二）基本概念和术语</h2><p><strong>1、数据</strong></p>
<p>数据是信息的载体，是描述客观事物属性的数。字符以及所有能够输入到计算机中并被计算机程序识别和处理的符号的集合。</p>
<p><strong>2、数据元素</strong></p>
<p>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干个数据项组成，数据项是构成数据元素的不可分割的最小单位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。</span><br></pre></td></tr></table></figure>

<p><strong>3、数据对象</strong></p>
<p>数据对象是具有相同性质的数据元素的集合，是数据的一个子集。</p>
<p>例如：整数数据对象是集合$$N = {0,  \pm 1,  \pm 2, …} $$。</p>
<p><strong>4、数据类型</strong></p>
<p>数据类型是一个值的集合和定义在此集合上一组操作的总称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"></span><br><span class="line">C语言中的整形变量，其值集为某个区间上的整数（区间大小依赖于不同的机器），定义在其上的操作为加、减、乘、除和取模等算数运算。</span><br></pre></td></tr></table></figure>

<ul>
<li>原子类型:其值不可再分的数据类型。<ul>
<li>如：C语言中的基本类型、指针类型和空类型。</li>
</ul>
</li>
<li>结构类型:其值可以再分解为若干成分(分量)的数据类型。<ul>
<li>如：数组</li>
</ul>
</li>
<li>抽象数据类型:抽象数据组织和与之相关的操作。</li>
</ul>
<p><strong>5、抽象数据类型</strong></p>
<p>抽象数据类型(ADT)是指一个数学模型以及定义在该模型上的一组操作。</p>
<p>抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。</p>
<p>通常用(数据对象、数据关系、基本操作集)这样的三元组来表示抽象数据类型。</p>
<p><strong>6.数据结构</strong><br>在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构(Structure)。</p>
<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三方面的内容:<strong>逻辑结构、存储结构和数据的运算</strong>。<br>数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</p>
<p><strong>逻辑结构</strong></p>
<p>逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。</p>
<p>数据的逻辑结构分为线性结构和非线性结构</p>
<p>![逻辑结构](/Users/hhh/blog/source/_posts/数据结构笔记/图片/第一章 绪论/逻辑结构.png)</p>
<ul>
<li><p>集合 </p>
<ul>
<li>结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系。 类似于数学上的集合</li>
</ul>
</li>
<li><p>线性结构 </p>
<ul>
<li>结构中的数据元素之间只存在一对一的关系。比如排队 </li>
</ul>
</li>
<li><p>树形结构</p>
<ul>
<li>结构中的数据元素之间存在一对多的关系。比如家族族谱 </li>
</ul>
</li>
<li><p>图状结构或网状结构 </p>
<ul>
<li>结构中的数据元素之间存在多对多的关系。 比如地图 </li>
</ul>
</li>
</ul>
<p>例如：</p>
<p>![逻辑结构2](./图片/第一章 绪论/逻辑结构2.png)</p>
<p><strong>物理结构</strong></p>
<p>存储结构是指数据结构在计算机中的表示(又称映像)，也称物理结构。它包括数据元素的表示和关系的表示。</p>
<p>数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。</p>
<p>数据的存储结构主要有:<strong>顺序存储、链式存储、索引存储和散列存储</strong>。</p>
<p>![物理结构1](./图片/第一章 绪论/物理结构1.png)</p>
<ul>
<li><p>顺序存储:</p>
<ul>
<li>存储的物理位置相邻(p.s. 物理位置即信息在计算机中的位置） </li>
</ul>
</li>
<li><p>链接存储:</p>
<ul>
<li>存储的物理位置未必相邻，通过 记录相邻元素的物理位置来找到相邻元素</li>
</ul>
</li>
<li><p>索引存储:</p>
<ul>
<li>类似于目录，以后可以联系操作系统的文件系统章节来理解</li>
</ul>
</li>
<li><p>散列存储:</p>
<ul>
<li>通过关键字直接计算出元素的物理地址(以后详解)</li>
</ul>
</li>
</ul>
<p>![物理结构2](./图片/第一章 绪论/物理结构2.png)</p>
<p><strong>数据的运算</strong></p>
<p>数据的运算包括运算的定义和实现。</p>
<ul>
<li><p>运算的定义是针对逻辑结构。</p>
</li>
<li><p>运算的实现是针对物理结构。 </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">以人为例，假设有一个运算是计算人的颜值。</span><br><span class="line">颜值=五官的漂亮程度之和(运算的定义)  针对逻辑结构</span><br><span class="line">通过读取计算机中每个人 五官的信息，然后相加得到颜值。(运算的实现)   针对物理结构</span><br></pre></td></tr></table></figure>

<h2 id="（三）算法和算法分析"><a href="#（三）算法和算法分析" class="headerlink" title="（三）算法和算法分析"></a>（三）算法和算法分析</h2><h3 id="一、算法"><a href="#一、算法" class="headerlink" title="一、算法"></a>一、算法</h3><p><strong>算法是对问题求解步骤的描述，通过有限序列的指令来实现。</strong></p>
<p>五大特征 </p>
<ol>
<li><strong>有穷性</strong>:  有限步之后结束</li>
<li><strong>确定性</strong>:  不存在二义性，即没有歧义 </li>
<li><strong>可行性</strong>:  比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。 </li>
<li><strong>输入</strong>:  能被计算机处理的各种类型数据，如数字，音频，图像等等。 </li>
<li><strong>输出</strong>:  一至多个程序输出结果。 </li>
</ol>
<p>![算法特性](./图片/第一章 绪论/算法特性.png)</p>
<h3 id="二、算法设计的要求"><a href="#二、算法设计的要求" class="headerlink" title="二、算法设计的要求"></a>二、算法设计的要求</h3><ol>
<li><strong>正确性</strong></li>
<li><strong>可读性</strong></li>
<li><strong>健壮性</strong></li>
<li><strong>效率与低存储量需求</strong></li>
</ol>
<h3 id="三、算法效率的度量"><a href="#三、算法效率的度量" class="headerlink" title="三、算法效率的度量"></a>三、算法效率的度量</h3><p>通过时间复杂度和空间复杂度。</p>
<h4 id="1、时间复杂度"><a href="#1、时间复杂度" class="headerlink" title="1、时间复杂度"></a>1、时间复杂度</h4><p>定义:<br>时间复杂度:</p>
<ul>
<li>它用来衡量算法随着问题规模增大，算法执行时间<strong>增长的快慢</strong>;</li>
<li>是问题规模的函数:T(n)是时间规模函数 时间复杂度主要分析T(n)的<strong>数量级</strong>；</li>
<li>T(n)=O(f(n)) f(n)是算法中基本运算的频度 一般我们考虑<strong>最坏情况</strong>下的时间复杂度</li>
</ul>
<p>计算方法：</p>
<p>取算法时间增长最快的那个函数项，忽略它的系数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：有一次、二次、三次的函数项，应选择三次方的函数项，且令其系数为1.</span><br></pre></td></tr></table></figure>

<p>![时间复杂度1](./图片/第一章 绪论/时间复杂度1.png)</p>
<p>从图中，可以看到:</p>
<p>随着问题规模的增大(横坐标)，所需时间的增长率(斜率)差别很大。</p>
<p>而且，这种差距随着问题规模的增大而显著地增大。</p>
<p><strong><em>我们关心的就是算法的这个增长规模速度。</em></strong></p>
<p>常用的时间复杂度大小关系:</p>
<p>Ο(1) &lt; Ο(log2n) &lt; Ο(n) &lt; Ο(nlog2n) &lt; Ο(n2) &lt; Ο(n3) &lt; Ο(2n)  </p>
<p>PS: log2n更多写成logn</p>
<p>从左至右，时间性能依次降低。</p>
<h4 id="2、时间复杂度的计算"><a href="#2、时间复杂度的计算" class="headerlink" title="2、时间复杂度的计算"></a>2、时间复杂度的计算</h4><p>​    <strong>（1）原始算法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">	sum=sum+i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>int sum=0;        执行1次<br>int i = 0      执行1次，   i&lt;=n     执行n+2次，   i++     执行n+1次<br>sum=sum+i;     执行n+1次</p>
<p><strong>时间分析:</strong></p>
<p>该算法执行了3n+6个语句。 假设每个语句执行时间一致，均为常数t。则总时间T =(3n+6)*t。 随着问题规模n的增大，总时间的增长率与n的增长率一致，所以复杂度为O(n)。 </p>
<p><strong>结论:</strong><br> • 复杂度是关于增长率的，所以可以直接忽视常数项。<br> • 一般可以直接关注循环段基本操作语句(示例中的sum=sum+i)的执行次数。 </p>
<p><strong>（2）单个循环体</strong></p>
<p>直接关注循环体的执行次数，设为k。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	sum=sum+i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i 为1 执行了1次</p>
<p>i 为2 执行了2</p>
<p> …..</p>
<p>i为n 执行了n次 此时仍然满足条件 </p>
<p>i=n+1时，跳出循环 </p>
<p>所以循环体执行次数:  k=n+1 </p>
<p>故时间复杂度为O(n). </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i=<span class="number">2</span>*i)&#123;</span><br><span class="line">	sum=sum+i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i 取值:1, 2, 4, 8 … </p>
<p>满足条件:  $$2^{k}  \leq n $$</p>
<p>$$K &gt;  \log_{2}{n} $$ 时， 跳出循环 </p>
<p>所以循环体执行次数:  $$ [ \log_{2}{n} ]$$</p>
<p>故时间复杂度为O(logn). </p>
<p><strong>（3）多个循环体</strong></p>
<p>两个运算规则:乘法规则，加法规则。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">	x++;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">	<span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">		x++;</span><br></pre></td></tr></table></figure>

<p>两个循环体是独立的，采用加法规则：</p>
<p>T(n) = T1(n) + T2(n) = max{ T1(n) , T2(n) }</p>
<p>​        = O(n^2)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n; j=<span class="number">2</span>*j)&#123;</span><br><span class="line">		sum=sum+j; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个循环体是嵌套的，采用乘法规则：</p>
<p>T(n) = T1(n) * T2(n)</p>
<p>​        = O(nlogn)</p>
<h4 id="3、空间复杂度"><a href="#3、空间复杂度" class="headerlink" title="3、空间复杂度"></a>3、空间复杂度</h4><p>空间复杂度:</p>
<ul>
<li>它用来衡量算法随着问题规模增大，算法所需空间的快慢;</li>
<li>是问题规模的函数:S(n)=O(g(n)) ;   算法所需空间的增长率和g(n)的增长率相同。</li>
</ul>
<h4 id="4、空间复杂度的计算"><a href="#4、空间复杂度的计算" class="headerlink" title="4、空间复杂度的计算"></a>4、空间复杂度的计算</h4><p>空间复杂度S(n)指算法运行过程中所使用的辅助空间的大小。</p>
<p>记为: </p>
<p>​                                S(n)=O(f(n)) </p>
<ul>
<li>辅助空间:除了存储算法本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。 </li>
<li>算法原地工作是指算法所需的辅助空间是常量，即O(1)。<ul>
<li>固定大小，不随代码的复杂度改变而改变。 </li>
</ul>
</li>
<li>考研中出现O(1)，O(n)较多。 </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/23/python全栈/第01部分：基础+模块+面向对象+网络编程/网络编程/网络编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/23/python全栈/第01部分：基础+模块+面向对象+网络编程/网络编程/网络编程/" itemprop="url">网络编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-23T09:03:20+08:00">
                2019-07-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-01部分-网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -01部分 -网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="（一）楔子"><a href="#（一）楔子" class="headerlink" title="（一）楔子"></a>（一）楔子</h2><p>​       你现在已经学会了写python代码，假如你写了两个python文件a.py和b.py，分别去运行，你就会发现，这两个python的文件分别运行的很好。但是如果这两个程序之间想要传递一个数据，你要怎么做呢？</p>
<p>​       这个问题以你现在的知识就可以解决了，我们可以创建一个文件，把a.py想要传递的内容写到文件中，然后b.py从这个文件中读取内容就可以了。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1.png" alt></p>
<p>​        但是当你的a.py和b.py分别在不同电脑上的时候，你要怎么办呢？</p>
<p>​      类似的机制有计算机网盘，qq等等。我们可以在我们的电脑上和别人聊天，可以在自己的电脑上向网盘中上传、下载内容。这些都是两个程序在通信。</p>
<h2 id="（二）软件开发的架构"><a href="#（二）软件开发的架构" class="headerlink" title="（二）软件开发的架构"></a>（二）软件开发的架构</h2><p>我们了解的涉及到两个程序之间通讯的应用大致可以分为两种：</p>
<p>第一种是应用类：qq、微信、网盘、优酷这一类是属于需要安装的桌面应用</p>
<p>第二种是web类：比如百度、知乎、博客园等使用浏览器访问就可以直接使用的应用</p>
<p>这些应用的本质其实都是两个程序之间的通讯。而这两个分类又对应了两个软件开发的架构～</p>
<h3 id="一、C-S架构"><a href="#一、C-S架构" class="headerlink" title="一、C/S架构"></a>一、C/S架构</h3><p>​      C/S即：<strong>Client与Server</strong> ，中文意思：客户端与服务器端架构，这种架构也是从用户层面（也可以是物理层面）来划分的。</p>
<p>​        服务端是要一直运行，等待服务别人的</p>
<p>​        客户端是当人们有需求时，才请求服务</p>
<p>​       这里的客户端一般泛指客户端应用程序EXE，程序需要先安装后，才能运行在用户的电脑上，对用户的电脑操作系统环境依赖较大。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2.png" alt></p>
<h3 id="二、B-S架构"><a href="#二、B-S架构" class="headerlink" title="二、B/S架构"></a>二、B/S架构</h3><p>​        B/S即：<strong>Browser与Server</strong>,中文意思：浏览器端与服务器端架构，这种架构是从用户层面来划分的。</p>
<p>​        Browser浏览器，其实也是一种Client客户端，只是这个客户端不需要大家去安装什么应用程序，只需在浏览器上通过HTTP请求服务器端相关的资源（网页资源），客户端Browser浏览器就能进行增删改查。</p>
<p>​        <strong>B/S架构其实也是一种C/S架构。</strong></p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/3.png" alt></p>
<h2 id="（三）网络基础"><a href="#（三）网络基础" class="headerlink" title="（三）网络基础"></a>（三）网络基础</h2><h3 id="一、一个程序如何在网络上找到另一个程序？"><a href="#一、一个程序如何在网络上找到另一个程序？" class="headerlink" title="一、一个程序如何在网络上找到另一个程序？"></a>一、一个程序如何在网络上找到另一个程序？</h3><p>​        首先，程序必须要启动，其次，必须有这台机器的地址，我们都知道我们人的地址大概就是国家\省\市\区\街道\楼\门牌号这样字。那么每一台联网的机器在网络上也有自己的地址，它的地址是怎么表示的呢？</p>
<p>​       就是使用一串数字来表示的，例如：100.4.5.6</p>
<p><strong>1、什么是ip地址</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP地址是指互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</span><br><span class="line"></span><br><span class="line">IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。IP地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。例：点分十进IP地址（100.4.5.6），实际上是32位二进制数（01100100.00000100.00000101.00000110）。</span><br></pre></td></tr></table></figure>

<p>本地回环地址：127.0.0.1</p>
<p><strong>2、什么是端口</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"端口"是英文port的意译，可以认为是设备与外界通讯交流的出口。</span><br></pre></td></tr></table></figure>

<p><strong>3、在windows上查看端口占用情况</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -aon|findstr "49157"</span><br></pre></td></tr></table></figure>

<p>因此ip地址精确到具体的一台电脑，而端口精确到具体的程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">我们找寻一台机器 : ip地址</span><br><span class="line">    如何判断 要找的机器在不在同一个局域网内:</span><br><span class="line">        用自己的ip地址和子网掩码按位与运算</span><br><span class="line">        192.168.21.36 11000000.10101000.00010101.00100100</span><br><span class="line">        255.255.255.0 11111111.11111111.11111111.00000000</span><br><span class="line">        192.168.21.0  11000000.10101000.00010101.00000000  # ---网段</span><br><span class="line">        用要找的机器ip和子网掩码按位与运算</span><br><span class="line">        192.168.21.21</span><br><span class="line">        如果上面的两个结果相同说明两台机器在同一个网段</span><br><span class="line">        子网掩码</span><br><span class="line">            2进制 8进制 10进制 16进制</span><br><span class="line"></span><br><span class="line">            16 8 4 2 1 (填位法)</span><br><span class="line">            1  0 1 0 0</span><br><span class="line">    要找的机器和你在同一个局域网内:</span><br><span class="line">        通过交换机</span><br><span class="line">            广播</span><br><span class="line">            和要找机器ip地址相同的服务器做出响应,将自己的ip地址返回给交换机</span><br><span class="line">            单播 : 把返回的信息再传递给要找机器的服务器</span><br><span class="line">    要找的机器和你不在同一个局域网内</span><br><span class="line">            先走交换机</span><br><span class="line">            交换机直接将消息传递给&quot;网关ip&quot;,通过ip找到对应机器所在的局域网</span><br><span class="line">            路由表 :网段 网关ip</span><br><span class="line">            通过对方局域网中的交换机进行广播</span><br><span class="line">            把信息回传给交换机</span><br><span class="line">            ......</span><br></pre></td></tr></table></figure>

<h3 id="二、osi七层模型"><a href="#二、osi七层模型" class="headerlink" title="二、osi七层模型"></a>二、osi七层模型</h3><h4 id="1、引子"><a href="#1、引子" class="headerlink" title="1、引子"></a>1、引子</h4><p>​        须知一个完整的计算机系统是由硬件、操作系统、应用软件三者组成,具备了这三个条件，一台计算机系统就可以自己跟自己玩了（打个单机游戏，玩个扫雷啥的）</p>
<p>​        如果你要跟别人一起玩，那你就需要上网了，什么是互联网？</p>
<p>​        互联网的核心就是由一堆协议组成，协议就是标准，比如全世界人通信的标准是英语，如果把计算机比作人，互联网协议就是计算机界的英语。所有的计算机都学会了互联网协议，那所有的计算机都就可以按照统一的标准去收发信息从而完成通信了。</p>
<h4 id="2、osi七层模型"><a href="#2、osi七层模型" class="headerlink" title="2、osi七层模型"></a>2、osi七层模型</h4><p>人们按照分工不同把互联网协议从逻辑上划分了层级：</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/4.png" alt></p>
<h3 id="三、socket概念"><a href="#三、socket概念" class="headerlink" title="三、socket概念"></a>三、socket概念</h3><h4 id="1、socket层"><a href="#1、socket层" class="headerlink" title="1、socket层"></a>1、socket层</h4><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/5.png" alt></p>
<h4 id="2、理解socket"><a href="#2、理解socket" class="headerlink" title="2、理解socket"></a>2、理解socket</h4><p>​       Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其实站在你的角度上看，socket就是一个模块。我们通过调用模块中已经实现的方法建立两个进程之间的连接和通信。</span><br><span class="line">也有人将socket说成ip+port，因为ip是用来标识互联网中的一台主机的位置，而port（端口）是用来标识这台机器上的一个应用程序。</span><br><span class="line">所以我们只要确立了ip和port就能找到一个应用程序，并且使用socket模块来与之通信。</span><br></pre></td></tr></table></figure>

<h3 id="四、套接字（socket）的发展史"><a href="#四、套接字（socket）的发展史" class="headerlink" title="四、套接字（socket）的发展史"></a>四、套接字（socket）的发展史</h3><p>​       套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计<strong>用在同 一台主机上多个应用程序之间的通讯</strong>。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。 </p>
<h4 id="1、基于文件类型的套接字家族"><a href="#1、基于文件类型的套接字家族" class="headerlink" title="1、基于文件类型的套接字家族"></a>1、基于文件类型的套接字家族</h4><p>套接字家族的名字：AF_UNIX</p>
<p>unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信。</p>
<h4 id="2、基于网络类型的套接字家族"><a href="#2、基于网络类型的套接字家族" class="headerlink" title="2、基于网络类型的套接字家族"></a>2、基于网络类型的套接字家族</h4><p>套接字家族的名字：AF_INET（用于ipv4）</p>
<p>(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)</p>
<h3 id="五、tcp协议和udp协议"><a href="#五、tcp协议和udp协议" class="headerlink" title="五、tcp协议和udp协议"></a>五、tcp协议和udp协议</h3><p><strong>TCP</strong>（Transmission Control Protocol）可靠的、面向连接的协议（eg:打电话）、传输效率低全双工通信（发送缓存&amp;接收缓存）、面向字节流。使用TCP的应用：Web浏览器；电子邮件、文件传输程序。</p>
<p><strong>UDP</strong>（User Datagram Protocol）不可靠的、无连接的服务，传输效率高（发送前时延小），一对一、一对多、多对一、多对多、面向报文，尽最大努力服务，无拥塞控制。使用UDP的应用：域名系统 (DNS)；视频流；IP语音(VoIP)。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/6.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TCP协议属于 : 传输层</span><br><span class="line">    面向连接 可靠的 字节流传输  长连接（一对一）</span><br><span class="line">UDP协议属于 : 传输层</span><br><span class="line">    面向数据包的 无连接的 不可靠的 速度快 不占用连接</span><br></pre></td></tr></table></figure>

<h2 id="（四）套接字（socket）初使用"><a href="#（四）套接字（socket）初使用" class="headerlink" title="（四）套接字（socket）初使用"></a>（四）套接字（socket）初使用</h2><h3 id="一、基于TCP协议的socket"><a href="#一、基于TCP协议的socket" class="headerlink" title="一、基于TCP协议的socket"></a>一、基于TCP协议的socket</h3><p><strong>tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端</strong></p>
<p><strong>（1）</strong></p>
<p><strong>server端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8898</span>))  <span class="comment">#把地址绑定到套接字</span></span><br><span class="line">sk.listen()          <span class="comment">#监听链接</span></span><br><span class="line">conn,addr = sk.accept() <span class="comment">#接受客户端链接</span></span><br><span class="line">ret = conn.recv(<span class="number">1024</span>)  <span class="comment">#接收客户端信息</span></span><br><span class="line">print(ret)       <span class="comment">#打印客户端信息</span></span><br><span class="line">conn.send(<span class="string">b'hi'</span>)        <span class="comment">#向客户端发送信息</span></span><br><span class="line">conn.close()       <span class="comment">#关闭客户端套接字</span></span><br><span class="line">sk.close()        <span class="comment">#关闭服务器套接字(可选)</span></span><br></pre></td></tr></table></figure>

<p><strong>client端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sk = socket.socket()           <span class="comment"># 创建客户套接字</span></span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8898</span>))    <span class="comment"># 尝试连接服务器</span></span><br><span class="line">sk.send(<span class="string">b'hello!'</span>)</span><br><span class="line">ret = sk.recv(<span class="number">1024</span>)         <span class="comment"># 对话(发送/接收)</span></span><br><span class="line">print(ret)</span><br><span class="line">sk.close()            <span class="comment"># 关闭客户套接字</span></span><br></pre></td></tr></table></figure>

<p><strong>问题：重启服务端时遇到</strong></p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/7.png" alt></p>
<p>解决方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加入一条socket配置，重用ip和端口</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> SOL_SOCKET,SO_REUSEADDR</span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>) <span class="comment">#就是它，在bind前加,避免重启服务端时，出现OSError</span></span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8898</span>))  <span class="comment">#把地址绑定到套接字</span></span><br><span class="line">sk.listen()          <span class="comment">#监听链接</span></span><br><span class="line">conn,addr = sk.accept() <span class="comment">#接受客户端链接</span></span><br><span class="line">ret = conn.recv(<span class="number">1024</span>)   <span class="comment">#接收客户端信息</span></span><br><span class="line">print(ret)              <span class="comment">#打印客户端信息</span></span><br><span class="line">conn.send(<span class="string">b'hi'</span>)        <span class="comment">#向客户端发送信息</span></span><br><span class="line">conn.close()       <span class="comment">#关闭客户端套接字</span></span><br><span class="line">sk.close()        <span class="comment">#关闭服务器套接字(可选)</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）</strong></p>
<p><strong>server端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">sk.bind((<span class="string">'192.168.21.36'</span>,<span class="number">9000</span>))</span><br><span class="line">sk.listen()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr = sk.accept()  <span class="comment"># 接收连接 三次握手conn</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        inp = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">        <span class="keyword">if</span> inp == <span class="string">'q'</span>:</span><br><span class="line">            conn.send(inp.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        conn.send(inp.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        msg = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">b'q'</span>:<span class="keyword">break</span></span><br><span class="line">        print(msg.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    conn.close()    <span class="comment"># 四次挥手</span></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p><strong>client端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = sk.recv(<span class="number">1024</span>)</span><br><span class="line">    print(msg.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">b'q'</span>:<span class="keyword">break</span></span><br><span class="line">    inp = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">'q'</span>:</span><br><span class="line">        sk.send(inp.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sk.send(inp.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<h3 id="二、基于UDP协议的socket"><a href="#二、基于UDP协议的socket" class="headerlink" title="二、基于UDP协议的socket"></a>二、基于UDP协议的socket</h3><p><strong>udp是无链接的，启动服务之后可以直接接受消息，不需要提前建立链接</strong></p>
<h4 id="1、简单使用"><a href="#1、简单使用" class="headerlink" title="1、简单使用"></a>1、简单使用</h4><p><strong>server端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">udp_sk = socket.socket(type=socket.SOCK_DGRAM)   <span class="comment">#创建一个服务器的套接字</span></span><br><span class="line">udp_sk.bind((<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>))        <span class="comment">#绑定服务器套接字</span></span><br><span class="line">msg,addr = udp_sk.recvfrom(<span class="number">1024</span>)</span><br><span class="line">print(msg)</span><br><span class="line">udp_sk.sendto(<span class="string">b'hi'</span>,addr)                 <span class="comment"># 对话(接收与发送)</span></span><br><span class="line">udp_sk.close()                         <span class="comment"># 关闭服务器套接字</span></span><br></pre></td></tr></table></figure>

<p><strong>client端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>)</span><br><span class="line">udp_sk=socket.socket(type=socket.SOCK_DGRAM)</span><br><span class="line">udp_sk.sendto(<span class="string">b'hello'</span>,ip_port)</span><br><span class="line">back_msg,addr=udp_sk.recvfrom(<span class="number">1024</span>)</span><br><span class="line">print(back_msg.decode(<span class="string">'utf-8'</span>),addr)</span><br></pre></td></tr></table></figure>

<h4 id="2、qq聊天"><a href="#2、qq聊天" class="headerlink" title="2、qq聊天"></a>2、qq聊天</h4><p><strong>server</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8081</span>)</span><br><span class="line">udp_server_sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">udp_server_sock.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    qq_msg,addr=udp_server_sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">'来自[%s:%s]的一条消息:\033[1;44m%s\033[0m'</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>],qq_msg.decode(<span class="string">'utf-8'</span>)))</span><br><span class="line">    back_msg=input(<span class="string">'回复消息: '</span>).strip()</span><br><span class="line"></span><br><span class="line">    udp_server_sock.sendto(back_msg.encode(<span class="string">'utf-8'</span>),addr)</span><br></pre></td></tr></table></figure>

<p><strong>client</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_client_socket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">qq_name_dic=&#123;</span><br><span class="line">    <span class="string">'金老板'</span>:(<span class="string">'127.0.0.1'</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">'哪吒'</span>:(<span class="string">'127.0.0.1'</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">'egg'</span>:(<span class="string">'127.0.0.1'</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">'yuan'</span>:(<span class="string">'127.0.0.1'</span>,<span class="number">8081</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    qq_name=input(<span class="string">'请选择聊天对象: '</span>).strip()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg=input(<span class="string">'请输入消息,回车发送,输入q结束和他的聊天: '</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">'q'</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg <span class="keyword">or</span> <span class="keyword">not</span> qq_name <span class="keyword">or</span> qq_name <span class="keyword">not</span> <span class="keyword">in</span> qq_name_dic:<span class="keyword">continue</span></span><br><span class="line">        udp_client_socket.sendto(msg.encode(<span class="string">'utf-8'</span>),qq_name_dic[qq_name])</span><br><span class="line"></span><br><span class="line">        back_msg,addr=udp_client_socket.recvfrom(BUFSIZE)</span><br><span class="line">        print(<span class="string">'来自[%s:%s]的一条消息:\033[1;44m%s\033[0m'</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>],back_msg.decode(<span class="string">'utf-8'</span>)))</span><br><span class="line"></span><br><span class="line">udp_client_socket.close()</span><br></pre></td></tr></table></figure>

<h4 id="3、时间服务器"><a href="#3、时间服务器" class="headerlink" title="3、时间服务器"></a>3、时间服务器</h4><p><strong>server</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> strftime</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">9000</span>)</span><br><span class="line">bufsize = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">tcp_server = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">tcp_server.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">tcp_server.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg, addr = tcp_server.recvfrom(bufsize)</span><br><span class="line">    print(<span class="string">'===&gt;'</span>, msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">        time_fmt = <span class="string">'%Y-%m-%d %X'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        time_fmt = msg.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    back_msg = strftime(time_fmt)</span><br><span class="line"></span><br><span class="line">    tcp_server.sendto(back_msg.encode(<span class="string">'utf-8'</span>), addr)</span><br><span class="line"></span><br><span class="line">tcp_server.close()</span><br></pre></td></tr></table></figure>

<p><strong>client</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">tcp_client=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">'请输入时间格式(例%Y %m %d)&gt;&gt;: '</span>).strip()</span><br><span class="line">    tcp_client.sendto(msg.encode(<span class="string">'utf-8'</span>),ip_port)</span><br><span class="line"></span><br><span class="line">    data=tcp_client.recv(bufsize)</span><br></pre></td></tr></table></figure>

<h3 id="三、socket参数的详解"><a href="#三、socket参数的详解" class="headerlink" title="三、socket参数的详解"></a>三、socket参数的详解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.socket(family=AF_INET,type=SOCK_STREAM,proto=<span class="number">0</span>,fileno=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>创建socket对象的参数说明：</p>
<table>
<thead>
<tr>
<th><strong>family</strong></th>
<th>地址系列应为AF_INET(默认值),AF_INET6,AF_UNIX,AF_CAN或AF_RDS。 （AF_UNIX 域实际上是使用本地 socket 文件来通信）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>type</strong></td>
<td>套接字类型应为SOCK_STREAM(默认值),SOCK_DGRAM,SOCK_RAW或其他SOCK_常量之一。 <strong>SOCK_STREAM</strong> 是基于TCP的，有保障的（即能保证数据正确传送到对方）面向连接的SOCKET，多用于资料传送。  <strong>SOCK_DGRAM</strong> 是基于UDP的，无保障的面向消息的socket，多用于在网络上发广播信息。</td>
</tr>
<tr>
<td><strong>proto</strong></td>
<td>协议号通常为零,可以省略,或者在地址族为AF_CAN的情况下,协议应为CAN_RAW或CAN_BCM之一。</td>
</tr>
<tr>
<td><strong>fileno</strong></td>
<td>如果指定了fileno,则其他参数将被忽略,导致带有指定文件描述符的套接字返回。 与socket.fromfd()不同,fileno将返回相同的套接字,而不是重复的。 这可能有助于使用socket.close()关闭一个独立的插座。</td>
</tr>
</tbody></table>
<h2 id="（五）黏包"><a href="#（五）黏包" class="headerlink" title="（五）黏包"></a>（五）黏包</h2><h3 id="一、黏包现象"><a href="#一、黏包现象" class="headerlink" title="一、黏包现象"></a>一、黏包现象</h3><p>让我们基于tcp先制作一个远程执行命令的程序（命令ls -l ; lllllll ; pwd）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server 下发命令</span></span><br><span class="line"><span class="comment"># client 执行命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh协议</span></span><br><span class="line"><span class="comment"># import os</span></span><br><span class="line"><span class="comment"># ret = os.popen('ls').read()</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="comment"># 内置模块 和os模块的功能有相似之处</span></span><br><span class="line"><span class="comment"># 能执行操作系统的命令的功能</span></span><br><span class="line">ret = subprocess.Popen(<span class="string">'dir'</span>,    <span class="comment"># 要执行的命令</span></span><br><span class="line">                       shell=<span class="literal">True</span>,  <span class="comment"># 表示要执行的是一条系统命令</span></span><br><span class="line">                       stdout=subprocess.PIPE, <span class="comment"># 存储执行结果的正常信息</span></span><br><span class="line">                       stderr=subprocess.PIPE) <span class="comment"># 存储执行结果的错误信息</span></span><br><span class="line">print(<span class="string">'stdout : '</span>,ret.stdout.read().decode(<span class="string">'gbk'</span>))</span><br><span class="line">print(<span class="string">'stderr : '</span>,ret.stderr.read().decode(<span class="string">'gbk'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 的结果的编码是以当前所在的系统为准的，如果是windows，那么res.stdout.read()读出的就是GBK编码的，在接收端需要用GBK解码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 且只能从管道里读一次结果</span></span><br></pre></td></tr></table></figure>

<p>同时执行多条命令之后，得到的结果很可能只有一部分，在执行其他命令的时候又接收到之前执行的另外一部分结果，这种显现就是黏包。</p>
<h4 id="1、基于tcp协议实现的黏包"><a href="#1、基于tcp协议实现的黏包" class="headerlink" title="1、基于tcp协议实现的黏包"></a>1、基于tcp协议实现的黏包</h4><p><strong>tcp - server</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=tcp_socket_server.accept()</span><br><span class="line">    print(<span class="string">'客户端'</span>,addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd=conn.recv(BUFSIZE)</span><br><span class="line">        <span class="keyword">if</span> len(cmd) == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">'utf-8'</span>),shell=<span class="literal">True</span>,</span><br><span class="line">                         stdout=subprocess.PIPE,</span><br><span class="line">                         stdin=subprocess.PIPE,</span><br><span class="line">                         stderr=subprocess.PIPE)</span><br><span class="line"></span><br><span class="line">        stderr=res.stderr.read()</span><br><span class="line">        stdout=res.stdout.read()</span><br><span class="line">        conn.send(stderr)</span><br><span class="line">        conn.send(stdout)</span><br></pre></td></tr></table></figure>

<p><strong>tcp - client</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> len(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">'quit'</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    act_res=s.recv(BUFSIZE)</span><br><span class="line"></span><br><span class="line">    print(act_res.decode(<span class="string">'utf-8'</span>),end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2、基于udp协议实现的黏包"><a href="#2、基于udp协议实现的黏包" class="headerlink" title="2、基于udp协议实现的黏包"></a>2、基于udp协议实现的黏包</h4><p><strong>udp - server</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">udp_server=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">udp_server.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">udp_server.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#收消息</span></span><br><span class="line">    cmd,addr=udp_server.recvfrom(bufsize)</span><br><span class="line">    print(<span class="string">'用户命令-----&gt;'</span>,cmd)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#逻辑处理</span></span><br><span class="line">    res=subprocess.Popen(cmd.decode(<span class="string">'utf-8'</span>),shell=<span class="literal">True</span>,stderr=subprocess.PIPE,stdin=subprocess.PIPE,stdout=subprocess.PIPE)</span><br><span class="line">    stderr=res.stderr.read()</span><br><span class="line">    stdout=res.stdout.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#发消息</span></span><br><span class="line">    udp_server.sendto(stderr,addr)</span><br><span class="line">    udp_server.sendto(stdout,addr)</span><br><span class="line">udp_server.close()</span><br></pre></td></tr></table></figure>

<p><strong>udp - client</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">udp_client=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    udp_client.sendto(msg.encode(<span class="string">'utf-8'</span>),ip_port)</span><br><span class="line">    err,addr=udp_client.recvfrom(bufsize)</span><br><span class="line">    out,addr=udp_client.recvfrom(bufsize)</span><br><span class="line">    <span class="keyword">if</span> err:</span><br><span class="line">        print(<span class="string">'error : %s'</span>%err.decode(<span class="string">'utf-8'</span>),end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> out:</span><br><span class="line">        print(out.decode(<span class="string">'utf-8'</span>), end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：只有TCP有粘包现象，UDP永远不会粘包</strong></p>
<h3 id="二、黏包成因"><a href="#二、黏包成因" class="headerlink" title="二、黏包成因"></a>二、黏包成因</h3><h4 id="1、TCP协议中的数据传递"><a href="#1、TCP协议中的数据传递" class="headerlink" title="1、TCP协议中的数据传递"></a>1、TCP协议中的数据传递</h4><p><strong>（1）tcp协议的拆包机制</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。 </span><br><span class="line">MTU是Maximum Transmission Unit的缩写。意思是网络上传送的最大数据包。MTU的单位是字节。 大部分网络设备的MTU都是1500。如果本机的MTU比网关的MTU大，大的数据包就会被拆开来传送，这样会产生很多数据包碎片，增加丢包率，降低网络速度。</span><br></pre></td></tr></table></figure>

<p><strong>（2）面向流的通信特点和Nagle算法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。</span><br><span class="line">收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。</span><br><span class="line">这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。 </span><br><span class="line">对于空消息：tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），也可以被发送，udp协议会帮你封装上消息头发送过去。 </span><br><span class="line">可靠黏包的tcp协议：tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。</span><br></pre></td></tr></table></figure>

<p><strong>（3）基于tcp协议特点的黏包现象成因</strong></p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/8.png" alt></p>
<p>​        例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束</p>
<p>​        此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。</p>
<h4 id="2、UDP不会发生黏包"><a href="#2、UDP不会发生黏包" class="headerlink" title="2、UDP不会发生黏包"></a>2、UDP不会发生黏包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。 </span><br><span class="line">不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是有消息保护边界的。 </span><br><span class="line">对于空消息：tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），也可以被发送，udp协议会帮你封装上消息头发送过去。 </span><br><span class="line">不可靠不黏包的udp协议：udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠。</span><br></pre></td></tr></table></figure>

<p><strong><em>补充：udp和tcp一次发送数据长度的限制</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用UDP协议发送时，用sendto函数最大能发送数据的长度为：65535- IP头(20) – UDP头(8)＝65507字节。用sendto函数发送数据时，如果发送数据长度大于该值，则函数会返回错误。（丢弃这个包，不进行发送） </span><br><span class="line"></span><br><span class="line"> 用TCP协议发送时，由于TCP是数据流协议，因此不存在包大小的限制（暂不考虑缓冲区的大小），这是指在用send函数时，数据长度参数不受限制。而实际上，所指定的这段数据并不一定会一次性发送出去，如果这段数据比较长，会被分段发送，如果比较短，可能会等待和下一次数据一起发送。</span><br></pre></td></tr></table></figure>

<h4 id="3、会发生黏包的两种情况"><a href="#3、会发生黏包的两种情况" class="headerlink" title="3、会发生黏包的两种情况"></a>3、会发生黏包的两种情况</h4><p><strong>（1）情况一：发送方的缓存机制</strong></p>
<p>发送端需要等缓冲区满才发送出去，造成黏包（发送数据时间间隔很短，数据很小，会合到一起，产生黏包）</p>
<p>服务端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr=tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data1=conn.recv(<span class="number">10</span>)</span><br><span class="line">data2=conn.recv(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-----&gt;'</span>,data1.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(<span class="string">'-----&gt;'</span>,data2.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.send(<span class="string">'hello'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">s.send(<span class="string">'egg'</span>.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>

<p><strong>（2）情况二：接收方的缓存机制</strong></p>
<p>接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包） </p>
<p>服务端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr=tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data1=conn.recv(<span class="number">2</span>) <span class="comment">#一次没有收完整</span></span><br><span class="line">data2=conn.recv(<span class="number">10</span>)<span class="comment">#下次收的时候,会先取旧的数据,然后取新的</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'-----&gt;'</span>,data1.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(<span class="string">'-----&gt;'</span>,data2.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.send(<span class="string">'hello egg'</span>.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>

<h4 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h4><p>黏包现象只发生在tcp协议中：</p>
<p>1.从表面上看，黏包问题主要是因为发送方和接收方的缓存机制、tcp协议面向流通信的特点。</p>
<p>2.实际上，<strong>主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">为什么会出现黏包现象？</span><br><span class="line">首先只有在TCP协议中才会出现黏包现象</span><br><span class="line">是因为TCP协议是面向流的协议</span><br><span class="line">在发送的数据传输的过程中还有缓存机制来避免数据流失</span><br><span class="line">因此 在连续发送小数据的时候 以及接收大小不符的时候都容易出现黏包现象</span><br><span class="line">本质还是因为我们在接受数据的时候不知道发送的数据的长短</span><br><span class="line"></span><br><span class="line">解决黏包问题：</span><br><span class="line">1、在传输大量数据之前先告诉接收端要发送的数据的大小</span><br><span class="line">2、如果想要更漂亮地解决问题，可以通过struct模块来实现</span><br></pre></td></tr></table></figure>

<h3 id="三、黏包的解决方案"><a href="#三、黏包的解决方案" class="headerlink" title="三、黏包的解决方案"></a>三、黏包的解决方案</h3><h4 id="1、解决方案一"><a href="#1、解决方案一" class="headerlink" title="1、解决方案一"></a>1、解决方案一</h4><p>​        问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/9.png" alt></p>
<p>服务端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line">sk.listen()</span><br><span class="line">conn, addr = sk.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">'q'</span>:</span><br><span class="line">        conn.send(<span class="string">b'q'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    conn.send(cmd.encode(<span class="string">'utf-8'</span>))  <span class="comment">#</span></span><br><span class="line">    num = conn.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    conn.send(<span class="string">b'ok'</span>)</span><br><span class="line">    res = conn.recv(int(num)).decode(<span class="string">'utf-8'</span>)   <span class="comment">#</span></span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>) <span class="comment">#</span></span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    res = subprocess.Popen(cmd, shell=<span class="literal">True</span>,</span><br><span class="line">                           stdout=subprocess.PIPE,</span><br><span class="line">                           stderr=subprocess.PIPE)</span><br><span class="line">    std_out = res.stdout.read()</span><br><span class="line">    std_err = res.stderr.read()</span><br><span class="line"></span><br><span class="line">    sk.send(str(len(std_out) + len(std_err)).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    sk.recv(<span class="number">1024</span>)   <span class="comment"># ok</span></span><br><span class="line">    sk.send(std_out)</span><br><span class="line">    sk.send(std_err)</span><br><span class="line"></span><br><span class="line">sk.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好处：确定了我到底要接收多大的数据</span></span><br><span class="line">        <span class="comment"># 要在文件中配置一个配置项：就是每一次recv的大小  buffer = 4096</span></span><br><span class="line">        <span class="comment"># 当我们要发送大数据的时候，要明确的告诉接收方要发送多大的数据，以便接收方能够准确的接收到所有的数据</span></span><br><span class="line">        <span class="comment"># 多用在文件传输的过程中</span></span><br><span class="line">            <span class="comment"># 大文件的传输 一定是按照字节读，每一次读固定的字节</span></span><br><span class="line">            <span class="comment"># 传输的过程中 一边读一边传， 接收端一边收一边写</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺点：多了一次交互，会产生额外的网络延迟</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存在的问题：</span><br><span class="line">程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗</span><br></pre></td></tr></table></figure>

<h4 id="2、解决方案进阶"><a href="#2、解决方案进阶" class="headerlink" title="2、解决方案进阶"></a>2、解决方案进阶</h4><p>刚刚的方法，问题在于我们我们在发送</p>
<p>我们可以借助一个模块，这个模块可以把要发送的数据长度转换成固定长度的字节。这样客户端每次接收消息之前只要先接受这个固定长度字节的内容看一看接下来要接收的信息大小，那么最终接受的数据只要达到这个值就停止，就能刚好不多不少的接收完整的数据了。</p>
<h5 id="（1）struct模块"><a href="#（1）struct模块" class="headerlink" title="（1）struct模块"></a>（1）struct模块</h5><p>该模块可以把一个类型，如数字，转成固定长度的bytes</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; struct.pack(&apos;i&apos;,1111111111111)</span><br><span class="line"></span><br><span class="line">struct.error: &apos;i&apos; format requires -2147483648 &lt;= number &lt;= 2147483647 #这个是范围</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/10.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们在网络上传输的所有数据都叫做 数据包</span><br><span class="line">数据包里所有的数据都叫 报文</span><br><span class="line">报文里不止有数据， 还有ip地址 mac地址 端口号</span><br><span class="line">所有报文都有报头</span><br><span class="line">一般所有协议都有报头：接收多少个字节...</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json,struct</span><br><span class="line"><span class="comment">#假设通过客户端上传1T:1073741824000的文件a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为避免粘包,必须自定制报头</span></span><br><span class="line">header=&#123;<span class="string">'file_size'</span>:<span class="number">1073741824000</span>,<span class="string">'file_name'</span>:<span class="string">'/a/b/c/d/e/a.txt'</span>,<span class="string">'md5'</span>:<span class="string">'8f6fbf8347faa4924a76856701edb0f3'</span>&#125; <span class="comment">#1T数据,文件路径和md5值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了该报头能传送,需要序列化并且转为bytes</span></span><br><span class="line">head_bytes=bytes(json.dumps(header),encoding=<span class="string">'utf-8'</span>) <span class="comment">#序列化并转成bytes,用于传输</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节</span></span><br><span class="line">head_len_bytes=struct.pack(<span class="string">'i'</span>,len(head_bytes)) <span class="comment">#这4个字节里只包含了一个数字,该数字是报头的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端开始发送</span></span><br><span class="line">conn.send(head_len_bytes) <span class="comment">#先发报头的长度,4个bytes</span></span><br><span class="line">conn.send(head_bytes) <span class="comment">#再发报头的字节格式</span></span><br><span class="line">conn.sendall(文件内容) <span class="comment">#然后发真实内容的字节格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务端开始接收</span></span><br><span class="line">head_len_bytes=s.recv(<span class="number">4</span>) <span class="comment">#先收报头4个bytes,得到报头长度的字节格式</span></span><br><span class="line">x=struct.unpack(<span class="string">'i'</span>,head_len_bytes)[<span class="number">0</span>] <span class="comment">#提取报头的长度</span></span><br><span class="line"></span><br><span class="line">head_bytes=s.recv(x) <span class="comment">#按照报头长度x,收取报头的bytes格式</span></span><br><span class="line">header=json.loads(json.dumps(header)) <span class="comment">#提取报头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后根据报头的内容提取真实的数据,比如</span></span><br><span class="line">real_data_len=s.recv(header[<span class="string">'file_size'</span>])</span><br><span class="line">s.recv(real_data_len)</span><br></pre></td></tr></table></figure>

<p>关于struct的详细用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="comment">#http://www.cnblogs.com/coser/archive/2011/12/17/2291160.html</span></span><br><span class="line">__author__ = <span class="string">'Linhaifeng'</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">values1 = (<span class="number">1</span>, <span class="string">'abc'</span>.encode(<span class="string">'utf-8'</span>), <span class="number">2.7</span>)</span><br><span class="line">values2 = (<span class="string">'defg'</span>.encode(<span class="string">'utf-8'</span>),<span class="number">101</span>)</span><br><span class="line">s1 = struct.Struct(<span class="string">'I3sf'</span>)</span><br><span class="line">s2 = struct.Struct(<span class="string">'4sI'</span>)</span><br><span class="line"></span><br><span class="line">print(s1.size,s2.size)</span><br><span class="line">prebuffer=ctypes.create_string_buffer(s1.size+s2.size)</span><br><span class="line">print(<span class="string">'Before : '</span>,binascii.hexlify(prebuffer))</span><br><span class="line"><span class="comment"># t=binascii.hexlify('asdfaf'.encode('utf-8'))</span></span><br><span class="line"><span class="comment"># print(t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1.pack_into(prebuffer,<span class="number">0</span>,*values1)</span><br><span class="line">s2.pack_into(prebuffer,s1.size,*values2)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'After pack'</span>,binascii.hexlify(prebuffer))</span><br><span class="line">print(s1.unpack_from(prebuffer,<span class="number">0</span>))</span><br><span class="line">print(s2.unpack_from(prebuffer,s1.size))</span><br><span class="line"></span><br><span class="line">s3=struct.Struct(<span class="string">'ii'</span>)</span><br><span class="line">s3.pack_into(prebuffer,<span class="number">0</span>,<span class="number">123</span>,<span class="number">123</span>)</span><br><span class="line">print(<span class="string">'After pack'</span>,binascii.hexlify(prebuffer))</span><br><span class="line">print(s3.unpack_from(prebuffer,<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<h5 id="（2）使用struct解决黏包"><a href="#（2）使用struct解决黏包" class="headerlink" title="（2）使用struct解决黏包"></a>（2）使用struct解决黏包</h5><p>借助struct模块，我们知道长度数字可以被转换成一个标准大小的4字节数字。因此可以利用这个特点来预先发送数据长度。</p>
<table>
<thead>
<tr>
<th>发送时</th>
<th>接收时</th>
</tr>
</thead>
<tbody><tr>
<td>先发送struct转换好的数据长度4字节</td>
<td>先接受4个字节使用struct转换成数字来获取要接收的数据长度</td>
</tr>
<tr>
<td>再发送数据</td>
<td>再按照长度接收数据</td>
</tr>
</tbody></table>
<h6 id="a-简单版："><a href="#a-简单版：" class="headerlink" title="(a)简单版："></a>(a)简单版：</h6><p>server</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line">sk.listen()</span><br><span class="line">conn, addr = sk.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">'q'</span>:</span><br><span class="line">        conn.send(<span class="string">b'q'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    conn.send(cmd.encode(<span class="string">'utf-8'</span>))  <span class="comment">#</span></span><br><span class="line">    num = conn.recv(<span class="number">4</span>)</span><br><span class="line">    num = struct.unpack(<span class="string">'i'</span>, num)[<span class="number">0</span>]</span><br><span class="line">    res = conn.recv(int(num)).decode(<span class="string">'utf-8'</span>)   <span class="comment">#</span></span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>client</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>) <span class="comment">#</span></span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    res = subprocess.Popen(cmd, shell=<span class="literal">True</span>,</span><br><span class="line">                           stdout=subprocess.PIPE,</span><br><span class="line">                           stderr=subprocess.PIPE)</span><br><span class="line">    std_out = res.stdout.read()</span><br><span class="line">    std_err = res.stderr.read()</span><br><span class="line"></span><br><span class="line">    len_num = len(std_out) + len(std_err)</span><br><span class="line">    num_by = struct.pack(<span class="string">'i'</span>, len_num)</span><br><span class="line">    sk.send(num_by)</span><br><span class="line">    sk.send(std_out)</span><br><span class="line">    sk.send(std_err)</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<h6 id="b-复杂版："><a href="#b-复杂版：" class="headerlink" title="(b)复杂版："></a>(b)复杂版：</h6><p>服务端（自定制报头）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,struct,json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>) <span class="comment">#就是它，在bind前加</span></span><br><span class="line"></span><br><span class="line">phone.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">phone.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=phone.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'cmd: %s'</span> %cmd)</span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">'utf-8'</span>),</span><br><span class="line">                             shell=<span class="literal">True</span>,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        print(err)</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            back_msg=err</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            back_msg=res.stdout.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(<span class="string">'i'</span>,len(back_msg))) <span class="comment">#先发back_msg的长度</span></span><br><span class="line">        conn.sendall(back_msg) <span class="comment">#在发真实的内容</span></span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端（自定制报头）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> socket,time,struct</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> len(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">'quit'</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    l=s.recv(<span class="number">4</span>)</span><br><span class="line">    x=struct.unpack(<span class="string">'i'</span>,l)[<span class="number">0</span>]</span><br><span class="line">    print(type(x),x)</span><br><span class="line">    <span class="comment"># print(struct.unpack('I',l))</span></span><br><span class="line">    r_s=<span class="number">0</span></span><br><span class="line">    data=<span class="string">b''</span></span><br><span class="line">    <span class="keyword">while</span> r_s &lt; x:</span><br><span class="line">        r_d=s.recv(<span class="number">1024</span>)</span><br><span class="line">        data+=r_d</span><br><span class="line">        r_s+=len(r_d)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(data.decode('utf-8'))</span></span><br><span class="line">    print(data.decode(<span class="string">'gbk'</span>)) <span class="comment">#windows默认gbk编码</span></span><br></pre></td></tr></table></figure>

<h6 id="c-更复杂版"><a href="#c-更复杂版" class="headerlink" title="(c)更复杂版"></a>(c)更复杂版</h6><p>我们还可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了）</p>
<table>
<thead>
<tr>
<th>发送时</th>
<th>接收时</th>
</tr>
</thead>
<tbody><tr>
<td>先发报头长度</td>
<td>先收报头长度，用struct取出来</td>
</tr>
<tr>
<td>再编码报头内容然后发送</td>
<td>根据取出的长度收取报头内容，然后解码，反序列化</td>
</tr>
<tr>
<td>最后发真实内容</td>
<td>从反序列化的结果中取出待取数据的详细信息，然后去取真实的数据内容</td>
</tr>
</tbody></table>
<p>服务端（定制稍微复杂一点的报头）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,struct,json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>) <span class="comment">#就是它，在bind前加</span></span><br><span class="line"></span><br><span class="line">phone.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">phone.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=phone.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'cmd: %s'</span> %cmd)</span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">'utf-8'</span>),</span><br><span class="line">                             shell=<span class="literal">True</span>,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        print(err)</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            back_msg=err</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            back_msg=res.stdout.read()</span><br><span class="line"></span><br><span class="line">        headers=&#123;<span class="string">'data_size'</span>:len(back_msg)&#125;</span><br><span class="line">        head_json=json.dumps(headers)</span><br><span class="line">        head_json_bytes=bytes(head_json,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(<span class="string">'i'</span>,len(head_json_bytes))) <span class="comment">#先发报头的长度</span></span><br><span class="line">        conn.send(head_json_bytes) <span class="comment">#再发报头</span></span><br><span class="line">        conn.sendall(back_msg) <span class="comment">#在发真实的内容</span></span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct,json</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd=input(<span class="string">'&gt;&gt;: '</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">continue</span></span><br><span class="line">    client.send(bytes(cmd,encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    head=client.recv(<span class="number">4</span>)</span><br><span class="line">    head_json_len=struct.unpack(<span class="string">'i'</span>,head)[<span class="number">0</span>]</span><br><span class="line">    head_json=json.loads(client.recv(head_json_len).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    data_len=head_json[<span class="string">'data_size'</span>]</span><br><span class="line"></span><br><span class="line">    recv_size=<span class="number">0</span></span><br><span class="line">    recv_data=<span class="string">b''</span></span><br><span class="line">    <span class="keyword">while</span> recv_size &lt; data_len:</span><br><span class="line">        recv_data+=client.recv(<span class="number">1024</span>)</span><br><span class="line">        recv_size+=len(recv_data)</span><br><span class="line"></span><br><span class="line">    print(recv_data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="comment">#print(recv_data.decode('gbk')) #windows默认gbk编码</span></span><br></pre></td></tr></table></figure>

<h4 id="3、FTP作业：上传下载文件"><a href="#3、FTP作业：上传下载文件" class="headerlink" title="3、FTP作业：上传下载文件"></a>3、FTP作业：上传下载文件</h4><p>服务端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8090</span>))</span><br><span class="line">buffer = <span class="number">1024</span></span><br><span class="line">sk.listen()</span><br><span class="line"></span><br><span class="line">conn, addr = sk.accept()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收端</span></span><br><span class="line">head_len = conn.recv(<span class="number">4</span>)</span><br><span class="line">head_len = struct.unpack(<span class="string">'i'</span>, head_len)[<span class="number">0</span>]</span><br><span class="line">json_head = conn.recv(head_len).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">head = json.loads(json_head)</span><br><span class="line"></span><br><span class="line">filesize = head[<span class="string">'filesize'</span>]</span><br><span class="line"><span class="keyword">with</span> open(head[<span class="string">'filename'</span>], <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> filesize:</span><br><span class="line">        <span class="keyword">if</span> filesize &gt;= buffer:</span><br><span class="line">            content = conn.recv(buffer)</span><br><span class="line">            f.write(content)</span><br><span class="line">            filesize -= buffer</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            content = conn.recv(filesize)</span><br><span class="line">            f.write(content)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8090</span>))</span><br><span class="line"></span><br><span class="line">buffer = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送文件</span></span><br><span class="line">head = &#123;<span class="string">'filepath'</span>: <span class="string">r'D:\视频存放位置\day18'</span>,</span><br><span class="line">        <span class="string">'filename'</span>: <span class="string">r'04 python fullstack s9 day18 re模块。mp4'</span>,</span><br><span class="line">        <span class="string">'filesize'</span>: <span class="literal">None</span>&#125;</span><br><span class="line">file_path = os.path.join(head[<span class="string">'filepath'</span>], head[<span class="string">'filename'</span>])</span><br><span class="line">filesize = os.path.getsize(file_path)</span><br><span class="line">head[<span class="string">'filesize'</span>] = filesize</span><br><span class="line"></span><br><span class="line">json_head = json.dump(head)     <span class="comment"># 字典转成了字符串</span></span><br><span class="line">bytes_head = json_head.encode(<span class="string">'utf-8'</span>)      <span class="comment"># 字符串转bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算head的长度</span></span><br><span class="line">head_len = len(bytes_head)      <span class="comment"># 报头长度</span></span><br><span class="line">pack_len = struct.pack(<span class="string">'i'</span>, head_len)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sk.send(pack_len)       <span class="comment"># 先发报头长度</span></span><br><span class="line">sk.send(bytes_head)     <span class="comment"># 再发送bytes类型的报头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(file_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> filesize:</span><br><span class="line">        <span class="keyword">if</span> filesize &gt;= buffer:</span><br><span class="line">            content = f.read(buffer)    <span class="comment"># 每次读出的内容</span></span><br><span class="line">            sk.send(content)</span><br><span class="line">            filesize -= buffer</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            content = f.read(filesize)</span><br><span class="line">            sk.send(content)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<h2 id="（六）socket的更多方法介绍"><a href="#（六）socket的更多方法介绍" class="headerlink" title="（六）socket的更多方法介绍"></a>（六）socket的更多方法介绍</h2><h3 id="一、更多方法"><a href="#一、更多方法" class="headerlink" title="一、更多方法"></a>一、更多方法</h3><p><strong>服务端套接字函数</strong><br>s.bind()    绑定(主机,端口号)到套接字<br>s.listen()  开始TCP监听<br>s.accept()  被动接受TCP客户的连接,(阻塞式)等待连接的到来</p>
<p><strong>客户端套接字函数</strong><br>s.connect()     主动初始化TCP服务器连接<br>s.connect_ex()  connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</p>
<p><strong>公共用途的套接字函数</strong><br>s.recv()            接收TCP数据<br>s.send()            发送TCP数据<br>s.sendall()         发送TCP数据<br>s.recvfrom()        接收UDP数据<br>s.sendto()          发送UDP数据<br>s.getpeername()     连接到当前套接字的远端的地址<br>s.getsockname()     当前套接字的地址<br>s.getsockopt()      返回指定套接字的参数<br>s.setsockopt()      设置指定套接字的参数<br>s.close()           关闭套接字</p>
<p><strong>面向锁的套接字方法</strong><br><strong>s.setblocking()     设置套接字的阻塞与非阻塞模式</strong></p>
<p>​        s.setblocking(False) 设置非阻塞模式 </p>
<p>s.settimeout()      设置阻塞套接字操作的超时时间<br>s.gettimeout()      得到阻塞套接字操作的超时时间</p>
<p><strong>面向文件的套接字的函数</strong><br>s.fileno()          套接字的文件描述符<br>s.makefile()        创建一个与该套接字相关的文件</p>
<h3 id="二、send和sendall方法"><a href="#二、send和sendall方法" class="headerlink" title="二、send和sendall方法"></a>二、send和sendall方法</h3><p>官方文档对socket模块下的socket.send()和socket.sendall()解释如下：</p>
<p>socket.send(string[, flags])<br>Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above. Returns the number of bytes sent. Applications are responsible for checking that all data has been sent; if only some of the data was transmitted, the application needs to attempt delivery of the remaining data.</p>
<p>send()的返回值是发送的字节数量，这个数量值可能小于要发送的string的字节数，也就是说可能无法发送string中所有的数据。如果有错误则会抛出异常。</p>
<p>–</p>
<p>socket.sendall(string[, flags])<br>Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above. Unlike send(), this method continues to send data from string until either all data has been sent or an error occurs. None is returned on success. On error, an exception is raised, and there is no way to determine how much data, if any, was successfully sent.</p>
<p>尝试发送string的所有数据，成功则返回None，失败则抛出异常。</p>
<p>故，下面两段代码是等价的：</p>
<p>sock.sendall(‘Hello world\n’)    # sandall 一次性发送所有数据，send 可能会有拆包现象</p>
<p>buffer = ‘Hello world\n’</p>
<p>while buffer:</p>
<p>​    bytes = sock.send(buffer)</p>
<p>​    buffer = buffer[bytes:]</p>
<h2 id="（七）验证客户端链接的合法性"><a href="#（七）验证客户端链接的合法性" class="headerlink" title="（七）验证客户端链接的合法性"></a>（七）验证客户端链接的合法性</h2><p>如果你想在分布式系统中实现一个简单的客户端链接认证功能，又不像SSL那么复杂，那么利用hmac+加盐的方式来实现</p>
<h3 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"></span><br><span class="line">secret_key = <span class="string">b'egg'</span></span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line">sk.listen()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_conn</span><span class="params">(conn)</span>:</span></span><br><span class="line">    msg = os.urandom(<span class="number">32</span>)</span><br><span class="line">    conn.send(msg)</span><br><span class="line">    h = hmac.new(secret_key, msg)</span><br><span class="line">    digest = h.digest()</span><br><span class="line">    client_digest = conn.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hmac.compare_digest(digest, client_digest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn, addr = sk.accept()</span><br><span class="line">res = check_conn(conn)</span><br><span class="line"><span class="keyword">if</span> res:</span><br><span class="line">    print(<span class="string">'合法的客户端'</span>)</span><br><span class="line">    conn.close()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'不合法的客户端'</span>)</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<h3 id="2、客户端（合法）"><a href="#2、客户端（合法）" class="headerlink" title="2、客户端（合法）"></a>2、客户端（合法）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"></span><br><span class="line">secret_key = <span class="string">b'egg'</span></span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line">msg = sk.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">h = hmac.new(secret_key, msg)</span><br><span class="line">digest = h.digest()</span><br><span class="line"></span><br><span class="line">sk.send(digest)</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<h2 id="（八）socketserver"><a href="#（八）socketserver" class="headerlink" title="（八）socketserver"></a>（八）socketserver</h2><h3 id="1、server端"><a href="#1、server端" class="headerlink" title="1、server端"></a>1、server端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyServer</span><span class="params">(socketserver.BaseRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            msg = self.request.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="keyword">if</span> msg == <span class="string">'q'</span>:</span><br><span class="line">                <span class="comment"># self.request.close()</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            print(msg)        <span class="comment"># self.request相当于一个conn</span></span><br><span class="line"></span><br><span class="line">            info = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">            self.request.send(info.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server = socketserver.ThreadingTCPServer((<span class="string">'127.0.0.1'</span>, <span class="number">8090</span>), MyServer)</span><br><span class="line"></span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure>

<h3 id="2、client"><a href="#2、client" class="headerlink" title="2、client"></a>2、client</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8090</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    sk.send((<span class="string">'user1:'</span> + msg).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    ret = sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    print(ret)</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/21/python全栈/第01部分：基础+模块+面向对象+网络编程/面向对象/面向对象进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/21/python全栈/第01部分：基础+模块+面向对象+网络编程/面向对象/面向对象进阶/" itemprop="url">面向对象进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-21T23:34:55+08:00">
                2019-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-01部分-面向对象/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -01部分 -面向对象</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="（一）进阶"><a href="#（一）进阶" class="headerlink" title="（一）进阶"></a>（一）进阶</h2><h3 id="一、isinstance-和-issubclass"><a href="#一、isinstance-和-issubclass" class="headerlink" title="一、isinstance 和 issubclass(***)"></a>一、isinstance 和 issubclass(***)</h3><ul>
<li><strong>isinstance(obj, cls)检查是否obj是否是类 cls 的对象</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">     <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">obj = Foo()</span><br><span class="line">  </span><br><span class="line">isinstance(obj, Foo)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>issubclass(sub, super)检查sub类是否是 super 类的派生类</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(Foo)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">issubclass(Bar, Foo)</span><br></pre></td></tr></table></figure>

<h3 id="二、反射（-）"><a href="#二、反射（-）" class="headerlink" title="二、反射（******）"></a>二、反射（******）</h3><h4 id="1、什么是反射"><a href="#1、什么是反射" class="headerlink" title="1、什么是反射"></a>1、什么是反射</h4><p>​        反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。</p>
<h4 id="2、python面向对象中的反射"><a href="#2、python面向对象中的反射" class="headerlink" title="2、python面向对象中的反射"></a>2、python面向对象中的反射</h4><p>四个可以实现自省的函数：hasattr、getattr、setattr、delattr</p>
<p>下列方法适用于类和对象（一切皆对象，类本身也是一个对象）</p>
<p><strong>（1）hasattr</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个模块中的类能不能反射得到</span></span><br><span class="line"><span class="keyword">import</span> my</span><br><span class="line">print(getattr(my,<span class="string">'C'</span>)())</span><br><span class="line"><span class="keyword">if</span> hasattr(my,<span class="string">'name'</span>):</span><br><span class="line">    getattr(my,<span class="string">'name'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>（2）getattr</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    price = <span class="number">20</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">'in func'</span>)</span><br><span class="line"><span class="comment"># 反射类的属性</span></span><br><span class="line"><span class="comment"># A.price</span></span><br><span class="line">print(getattr(A,<span class="string">'price'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反射类的方法 ：classmethod staticmethod</span></span><br><span class="line"><span class="comment"># A.func()</span></span><br><span class="line"><span class="keyword">if</span> hasattr(A,<span class="string">'func'</span>):</span><br><span class="line">    getattr(A,<span class="string">'func'</span>)()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模块</span></span><br><span class="line"><span class="keyword">import</span> my</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">my模块内容：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">day = 'Monday'  # 周一</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def wahaha():</span></span><br><span class="line"><span class="string">    print('wahahaha')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class C:</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 反射模块的属性</span></span><br><span class="line">print(my.day)</span><br><span class="line">print(getattr(my,<span class="string">'day'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反射模块的方法</span></span><br><span class="line">getattr(my,<span class="string">'wahaha'</span>)()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内置模块也能用</span></span><br><span class="line"><span class="comment"># time</span></span><br><span class="line"><span class="comment"># asctime</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(getattr(time,<span class="string">'time'</span>)())</span><br><span class="line">print(getattr(time,<span class="string">'asctime'</span>)())</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qqxing</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'qqxing'</span>)</span><br><span class="line">year = <span class="number">2018</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">print(sys.modules[<span class="string">'__main__'</span>].year)</span><br><span class="line"><span class="comment"># 反射自己模块中的变量</span></span><br><span class="line">print(getattr(sys.modules[<span class="string">'__main__'</span>],<span class="string">'year'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反射自己模块中的函数</span></span><br><span class="line">getattr(sys.modules[<span class="string">'__main__'</span>],<span class="string">'qqxing'</span>)()</span><br><span class="line"></span><br><span class="line">变量名 = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">print(getattr(sys.modules[__name__],变量名))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要反射的函数有参数怎么办?</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(time.strftime(<span class="string">'%Y-%m-%d %H:%M:S'</span>))</span><br><span class="line">print(getattr(time,<span class="string">'strftime'</span>)(<span class="string">'%Y-%m-%d %H:%M:S'</span>))</span><br></pre></td></tr></table></figure>

<p><strong>（3）setattr</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line"><span class="comment"># setattr  设置修改变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a = A()</span><br><span class="line">setattr(a,<span class="string">'name'</span>,<span class="string">'nezha'</span>)</span><br><span class="line">setattr(A,<span class="string">'name'</span>,<span class="string">'alex'</span>)</span><br><span class="line">print(A.name)</span><br><span class="line">print(a.name)</span><br></pre></td></tr></table></figure>

<p><strong>（4）delattr</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line"><span class="comment"># delattr 删除一个变量</span></span><br><span class="line">delattr(a,<span class="string">'name'</span>)</span><br><span class="line">print(a.name)</span><br><span class="line">delattr(A,<span class="string">'name'</span>)</span><br><span class="line">print(a.name)</span><br></pre></td></tr></table></figure>

<h3 id="三、-str-和-repr"><a href="#三、-str-和-repr" class="headerlink" title="三、__str__ 和 _repr_"></a>三、__str__ 和 _<em>repr_</em></h3><p>改变对象的字符串显示__str__,_<em>repr_</em></p>
<p>自定制格式化字符串_<em>format_</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">str函数或者print函数---&gt;obj.__str__()</span></span><br><span class="line"><span class="string">repr或者交互式解释器---&gt;obj.__repr__()</span></span><br><span class="line"><span class="string">如果__str__没有被定义,那么就会使用__repr__来代替输出</span></span><br><span class="line"><span class="string">注意:这俩方法的返回值必须是字符串,否则抛出异常</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"A's object"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"wahaha"</span></span><br><span class="line">  </span><br><span class="line">a = A()</span><br><span class="line">print(a)	<span class="comment"># 打印一个对象的时候，就是调用a.__str__</span></span><br><span class="line"><span class="comment"># object 里有一个__str__，一旦被调用，就返回调用这个方法对象的内存地址</span></span><br><span class="line"></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'%s:%s'</span>%(<span class="string">'A'</span>, a))	<span class="comment"># %s str() 直接打印 实际上都是走的__str__</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,salary)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.salary = salary</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Teacher's object :%s"</span>%self.name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.__dict__)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'wahaha'</span></span><br><span class="line">nezha = Teacher(<span class="string">'哪吒'</span>,<span class="number">250</span>)</span><br><span class="line">print(nezha) </span><br><span class="line">print(repr(nezha))</span><br><span class="line">print(<span class="string">'&gt;&gt;&gt; %r'</span>%nezha)</span><br><span class="line"></span><br><span class="line"><span class="comment"># a.__str__ --&gt; object</span></span><br><span class="line"><span class="comment"># object  里有一个__str__，一旦被调用，就返回调用这个方法的对象的内存地址</span></span><br><span class="line"><span class="comment"># %s str()  直接打印 实际上都是走的__str__</span></span><br><span class="line"><span class="comment"># %r repr()  实际上都是走的__repr__</span></span><br><span class="line"><span class="comment"># repr 是str的备胎，但str不能做repr的备胎</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(obj)/'%s'%obj/str(obj)的时候，实际上是内部调用了obj.__str__方法，如果str方法有，那么他返回的必定是一个字符串</span></span><br><span class="line"><span class="comment"># 如果没有__str__方法，会先找本类中的__repr__方法，再没有再找父类中的__str__。</span></span><br><span class="line"><span class="comment"># repr(),只会找__repr__,如果没有找父类的</span></span><br></pre></td></tr></table></figure>

<h3 id="四、item系列"><a href="#四、item系列" class="headerlink" title="四、item系列"></a>四、item系列</h3><h4 id="1、-getitem-、-setitem-、-delitem"><a href="#1、-getitem-、-setitem-、-delitem" class="headerlink" title="1、__getitem__、__setitem__、__delitem__"></a>1、__getitem__、__setitem__、__delitem__</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 就像字典一样的操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,sex)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self,item):</span><br><span class="line">            <span class="keyword">return</span> self.__dict__[item]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self.__dict__[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.__dict__[key]</span><br><span class="line"></span><br><span class="line">f = Foo(<span class="string">'egon'</span>,<span class="number">38</span>,<span class="string">'男'</span>)</span><br><span class="line">print(f[<span class="string">'name'</span>])</span><br><span class="line">f[<span class="string">'hobby'</span>] = <span class="string">'男'</span></span><br><span class="line">print(f.hobby,f[<span class="string">'hobby'</span>])</span><br><span class="line"><span class="keyword">del</span> f.hobby      <span class="comment"># object 原生支持  __delattr__</span></span><br><span class="line"><span class="keyword">del</span> f[<span class="string">'hobby'</span>]   <span class="comment"># 通过自己实现的</span></span><br><span class="line">print(f.__dict__)</span><br></pre></td></tr></table></figure>

<h3 id="五、-del"><a href="#五、-del" class="headerlink" title="五、_del_"></a>五、_<em>del_</em></h3><p>析构方法，当对象在内存中被释放时，自动触发执行。</p>
<p><strong>注：</strong></p>
<p>​        此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。</p>
<p>简单示范：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span>   <span class="comment"># 析构函数: 在删除一个对象之前进行一些收尾工作</span></span><br><span class="line">        self.f.close()</span><br><span class="line">a = A()</span><br><span class="line">a.f = open()   <span class="comment"># 打开文件 第一 在操作系统中打开了一个文件 拿到了文件操作符存在了内存中</span></span><br><span class="line"><span class="keyword">del</span> a          <span class="comment"># a.f 拿到了文件操作符消失在了内存中</span></span><br><span class="line"><span class="keyword">del</span> a   <span class="comment"># del 既执行了这个方法，又删除了变量</span></span><br><span class="line"><span class="comment"># 引用计数</span></span><br></pre></td></tr></table></figure>

<h3 id="六、-new"><a href="#六、-new" class="headerlink" title="六、_new_"></a>六、_<em>new_</em></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="number">1</span></span><br><span class="line">        print(<span class="string">'in init function'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'in new function'</span>)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(A)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a.x)</span><br></pre></td></tr></table></figure>

<p>设计模式<br>23种</p>
<p>单例模式：<br>一个类 始终 只有 一个 实例<br>当你第一次实例化这个类的时候 就创建一个实例化的对象<br>当你之后再来实例化的时候 就用之前创建的对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    __instance = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance:</span><br><span class="line">            <span class="keyword">return</span> cls.__instance</span><br><span class="line">        cls.__instance = object.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">egon = A(<span class="string">'egg'</span>,<span class="number">38</span>)</span><br><span class="line">egon.cloth = <span class="string">'小花袄'</span></span><br><span class="line">nezha = A(<span class="string">'nazha'</span>,<span class="number">25</span>)</span><br><span class="line">print(nezha)</span><br><span class="line">print(egon)</span><br><span class="line">print(nezha.name)</span><br><span class="line">print(egon.name)</span><br><span class="line">print(nezha.cloth)</span><br></pre></td></tr></table></figure>

<h3 id="七、-call"><a href="#七、-call" class="headerlink" title="七、_call_"></a>七、_<em>call_</em></h3><p>对象后面加括号，触发执行。</p>
<p><strong>注：</strong></p>
<p>​        构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 _<em>call_</em> 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        打印这个对象中的所有属性</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self.__dict__:</span><br><span class="line">            print(k,self.__dict__[k])</span><br><span class="line">a = A(<span class="string">'alex'</span>)()</span><br></pre></td></tr></table></figure>

<h3 id="八、with-和-enter-exit"><a href="#八、with-和-enter-exit" class="headerlink" title="八、with 和 __enter__, _exit_"></a>八、with 和 __enter__, _<em>exit_</em></h3><h4 id="1、with语句"><a href="#1、with语句" class="headerlink" title="1、with语句"></a>1、with语句</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'before'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        print(<span class="string">'after'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> A() <span class="keyword">as</span> a:</span><br><span class="line">    print(<span class="string">'123'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2、with语句和init"><a href="#2、with语句和init" class="headerlink" title="2、with语句和init"></a>2、with语句和init</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'init'</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'before'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        print(<span class="string">'after'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> A() <span class="keyword">as</span> a:</span><br><span class="line">    print(<span class="string">'123'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3、with和文件操作"><a href="#3、with和文件操作" class="headerlink" title="3、with和文件操作"></a>3、with和文件操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myfile</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,path,mode=<span class="string">'r'</span>,encoding = <span class="string">'utf-8'</span>)</span>:</span></span><br><span class="line">        self.path = path</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.encoding = encoding</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.f = open(self.path, mode=self.mode, encoding=self.encoding)</span><br><span class="line">        <span class="keyword">return</span> self.f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        self.f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Myfile(<span class="string">'file'</span>,mode=<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'wahaha'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="4、with和pickle"><a href="#4、with和pickle" class="headerlink" title="4、with和pickle"></a>4、with和pickle</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  pickle</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPickledump</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,path)</span>:</span></span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.f = open(self.path, mode=<span class="string">'ab'</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(self,content)</span>:</span></span><br><span class="line">        pickle.dump(content,self.f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        self.f.close()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mypickleload</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,path)</span>:</span></span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.f = open(self.path, mode=<span class="string">'rb'</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        self.f.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">return</span> pickle.load(self.f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaditer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">yield</span>  self.load()</span><br><span class="line">            <span class="keyword">except</span> EOFError:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># with MyPickledump('file') as f:</span></span><br><span class="line"><span class="comment">#      f.dump(&#123;1,2,3,4&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Mypickleload(<span class="string">'file'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> f.loaditer():</span><br><span class="line">        print(item)</span><br></pre></td></tr></table></figure>

<h4 id="5、with-和-pickle-和-iter"><a href="#5、with-和-pickle-和-iter" class="headerlink" title="5、with 和 pickle 和 iter"></a>5、with 和 pickle 和 iter</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  pickle</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPickledump</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,path)</span>:</span></span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.f = open(self.path, mode=<span class="string">'ab'</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(self,content)</span>:</span></span><br><span class="line">        pickle.dump(content,self.f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        self.f.close()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mypickleload</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,path)</span>:</span></span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.f = open(self.path, mode=<span class="string">'rb'</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        self.f.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">yield</span>  pickle.load(self.f)</span><br><span class="line">            <span class="keyword">except</span> EOFError:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># with MyPickledump('file') as f:</span></span><br><span class="line"><span class="comment">#      f.dump(&#123;1,2,3,4&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Mypickleload(<span class="string">'file'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> f:</span><br><span class="line">        print(item)</span><br></pre></td></tr></table></figure>

<h3 id="九、-len"><a href="#九、-len" class="headerlink" title="九、_len_"></a>九、_<em>len_</em></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classes</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.student = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.student)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'classes'</span></span><br><span class="line">      </span><br><span class="line">py_s9= Classes(<span class="string">'python全栈9期'</span>)</span><br><span class="line">py_s9.student.append(<span class="string">'二哥'</span>)</span><br><span class="line">py_s9.student.append(<span class="string">'泰哥'</span>)</span><br><span class="line">print(len(py_s9))</span><br><span class="line">print(py_s9)</span><br></pre></td></tr></table></figure>

<h3 id="十、-hash"><a href="#十、-hash" class="headerlink" title="十、_hash_"></a>十、_<em>hash_</em></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,sex)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.sex = sex</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self.name+self.sex)</span><br><span class="line"></span><br><span class="line">a = A(<span class="string">'egon'</span>,<span class="string">'男'</span>)</span><br><span class="line">b = A(<span class="string">'egon'</span>,<span class="string">'nv'</span>)</span><br><span class="line">print(hash(a))</span><br><span class="line">print(hash(b))</span><br></pre></td></tr></table></figure>

<h3 id="十一、-eq"><a href="#十一、-eq" class="headerlink" title="十一、_eq_"></a>十一、_<em>eq_</em></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__dict__ == other.__dict__:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">ob1 = A(<span class="string">'egon'</span>)</span><br><span class="line">ob2 = A(<span class="string">'egg'</span>)</span><br><span class="line">print(ob1 == ob2)</span><br></pre></td></tr></table></figure>

<h2 id="（二）小实例"><a href="#（二）小实例" class="headerlink" title="（二）小实例"></a>（二）小实例</h2><h3 id="一、纸牌游戏"><a href="#一、纸牌游戏" class="headerlink" title="一、纸牌游戏"></a>一、纸牌游戏</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FranchDeck</span>:</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)	<span class="comment"># 2-A</span></span><br><span class="line">    suits = [<span class="string">'红心'</span>,<span class="string">'方板'</span>,<span class="string">'梅花'</span>,<span class="string">'黑桃'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(rank,suit) <span class="keyword">for</span> rank <span class="keyword">in</span> FranchDeck.ranks</span><br><span class="line">                                        <span class="keyword">for</span> suit <span class="keyword">in</span> FranchDeck.suits]</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        列表表达式</span></span><br><span class="line"><span class="string">        效果等价于：</span></span><br><span class="line"><span class="string">        	for suit in FranchDeck.suits:</span></span><br><span class="line"><span class="string">        		for rank in FranchDeck.ranks:</span></span><br><span class="line"><span class="string">        			将Card(rank,suit)添加到列表中</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[item]</span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> json.dumps(self._cards,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">deck = FranchDeck()</span><br><span class="line">print(deck[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">print(choice(deck))		<span class="comment"># 抽牌 要用到__len__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line">shuffle(deck)</span><br><span class="line">print(deck[<span class="number">10</span>])		<span class="comment"># 洗牌 要用到__getitem__</span></span><br><span class="line"></span><br><span class="line">print(deck)		<span class="comment"># 通过json模块输出所有当下顺序的牌</span></span><br><span class="line">print(deck[:<span class="number">5</span>])		<span class="comment"># 取前5张牌</span></span><br></pre></td></tr></table></figure>

<h3 id="二、一道面试题"><a href="#二、一道面试题" class="headerlink" title="二、一道面试题"></a>二、一道面试题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,sex)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = sex</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self.name+self.sex)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.name == other.name <span class="keyword">and</span> self.sex == other.sex:<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p_lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">84</span>):</span><br><span class="line">    p_lst.append(Person(<span class="string">'egon'</span>,i,<span class="string">'male'</span>))</span><br><span class="line"></span><br><span class="line">print(p_lst)</span><br><span class="line">print(set(p_lst))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set 依赖对象的 hash eq</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="John Doe">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">65</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://suliangxu.github.io" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1193135584@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  



  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
