<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/09/python全栈/第01部分：基础+模块+面向对象+网络编程/模块/模块和包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/09/python全栈/第01部分：基础+模块+面向对象+网络编程/模块/模块和包/" itemprop="url">模块和包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-09T07:53:58+08:00">
                2019-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-01部分-模块和包/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -01部分 -模块和包</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="（一）模块"><a href="#（一）模块" class="headerlink" title="（一）模块"></a>（一）模块</h2><h3 id="一、什么是模块"><a href="#一、什么是模块" class="headerlink" title="一、什么是模块"></a>一、什么是模块</h3><p>​        常见的场景：一个模块就是一个包含了python定义和声明的文件，文件名就是模块名字加上.py的后缀。</p>
<p>   但其实import加载的模块分为四个通用类别：　</p>
<p>　　1 使用python编写的代码（.py文件）</p>
<p>　　2 已被编译为共享库或DLL的C或C++扩展</p>
<p>　　3 包好一组模块的包</p>
<p>　　4 使用C编写并链接到python解释器的内置模块</p>
<h3 id="二、为何要使用模块"><a href="#二、为何要使用模块" class="headerlink" title="二、为何要使用模块"></a>二、为何要使用模块</h3><p>​    如果你退出python解释器然后重新进入，那么你之前定义的函数或者变量都将丢失，因此我们通常将程序写到文件中以便永久保存下来，需要时就通过python test.py方式去执行，此时test.py被称为脚本script。</p>
<p>​    随着程序的发展，功能越来越多，为了方便管理，我们通常将程序分成一个个的文件，这样做程序的结构更清晰，方便管理。这时我们不仅仅可以把这些文件当做脚本去执行，还可以把他们当做模块来导入到其他的模块中，实现了功能的重复利用，</p>
<h3 id="三、如何使用模块"><a href="#三、如何使用模块" class="headerlink" title="三、如何使用模块"></a>三、如何使用模块</h3><h4 id="1、import"><a href="#1、import" class="headerlink" title="1、import"></a>1、import</h4><p>示例文件：自定义模块my_module.py，文件名my_module.py,模块名my_module</p>
<p>my_module模块:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#my_module.py</span></span><br><span class="line">print(<span class="string">'from the my_module.py'</span>)</span><br><span class="line"></span><br><span class="line">money=<span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'my_module-&gt;read1-&gt;money'</span>,money)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'my_module-&gt;read2 calling read1'</span>)</span><br><span class="line">    read1()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> money</span><br><span class="line">    money=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>​        模块可以包含可执行的语句和函数的定义，这些语句的目的是初始化模块，它们只在模块名第一次遇到导入import语句时才执行（import语句是可以在程序中的任意位置使用的,且针对同一个模块很import多次,为了防止你重复导入，python的优化手段是：第一次导入后就将模块名加载到内存了，后续的import语句仅是对已经加载大内存中的模块对象增加了一次引用，不会重新执行模块内的语句），如下 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#demo.py</span></span><br><span class="line"><span class="keyword">import</span> my_module <span class="comment">#只在第一次导入时才执行my_module.py内代码,此处的显式效果是只打印一次'from the my_module.py',当然其他的顶级代码也都被执行了,只不过没有显示效果.</span></span><br><span class="line"><span class="keyword">import</span> my_module</span><br><span class="line"><span class="keyword">import</span> my_module</span><br><span class="line"><span class="keyword">import</span> my_module</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果：</span></span><br><span class="line"><span class="string">from the my_module.py</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>​        我们可以从sys.modules中找到当前已经加载的模块，sys.modules是一个字典，内部包含模块名与模块对象的映射，该字典决定了导入模块时是否需要重新导入。</p>
<p>​        每个模块都是一个独立的名称空间，定义在这个模块中的函数，把这个模块的名称空间当做全局名称空间，这样我们在编写自己的模块时，就不用担心我们定义在自己模块中全局变量会在被导入时，与使用者的全局变量冲突</p>
<p>测试一:money与my_module.money不冲突</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试一:money与my_module.money不冲突</span></span><br><span class="line"><span class="comment">#demo.py</span></span><br><span class="line"><span class="keyword">import</span> my_module</span><br><span class="line">money=<span class="number">10</span></span><br><span class="line">print(my_module.money)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果：</span></span><br><span class="line"><span class="string">from the my_module.py</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>测试二：read1与my_module.read1不冲突</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试二：read1与my_module.read1不冲突</span></span><br><span class="line"><span class="comment">#demo.py</span></span><br><span class="line"><span class="keyword">import</span> my_module</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'========'</span>)</span><br><span class="line">my_module.read1()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">from the my_module.py</span></span><br><span class="line"><span class="string">my_module-&gt;read1-&gt;money 1000</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>测试三：执行my_module.change()操作的全局变量money仍然是my_module中的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试三：执行my_module.change()操作的全局变量money仍然是my_module中的</span></span><br><span class="line"><span class="comment">#demo.py</span></span><br><span class="line"><span class="keyword">import</span> my_module</span><br><span class="line">money=<span class="number">1</span></span><br><span class="line">my_module.change()</span><br><span class="line">print(money)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果：</span></span><br><span class="line"><span class="string">from the my_module.py</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>总结：首次导入模块my_module时会做三件事：</p>
<p>1.为源文件(my_module模块)创建新的名称空间，在my_module中定义的函数和方法若是使用到了global时访问的就是这个名称空间。</p>
<p>2.在新创建的命名空间中执行模块中包含的代码，见初始导入import my_module</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 提示:导入模块时到底执行了什么？</span><br><span class="line">2 </span><br><span class="line">3 In fact function definitions are also ‘statements’ that are ‘executed’; the execution of a module-level function definition enters the function name in the module’s global symbol table.</span><br><span class="line">4 事实上函数定义也是“被执行”的语句，模块级别函数定义的执行将函数名放入模块全局名称空间表，用globals()可以查看</span><br></pre></td></tr></table></figure>

<p>3.创建名字my_module来引用该命名空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 这个名字和变量名没什么区别，都是‘第一类的’，且使用my_module.名字的方式可以访问my_module.py文件中定义的名字，my_module.名字与test.py中的名字来自两个完全不同的地方。</span><br></pre></td></tr></table></figure>

<p>为模块名起别名，相当于m1=1;m2=m1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_module <span class="keyword">as</span> sm</span><br><span class="line">print(sm.money)</span><br></pre></td></tr></table></figure>

<p>示范用法一：</p>
<p>有两中sql模块mysql和oracle，根据用户的输入，选择不同的sql功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mysql.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqlparse</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'from mysql sqlparse'</span>)</span><br><span class="line"><span class="comment">#oracle.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqlparse</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'from oracle sqlparse'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#test.py</span></span><br><span class="line">db_type=input(<span class="string">'&gt;&gt;: '</span>)</span><br><span class="line"><span class="keyword">if</span> db_type == <span class="string">'mysql'</span>:</span><br><span class="line">    <span class="keyword">import</span> mysql <span class="keyword">as</span> db</span><br><span class="line"><span class="keyword">elif</span> db_type == <span class="string">'oracle'</span>:</span><br><span class="line">    <span class="keyword">import</span> oracle <span class="keyword">as</span> db</span><br><span class="line"></span><br><span class="line">db.sqlparse()</span><br></pre></td></tr></table></figure>

<p>示范用法二： </p>
<p>​        为已经导入的模块起别名的方式对编写可扩展的代码很有用，假设有两个模块xmlreader.py和csvreader.py，它们都定义了函数read_data(filename):用来从文件中读取一些数据，但采用不同的输入格式。可以编写代码来选择性地挑选读取模块，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> file_format == <span class="string">'xml'</span>:</span><br><span class="line">     <span class="keyword">import</span> xmlreader <span class="keyword">as</span> reader</span><br><span class="line"><span class="keyword">elif</span> file_format == <span class="string">'csv'</span>:</span><br><span class="line">     <span class="keyword">import</span> csvreader <span class="keyword">as</span> reader</span><br><span class="line">data=reader.read_date(filename)</span><br></pre></td></tr></table></figure>

<p>在一行导入多个模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys,os,re</span><br></pre></td></tr></table></figure>

<h4 id="2、-from-…-import…"><a href="#2、-from-…-import…" class="headerlink" title="2、 from … import…"></a>2、 <strong>from … import…</strong></h4><p>​        对比import my_module，会将源文件的名称空间’my_module’带到当前名称空间中，使用时必须是my_module.名字的方式</p>
<p>​        而from 语句相当于import，也会创建新的名称空间，但是将my_module中的名字直接导入到当前的名称空间中，在当前名称空间中，直接使用名字就可以了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> read1,read2</span><br></pre></td></tr></table></figure>

<p>这样在当前位置直接使用read1和read2就好了，执行时，仍然以my_module.py文件全局名称空间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试一：导入的函数read1，执行时仍然回到my_module.py中寻找全局变量money</span></span><br><span class="line"><span class="comment">#demo.py</span></span><br><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> read1</span><br><span class="line">money=<span class="number">1000</span></span><br><span class="line">read1()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">from the my_module.py</span></span><br><span class="line"><span class="string">spam-&gt;read1-&gt;money 1000</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试二:导入的函数read2，执行时需要调用read1(),仍然回到my_module.py中找read1()</span></span><br><span class="line"><span class="comment">#demo.py</span></span><br><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> read2</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'=========='</span>)</span><br><span class="line">read2()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">from the my_module.py</span></span><br><span class="line"><span class="string">my_module-&gt;read2 calling read1</span></span><br><span class="line"><span class="string">my_module-&gt;read1-&gt;money 1000</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>如果当前有重名read1或者read2，那么会有覆盖效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试三:导入的函数read1，被当前位置定义的read1覆盖掉了</span></span><br><span class="line"><span class="comment">#demo.py</span></span><br><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> read1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'=========='</span>)</span><br><span class="line">read1()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">from the my_module.py</span></span><br><span class="line"><span class="string">==========</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>需要特别强调的一点是：python中的变量赋值不是一种存储操作，而只是一种绑定关系，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> money,read1</span><br><span class="line">money=<span class="number">100</span> <span class="comment">#将当前位置的名字money绑定到了100</span></span><br><span class="line">print(money) <span class="comment">#打印当前的名字</span></span><br><span class="line">read1() <span class="comment">#读取my_module.py中的名字money,仍然为1000</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">from the my_module.py</span></span><br><span class="line"><span class="string">my_module-&gt;read1-&gt;money 1000</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>也支持as</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> read1 <span class="keyword">as</span> read</span><br></pre></td></tr></table></figure>

<p>也支持导入多行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> (read1,</span><br><span class="line">                       read2,</span><br><span class="line">                 			 money)</span><br></pre></td></tr></table></figure>

<p>​        from my_module import * 把my_module中所有的不是以下划线(_)开头的名字都导入到当前位置，大部分情况下我们的python程序不应该使用这种导入方式，因为*你不知道你导入什么名字，很有可能会覆盖掉你之前已经定义的名字。而且可读性极其的差，在交互式环境中导入时没有问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> * <span class="comment">#将模块my_module中所有的名字都导入到当前名称空间</span></span><br><span class="line">print(money)</span><br><span class="line">print(read1)</span><br><span class="line">print(read2)</span><br><span class="line">print(change)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">from the my_module.py</span></span><br><span class="line"><span class="string">&lt;function read1 at 0x1012e8158&gt;</span></span><br><span class="line"><span class="string">&lt;function read2 at 0x1012e81e0&gt;</span></span><br><span class="line"><span class="string">&lt;function change at 0x1012e8268&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>在my_module.py中新增一行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__all__=[<span class="string">'money'</span>,<span class="string">'read1'</span>] <span class="comment">#这样在另外一个文件中用from my_module import *就这能导入列表中规定的两个名字</span></span><br></pre></td></tr></table></figure>

<p><strong>如果my_module.py中的名字前加_,即_money，则from my_module import *,则_money不能被导入</strong></p>
<p><strong>模块的循环引用问题</strong></p>
<p>思考：假如有两个模块a，b。我可不可以在a模块中import b ，再在b模块中import a</p>
<p><strong>模块的加载与修改</strong></p>
<p>​        考虑到性能的原因，每个模块只被导入一次,放入字典sys.modules中，如果你改变了模块的内容，你必须重启程序，python不支持重新加载或卸载之前导入的模块，</p>
<p>​        有的同学可能会想到直接从sys.modules中删除一个模块不就可以卸载了吗，注意了，你删了sys.modules中的模块对象仍然可能被其他程序的组件所引用，因而不会被清除。</p>
<p>​        特别的对于我们引用了这个模块中的一个类，用这个类产生了很多对象，因而这些对象都有关于这个模块的引用。</p>
<p>​        如果只是你想交互测试的一个模块，使用 importlib.reload(), e.g. import importlib; importlib.reload(modulename)，这只能用于测试环境。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># aa.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'func1'</span>)</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time,importlib</span><br><span class="line"><span class="keyword">import</span> aa</span><br><span class="line"> </span><br><span class="line">time.sleep(<span class="number">20</span>)</span><br><span class="line"><span class="comment"># importlib.reload(aa)</span></span><br><span class="line">aa.func1()</span><br></pre></td></tr></table></figure>

<p>在20秒的等待时间里，修改aa.py中func1的内容，等待test.py的结果。</p>
<p>打开importlib注释，重新测试</p>
<h4 id="3、把模块当作脚本运行"><a href="#3、把模块当作脚本运行" class="headerlink" title="3、把模块当作脚本运行"></a>3、把模块当作脚本运行</h4><p>我们可以通过模块的全局变量__name__来查看模块名：<br>当做脚本运行：<br>__name__ 等于’__main__‘</p>
<p>当做模块导入：<br>__name__= 模块名</p>
<p>作用：用来控制.py文件在不同的应用场景下执行不同的逻辑<br>if __name__ == ‘__main__‘:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>   </span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        print(b, end=<span class="string">' '</span>)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(__name__)</span><br><span class="line">    num = input(<span class="string">'num :'</span>)</span><br><span class="line">    fib(int(num))</span><br></pre></td></tr></table></figure>

<h4 id="4、模块搜索路径"><a href="#4、模块搜索路径" class="headerlink" title="4、模块搜索路径"></a>4、模块搜索路径</h4><p>python解释器在启动时会自动加载一些模块，可以使用sys.modules查看</p>
<p>在第一次导入某个模块时（比如my_module），会先检查该模块是否已经被加载到内存中（当前执行文件的名称空间对应的内存），如果有则直接引用</p>
<p>如果没有，解释器则会查找同名的内建模块，如果还没有找到就从sys.path给出的目录列表中依次寻找my_module.py文件。</p>
<p><strong>所以总结模块的查找顺序是：内存中已经加载的模块-&gt;内置模块-&gt;sys.path路径中包含的模块</strong></p>
<p>sys.path的初始化的值来自于：</p>
<p>The directory containing the input script (or the current directory when no file is specified).<br>PYTHONPATH (a list of directory names, with the same syntax as the shell variable PATH).<br>The installation-dependent default.</p>
<p>需要特别注意的是：我们自定义的模块名不应该与系统内置模块重名。虽然每次都说，但是仍然会有人不停的犯错。 </p>
<p>在初始化后，python程序可以修改sys.path,路径放到前面的优先于标准库被加载。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.append(<span class="string">'/a/b/c/d'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.insert(<span class="number">0</span>,<span class="string">'/x/y/z'</span>) <span class="comment">#排在前的目录，优先被搜索</span></span><br></pre></td></tr></table></figure>

<p>​        注意：搜索时按照sys.path中从左到右的顺序查找，位于前的优先被查找，sys.path中还可能包含.zip归档文件和.egg文件，python会把.zip归档文件当成一个目录去处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先制作归档文件：zip module.zip foo.py bar.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'module.zip'</span>)</span><br><span class="line"><span class="keyword">import</span> foo,bar</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以使用zip中目录结构的具体位置</span></span><br><span class="line">sys.path.append(<span class="string">'module.zip/lib/python'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#windows下的路径不加r开头，会语法错误</span></span><br><span class="line">sys.path.insert(<span class="number">0</span>,<span class="string">r'C:\Users\Administrator\PycharmProjects\a'</span>)</span><br></pre></td></tr></table></figure>

<p>​        至于.egg文件是由setuptools创建的包，这是按照第三方python库和扩展时使用的一种常见格式，.egg文件实际上只是添加了额外元数据(如版本号，依赖项等)的.zip文件。</p>
<p>​        需要强调的一点是：只能从.zip文件中导入.py，.pyc等文件。使用C编写的共享库和扩展块无法直接从.zip文件中加载（此时setuptools等打包系统有时能提供一种规避方法），且从.zip中加载文件不会创建.pyc或者.pyo文件，因此一定要事先创建他们，来避免加载模块是性能下降。</p>
<p><strong>官网解释</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#官网链接：https://docs.python.org/3/tutorial/modules.html#the-module-search-path</span><br><span class="line">搜索路径：</span><br><span class="line">当一个命名为my_module的模块被导入时</span><br><span class="line">    解释器首先会从内建模块中寻找该名字</span><br><span class="line">    找不到，则去sys.path中找该名字</span><br><span class="line"></span><br><span class="line">sys.path从以下位置初始化</span><br><span class="line">执行文件所在的当前目录</span><br><span class="line">PTYHONPATH（包含一系列目录名，与shell变量PATH语法一样）</span><br><span class="line">依赖安装时默认指定的</span><br><span class="line"></span><br><span class="line">注意：在支持软连接的文件系统中，执行脚本所在的目录是在软连接之后被计算的，换句话说，包含软连接的目录不会被添加到模块的搜索路径中</span><br><span class="line"></span><br><span class="line">在初始化后，我们也可以在python程序中修改sys.path,执行文件所在的路径默认是sys.path的第一个目录，在所有标准库路径的前面。这意味着，当前目录是优先于标准库目录的，需要强调的是：我们自定义的模块名不要跟python标准库的模块名重复，除非你是故意的，傻叉。</span><br></pre></td></tr></table></figure>

<h4 id="5、编译python文件"><a href="#5、编译python文件" class="headerlink" title="5、编译python文件"></a>5、编译python文件</h4><p>​        为了提高加载模块的速度，强调强调强调：提高的是加载速度而绝非运行速度。python解释器会在<strong>pycache</strong>目录中下缓存每个模块编译后的版本，格式为：module.version.pyc。通常会包含python的版本号。例如，在CPython3.3版本下，    my_module.py模块会被缓存成<strong>pycache</strong>/my_module.cpython-33.pyc。这种命名规范保证了编译后的结果多版本共存。</p>
<p>​        Python检查源文件的修改时间与编译的版本进行对比，如果过期就需要重新编译。这是完全自动的过程。并且编译的模块是平台独立的，所以相同的库可以在不同的架构的系统之间共享，即pyc使一种跨平台的字节码，类似于JAVA火.NET,是由python虚拟机来执行的，但是pyc的内容跟python的版本相关，不同的版本编译后的pyc文件不同，2.5编译的pyc文件不能到3.5上执行，并且pyc文件是可以反编译的，因而它的出现仅仅是用来提升模块的加载速度的。</p>
<p>python解释器在以下两种情况下不检测缓存<br>　　1 如果是在命令行中被直接导入模块，则按照这种方式，每次导入都会重新编译，并且不会存储编译后的结果（python3.3以前的版本应该是这样）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m my_module.py</span><br></pre></td></tr></table></figure>

<p>2 如果源文件不存在，那么缓存的结果也不会被使用，如果想在没有源文件的情况下来使用编译后的结果，则编译后的结果必须在源目录下 </p>
<p>提示：</p>
<p>1.模块名区分大小写，foo.py与FOO.py代表的是两个模块</p>
<p>2.你可以使用-O或者-OO转换python命令来减少编译模块的大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-O转换会帮你去掉assert语句</span><br><span class="line">-OO转换会帮你去掉assert语句和__doc__文档字符串</span><br><span class="line">由于一些程序可能依赖于assert语句或文档字符串，你应该在在确认需要的情况下使用这些选项。</span><br></pre></td></tr></table></figure>

<p>3.在速度上从.pyc文件中读指令来执行不会比从.py文件中读指令执行更快，只有在模块被加载时，.pyc文件才是更快的</p>
<p>4.只有使用import语句是才将文件自动编译为.pyc文件，在命令行或标准输入中指定运行脚本则不会生成这类文件，因而我们可以使用compieall模块为一个目录中的所有模块创建.pyc文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">模块可以作为一个脚本（使用python -m compileall）编译Python源</span><br><span class="line"> </span><br><span class="line">python -m compileall /module_directory 递归着编译</span><br><span class="line">如果使用python -O -m compileall /module_directory -l则只一层</span><br><span class="line"> </span><br><span class="line">命令行里使用compile()函数时，自动使用python -O -m compileall</span><br><span class="line"> </span><br><span class="line">详见：https://docs.python.org/3/library/compileall.html#module-compileall</span><br></pre></td></tr></table></figure>

<h4 id="6、补充：dir-函数"><a href="#6、补充：dir-函数" class="headerlink" title="6、补充：dir() 函数"></a>6、补充：dir() 函数</h4><p>内建函数dir是用来查找模块中定义的名字，返回一个有序字符串列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_module</span><br><span class="line">dir(my_module)</span><br></pre></td></tr></table></figure>

<p>如果没有参数,dir()列举出当前定义的名字</p>
<p>dir()不会列举出内建函数或者变量的名字，它们都被定义到了标准模块builtin中，可以列举出它们，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line">dir(builtins)</span><br></pre></td></tr></table></figure>

<h2 id="（二）包"><a href="#（二）包" class="headerlink" title="（二）包"></a>（二）包</h2><p>包是一种通过使用‘.模块名’来组织python模块名称空间的方式。</p>
<p><strong>１. 无论是import形式还是from…import形式，凡是在导入语句中（而不是在使用时）遇到带点的，都要第一时间提高警觉：这是关于包才有的导入语法</strong></p>
<p><strong>2. 包是目录级的（文件夹级），文件夹是用来组成py文件（包的本质就是一个包含<strong>init</strong>.py文件的目录）</strong></p>
<p><strong>3. import导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的<strong>init</strong>.py，导入包本质就是在导入该文件</strong></p>
<p><strong>强调：</strong></p>
<p>　　<strong>1. 在python3中，即使包下没有<strong>init</strong>.py文件，import 包仍然不会报错，而在python2中，包下一定要有该文件，否则import 包报错</strong></p>
<p>　　<strong>2. 创建包的目的不是为了运行，而是被导入使用，记住，包只是模块的一种形式而已，包即模块</strong></p>
<p>包A和包B下有同名模块也不会冲突，如A.a与B.a来自俩个命名空间</p>
<p>创建目录代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.makedirs(<span class="string">'glance/api'</span>)</span><br><span class="line">os.makedirs(<span class="string">'glance/cmd'</span>)</span><br><span class="line">os.makedirs(<span class="string">'glance/db'</span>)</span><br><span class="line">l = []</span><br><span class="line">l.append(open(<span class="string">'glance/__init__.py'</span>,<span class="string">'w'</span>))</span><br><span class="line">l.append(open(<span class="string">'glance/api/__init__.py'</span>,<span class="string">'w'</span>))</span><br><span class="line">l.append(open(<span class="string">'glance/api/policy.py'</span>,<span class="string">'w'</span>))</span><br><span class="line">l.append(open(<span class="string">'glance/api/versions.py'</span>,<span class="string">'w'</span>))</span><br><span class="line">l.append(open(<span class="string">'glance/cmd/__init__.py'</span>,<span class="string">'w'</span>))</span><br><span class="line">l.append(open(<span class="string">'glance/cmd/manage.py'</span>,<span class="string">'w'</span>))</span><br><span class="line">l.append(open(<span class="string">'glance/db/models.py'</span>,<span class="string">'w'</span>))</span><br><span class="line">map(<span class="keyword">lambda</span> f:f.close() ,l)</span><br></pre></td></tr></table></figure>

<p>目录结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">glance/                   <span class="comment">#Top-level package</span></span><br><span class="line"></span><br><span class="line">├── __init__.py      <span class="comment">#Initialize the glance package</span></span><br><span class="line"></span><br><span class="line">├── api                  <span class="comment">#Subpackage for api</span></span><br><span class="line"></span><br><span class="line">│   ├── __init__.py</span><br><span class="line"></span><br><span class="line">│   ├── policy.py</span><br><span class="line"></span><br><span class="line">│   └── versions.py</span><br><span class="line"></span><br><span class="line">├── cmd                <span class="comment">#Subpackage for cmd</span></span><br><span class="line"></span><br><span class="line">│   ├── __init__.py</span><br><span class="line"></span><br><span class="line">│   └── manage.py</span><br><span class="line"></span><br><span class="line">└── db                  <span class="comment">#Subpackage for db</span></span><br><span class="line"></span><br><span class="line">    ├── __init__.py</span><br><span class="line"></span><br><span class="line">    └── models.py</span><br></pre></td></tr></table></figure>

<p>文件内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#policy.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'from policy.py'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#versions.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_resource</span><span class="params">(conf)</span>:</span></span><br><span class="line">    print(<span class="string">'from version.py: '</span>,conf)</span><br><span class="line"></span><br><span class="line"><span class="comment">#manage.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'from manage.py'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#models.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register_models</span><span class="params">(engine)</span>:</span></span><br><span class="line">    print(<span class="string">'from models.py: '</span>,engine)</span><br></pre></td></tr></table></figure>

<h3 id="一、注意事项"><a href="#一、注意事项" class="headerlink" title="一、注意事项"></a>一、注意事项</h3><p>​        1.关于包相关的导入语句也分为import和from … import …两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，如item.subitem.subsubitem,但都必须遵循这个原则。</p>
<p>​        2.对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。</p>
<p>​        3.对比import item 和from item import name的应用场景：<br>如果我们想直接使用name那必须使用后者。</p>
<h3 id="二、import"><a href="#二、import" class="headerlink" title="二、import"></a>二、import</h3><p>我们在与包glance同级别的文件中测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glance.db.models</span><br><span class="line">glance.db.models.register_models(<span class="string">'mysql'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="三、from-…-import-…"><a href="#三、from-…-import-…" class="headerlink" title="三、from … import …"></a>三、from … import …</h3><p><strong>需要注意的是from后import导入的模块，必须是明确的一个不能带点，否则会有语法错误，如：from a import b.c是错误语法</strong></p>
<p>我们在与包glance同级别的文件中测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> glance.db <span class="keyword">import</span> models</span><br><span class="line">models.register_models(<span class="string">'mysql'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> glance.db.models <span class="keyword">import</span> register_models</span><br><span class="line">register_models(<span class="string">'mysql'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="四、-init-py文件"><a href="#四、-init-py文件" class="headerlink" title="四、__init__.py文件"></a>四、__init__.py文件</h3><p>​        不管是哪种方式，只要是第一次导入包或者是包的任何其他部分，都会依次执行包下的<strong>init</strong>.py文件(我们可以在每个包的文件内都打印一行内容来验证一下)，这个文件可以为空，但是也可以存放一些初始化包的代码。</p>
<h3 id="五、from-glance-api-import"><a href="#五、from-glance-api-import" class="headerlink" title="五、from glance.api import *"></a>五、from glance.api import *</h3><p>​        在讲模块时，我们已经讨论过了从一个模块内导入所有<em>，此处我们研究从一个包导入所有</em>。</p>
<p>​        此处是想从包api中导入所有，实际上该语句只会导入包api下__init__.py文件中定义的名字，我们可以在这个文件中定义__all___:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在__init__.py中定义</span></span><br><span class="line">x=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'from api.__init.py'</span>)</span><br><span class="line"></span><br><span class="line">__all__=[<span class="string">'x'</span>,<span class="string">'func'</span>,<span class="string">'policy'</span>]</span><br></pre></td></tr></table></figure>

<p>此时我们在于glance同级的文件中执行from glance.api import *就导入__all__中的内容（versions仍然不能导入）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">glance/                   </span><br><span class="line"></span><br><span class="line">├── __init__.py      </span><br><span class="line"></span><br><span class="line">├── api                  </span><br><span class="line"></span><br><span class="line">│   ├── __init__.py   __all__ = [<span class="string">'policy'</span>,<span class="string">'versions'</span>] </span><br><span class="line"></span><br><span class="line">│   ├── policy.py</span><br><span class="line"></span><br><span class="line">│   └── versions.py</span><br><span class="line"></span><br><span class="line">├── cmd               __all__ = [<span class="string">'manage'</span>]    </span><br><span class="line"></span><br><span class="line">│   ├── __init__.py</span><br><span class="line"></span><br><span class="line">│   └── manage.py    </span><br><span class="line"></span><br><span class="line">└── db                __all__ = [<span class="string">'models'</span>]              </span><br><span class="line"></span><br><span class="line">    ├── __init__.py</span><br><span class="line"></span><br><span class="line">    └── models.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> glance.api <span class="keyword">import</span> *</span><br><span class="line">policy.get()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> glance.api <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<h3 id="六、绝对导入和相对导入"><a href="#六、绝对导入和相对导入" class="headerlink" title="六、绝对导入和相对导入"></a>六、绝对导入和相对导入</h3><p>​        我们的最顶级包glance是写给别人用的，然后在glance包内部也会有彼此之间互相导入的需求，这时候就有绝对导入和相对导入两种方式：</p>
<p>绝对导入：以glance作为起始</p>
<p>相对导入：用.或者..的方式最为起始（只能在一个包中使用，不能用于不同目录内）</p>
<p>例如：我们在glance/api/version.py中想要导入glance/cmd/manage.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在glance/api/version.py</span><br><span class="line"></span><br><span class="line"><span class="comment">#绝对导入</span></span><br><span class="line"><span class="keyword">from</span> glance.cmd <span class="keyword">import</span> manage</span><br><span class="line">manage.main()</span><br><span class="line"></span><br><span class="line"><span class="comment">#相对导入</span></span><br><span class="line"><span class="keyword">from</span> ..cmd <span class="keyword">import</span> manage</span><br><span class="line">manage.main()</span><br></pre></td></tr></table></figure>

<p>测试结果：注意一定要在于glance同级的文件中测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> glance.api <span class="keyword">import</span> versions</span><br></pre></td></tr></table></figure>

<p>​        注意：在使用pycharm时，有的情况会为你多做一些事情，这是软件相关的东西，会影响你对模块导入的理解，因而在测试时，一定要回到命令行去执行，模拟我们生产环境，你总不能拿着pycharm去上线代码吧！！！</p>
<p>​        <strong>特别需要注意的是：可以用import导入内置或者第三方模块（已经在sys.path中），但是要绝对避免使用import来导入自定义包的子模块(没有在sys.path中)，应该使用from… import …的绝对或者相对导入,且包的相对导入只能用from的形式。</strong></p>
<p>​        比如我们想在glance/api/versions.py中导入glance/api/policy.py，有的同学一抽这俩模块是在同一个目录下，十分开心的就去做了，它直接这么做</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在version.py中</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> policy</span><br><span class="line">policy.get()</span><br></pre></td></tr></table></figure>

<p>​        没错，我们单独运行version.py是一点问题没有的，运行version.py的路径搜索就是从当前路径开始的，于是在导入policy时能在当前目录下找到</p>
<p>​        但是你想啊，你子包中的模块version.py极有可能是被一个glance包同一级别的其他文件导入，比如我们在于glance同级下的一个test.py文件中导入version.py，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> glance.api <span class="keyword">import</span> versions</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">ImportError: No module named 'policy'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">分析:</span></span><br><span class="line"><span class="string">此时我们导入versions在versions.py中执行</span></span><br><span class="line"><span class="string">import policy需要找从sys.path也就是从当前目录找policy.py,</span></span><br><span class="line"><span class="string">这必然是找不到的</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>绝对导入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">glance/                   </span><br><span class="line"></span><br><span class="line">├── __init__.py      <span class="keyword">from</span> glance <span class="keyword">import</span> api</span><br><span class="line">                             <span class="keyword">from</span> glance <span class="keyword">import</span> cmd</span><br><span class="line">                             <span class="keyword">from</span> glance <span class="keyword">import</span> db</span><br><span class="line"></span><br><span class="line">├── api                  </span><br><span class="line"></span><br><span class="line">│   ├── __init__.py  <span class="keyword">from</span> glance.api <span class="keyword">import</span> policy</span><br><span class="line">                              <span class="keyword">from</span> glance.api <span class="keyword">import</span> versions</span><br><span class="line"></span><br><span class="line">│   ├── policy.py</span><br><span class="line"></span><br><span class="line">│   └── versions.py</span><br><span class="line"></span><br><span class="line">├── cmd                 <span class="keyword">from</span> glance.cmd <span class="keyword">import</span> manage</span><br><span class="line"></span><br><span class="line">│   ├── __init__.py</span><br><span class="line"></span><br><span class="line">│   └── manage.py</span><br><span class="line"></span><br><span class="line">└── db                   <span class="keyword">from</span> glance.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">    ├── __init__.py</span><br><span class="line"></span><br><span class="line">    └── models.py</span><br></pre></td></tr></table></figure>

<p>相对导入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">glance/                   </span><br><span class="line"></span><br><span class="line">├── __init__.py      <span class="keyword">from</span> . <span class="keyword">import</span> api  <span class="comment">#.表示当前目录</span></span><br><span class="line">                     <span class="keyword">from</span> . <span class="keyword">import</span> cmd</span><br><span class="line">                     <span class="keyword">from</span> . <span class="keyword">import</span> db</span><br><span class="line"></span><br><span class="line">├── api                  </span><br><span class="line"></span><br><span class="line">│   ├── __init__.py  <span class="keyword">from</span> . <span class="keyword">import</span> policy</span><br><span class="line">                     <span class="keyword">from</span> . <span class="keyword">import</span> versions</span><br><span class="line"></span><br><span class="line">│   ├── policy.py</span><br><span class="line"></span><br><span class="line">│   └── versions.py</span><br><span class="line"></span><br><span class="line">├── cmd              <span class="keyword">from</span> . <span class="keyword">import</span> manage</span><br><span class="line"></span><br><span class="line">│   ├── __init__.py</span><br><span class="line"></span><br><span class="line">│   └── manage.py    <span class="keyword">from</span> ..api <span class="keyword">import</span> policy   </span><br><span class="line">                     <span class="comment">#..表示上一级目录，想再manage中使用policy中的方法就需要回到上一级glance目录往下找api包，从api导入policy</span></span><br><span class="line"></span><br><span class="line">└── db               <span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">    ├── __init__.py</span><br><span class="line"></span><br><span class="line">    └── models.py</span><br></pre></td></tr></table></figure>

<h3 id="七、单独导入包"><a href="#七、单独导入包" class="headerlink" title="七、单独导入包"></a>七、单独导入包</h3><p>单独导入包名称时不会导入包中所有包含的所有子模块，如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在与glance同级的test.py中</span></span><br><span class="line"><span class="keyword">import</span> glance</span><br><span class="line">glance.cmd.manage.main()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果：</span></span><br><span class="line"><span class="string">AttributeError: module 'glance' has no attribute 'cmd'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#glance/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> cmd</span><br><span class="line"> </span><br><span class="line"><span class="comment">#glance/cmd/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> manage</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在于glance同级的test.py中</span></span><br><span class="line"><span class="keyword">import</span> glance</span><br><span class="line">glance.cmd.manage.main()</span><br></pre></td></tr></table></figure>

<p>千万别问：__all__不能解决吗，__all__是用于控制from…import *</p>
<p>import glance之后直接调用模块中的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">glance/                   </span><br><span class="line"></span><br><span class="line">├── __init__.py     <span class="keyword">from</span> .api <span class="keyword">import</span> *</span><br><span class="line">                    <span class="keyword">from</span> .cmd <span class="keyword">import</span> *</span><br><span class="line">                    <span class="keyword">from</span> .db <span class="keyword">import</span> *    </span><br><span class="line">├── api                  </span><br><span class="line"></span><br><span class="line">│   ├── __init__.py   __all__ = [<span class="string">'policy'</span>,<span class="string">'versions'</span>] </span><br><span class="line"></span><br><span class="line">│   ├── policy.py</span><br><span class="line"></span><br><span class="line">│   └── versions.py</span><br><span class="line"></span><br><span class="line">├── cmd               __all__ = [<span class="string">'manage'</span>]    </span><br><span class="line"></span><br><span class="line">│   ├── __init__.py</span><br><span class="line"></span><br><span class="line">│   └── manage.py    </span><br><span class="line"></span><br><span class="line">└── db                __all__ = [<span class="string">'models'</span>]              </span><br><span class="line"></span><br><span class="line">    ├── __init__.py</span><br><span class="line"></span><br><span class="line">    └── models.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> glance</span><br><span class="line">policy.get()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> glance</span><br></pre></td></tr></table></figure>

<h2 id="（三）软件开发规范"><a href="#（三）软件开发规范" class="headerlink" title="（三）软件开发规范"></a>（三）软件开发规范</h2><p><img src="https://images2017.cnblogs.com/blog/827651/201708/827651-20170809105059949-1199069919.png" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#=============&gt;bin目录：存放执行脚本</span></span><br><span class="line"><span class="comment">#start.py</span></span><br><span class="line"><span class="keyword">import</span> sys,os</span><br><span class="line"></span><br><span class="line">BASE_DIR=os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">sys.path.append(BASE_DIR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> core <span class="keyword">import</span> core</span><br><span class="line"><span class="keyword">from</span> conf <span class="keyword">import</span> my_log_settings</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    my_log_settings.load_my_logging_cfg()</span><br><span class="line">    core.run()</span><br><span class="line"></span><br><span class="line"><span class="comment">#=============&gt;conf目录：存放配置文件</span></span><br><span class="line"><span class="comment">#config.ini</span></span><br><span class="line">[DEFAULT]</span><br><span class="line">user_timeout = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">[egon]</span><br><span class="line">password = <span class="number">123</span></span><br><span class="line">money = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">[alex]</span><br><span class="line">password = alex3714</span><br><span class="line">money=<span class="number">10000000000</span></span><br><span class="line"></span><br><span class="line">[yuanhao]</span><br><span class="line">password = ysb123</span><br><span class="line">money=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#settings.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">config_path=<span class="string">r'%s\%s'</span> %(os.path.dirname(os.path.abspath(__file__)),<span class="string">'config.ini'</span>)</span><br><span class="line">user_timeout=<span class="number">10</span></span><br><span class="line">user_db_path=<span class="string">r'%s\%s'</span> %(os.path.dirname(os.path.dirname(os.path.abspath(__file__))),\</span><br><span class="line">                     <span class="string">'db'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#my_log_settings.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">logging配置</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义三种日志输出格式 开始</span></span><br><span class="line"></span><br><span class="line">standard_format = <span class="string">'[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]'</span> \</span><br><span class="line">                  <span class="string">'[%(levelname)s][%(message)s]'</span> <span class="comment">#其中name为getlogger指定的名字</span></span><br><span class="line"></span><br><span class="line">simple_format = <span class="string">'[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s'</span></span><br><span class="line"></span><br><span class="line">id_simple_format = <span class="string">'[%(levelname)s][%(asctime)s] %(message)s'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义日志输出格式 结束</span></span><br><span class="line"></span><br><span class="line">logfile_dir = <span class="string">r'%s\log'</span> %os.path.dirname(os.path.dirname(os.path.abspath(__file__)))  <span class="comment"># log文件的目录</span></span><br><span class="line"></span><br><span class="line">logfile_name = <span class="string">'all2.log'</span>  <span class="comment"># log文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不存在定义的日志目录就创建一个</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(logfile_dir):</span><br><span class="line">    os.mkdir(logfile_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># log文件的全路径</span></span><br><span class="line">logfile_path = os.path.join(logfile_dir, logfile_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># log配置字典</span></span><br><span class="line">LOGGING_DIC = &#123;</span><br><span class="line">    <span class="string">'version'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'disable_existing_loggers'</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">'formatters'</span>: &#123;</span><br><span class="line">        <span class="string">'standard'</span>: &#123;</span><br><span class="line">            <span class="string">'format'</span>: standard_format</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'simple'</span>: &#123;</span><br><span class="line">            <span class="string">'format'</span>: simple_format</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'filters'</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">'handlers'</span>: &#123;</span><br><span class="line">        <span class="comment">#打印到终端的日志</span></span><br><span class="line">        <span class="string">'console'</span>: &#123;</span><br><span class="line">            <span class="string">'level'</span>: <span class="string">'DEBUG'</span>,</span><br><span class="line">            <span class="string">'class'</span>: <span class="string">'logging.StreamHandler'</span>,  <span class="comment"># 打印到屏幕</span></span><br><span class="line">            <span class="string">'formatter'</span>: <span class="string">'simple'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">#打印到文件的日志,收集info及以上的日志</span></span><br><span class="line">        <span class="string">'default'</span>: &#123;</span><br><span class="line">            <span class="string">'level'</span>: <span class="string">'DEBUG'</span>,</span><br><span class="line">            <span class="string">'class'</span>: <span class="string">'logging.handlers.RotatingFileHandler'</span>,  <span class="comment"># 保存到文件</span></span><br><span class="line">            <span class="string">'formatter'</span>: <span class="string">'standard'</span>,</span><br><span class="line">            <span class="string">'filename'</span>: logfile_path,  <span class="comment"># 日志文件</span></span><br><span class="line">            <span class="string">'maxBytes'</span>: <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">5</span>,  <span class="comment"># 日志大小 5M</span></span><br><span class="line">            <span class="string">'backupCount'</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">'encoding'</span>: <span class="string">'utf-8'</span>,  <span class="comment"># 日志文件的编码，再也不用担心中文log乱码了</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'loggers'</span>: &#123;</span><br><span class="line">        <span class="comment">#logging.getLogger(__name__)拿到的logger配置</span></span><br><span class="line">        <span class="string">''</span>: &#123;</span><br><span class="line">            <span class="string">'handlers'</span>: [<span class="string">'default'</span>, <span class="string">'console'</span>],  <span class="comment"># 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕</span></span><br><span class="line">            <span class="string">'level'</span>: <span class="string">'DEBUG'</span>,</span><br><span class="line">            <span class="string">'propagate'</span>: <span class="literal">True</span>,  <span class="comment"># 向上（更高level的logger）传递</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_my_logging_cfg</span><span class="params">()</span>:</span></span><br><span class="line">    logging.config.dictConfig(LOGGING_DIC)  <span class="comment"># 导入上面定义的logging配置</span></span><br><span class="line">    logger = logging.getLogger(__name__)  <span class="comment"># 生成一个log实例</span></span><br><span class="line">    logger.info(<span class="string">'It works!'</span>)  <span class="comment"># 记录该文件的运行状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    load_my_logging_cfg()</span><br><span class="line"></span><br><span class="line"><span class="comment">#=============&gt;core目录：存放核心逻辑</span></span><br><span class="line"><span class="comment">#core.py</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> lib <span class="keyword">import</span> read_ini</span><br><span class="line"></span><br><span class="line">config=read_ini.read(settings.config_path)</span><br><span class="line">logger=logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">current_user=&#123;<span class="string">'user'</span>:<span class="literal">None</span>,<span class="string">'login_time'</span>:<span class="literal">None</span>,<span class="string">'timeout'</span>:int(settings.user_timeout)&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> current_user[<span class="string">'user'</span>]:</span><br><span class="line">            interval=time.time()-current_user[<span class="string">'login_time'</span>]</span><br><span class="line">            <span class="keyword">if</span> interval &lt; current_user[<span class="string">'timeout'</span>]:</span><br><span class="line">                <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">        name = input(<span class="string">'name&gt;&gt;: '</span>)</span><br><span class="line">        password = input(<span class="string">'password&gt;&gt;: '</span>)</span><br><span class="line">        <span class="keyword">if</span> config.has_section(name):</span><br><span class="line">            <span class="keyword">if</span> password == config.get(name,<span class="string">'password'</span>):</span><br><span class="line">                logger.info(<span class="string">'登录成功'</span>)</span><br><span class="line">                current_user[<span class="string">'user'</span>]=name</span><br><span class="line">                current_user[<span class="string">'login_time'</span>]=time.time()</span><br><span class="line">                <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logger.error(<span class="string">'用户名不存在'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'buy...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'''</span></span><br><span class="line"><span class="string">购物</span></span><br><span class="line"><span class="string">查看余额</span></span><br><span class="line"><span class="string">转账</span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        choice = input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> choice:<span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> choice == <span class="string">'1'</span>:</span><br><span class="line">            buy()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br><span class="line"></span><br><span class="line"><span class="comment">#=============&gt;db目录：存放数据库文件</span></span><br><span class="line"><span class="comment">#alex_json</span></span><br><span class="line"><span class="comment">#egon_json</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#=============&gt;lib目录：存放自定义的模块与包</span></span><br><span class="line"><span class="comment">#read_ini.py</span></span><br><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(config_file)</span>:</span></span><br><span class="line">    config=configparser.ConfigParser()</span><br><span class="line">    config.read(config_file)</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line"></span><br><span class="line"><span class="comment">#=============&gt;log目录：存放日志</span></span><br><span class="line"><span class="comment">#all2.log</span></span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">31</span>:<span class="number">40</span>,<span class="number">272</span>][MainThread:<span class="number">11692</span>][task_id:conf.my_log_settings][my_log_settings.py:<span class="number">75</span>][INFO][It works!]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">31</span>:<span class="number">41</span>,<span class="number">789</span>][MainThread:<span class="number">11692</span>][task_id:core.core][core.py:<span class="number">25</span>][ERROR][用户名不存在]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">31</span>:<span class="number">46</span>,<span class="number">394</span>][MainThread:<span class="number">12348</span>][task_id:conf.my_log_settings][my_log_settings.py:<span class="number">75</span>][INFO][It works!]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">31</span>:<span class="number">47</span>,<span class="number">629</span>][MainThread:<span class="number">12348</span>][task_id:core.core][core.py:<span class="number">25</span>][ERROR][用户名不存在]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">31</span>:<span class="number">57</span>,<span class="number">912</span>][MainThread:<span class="number">10528</span>][task_id:conf.my_log_settings][my_log_settings.py:<span class="number">75</span>][INFO][It works!]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">03</span>,<span class="number">340</span>][MainThread:<span class="number">12744</span>][task_id:conf.my_log_settings][my_log_settings.py:<span class="number">75</span>][INFO][It works!]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">05</span>,<span class="number">065</span>][MainThread:<span class="number">12916</span>][task_id:conf.my_log_settings][my_log_settings.py:<span class="number">75</span>][INFO][It works!]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">08</span>,<span class="number">181</span>][MainThread:<span class="number">12916</span>][task_id:core.core][core.py:<span class="number">25</span>][ERROR][用户名不存在]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">13</span>,<span class="number">638</span>][MainThread:<span class="number">7220</span>][task_id:conf.my_log_settings][my_log_settings.py:<span class="number">75</span>][INFO][It works!]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">23</span>,<span class="number">005</span>][MainThread:<span class="number">7220</span>][task_id:core.core][core.py:<span class="number">20</span>][INFO][登录成功]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">40</span>,<span class="number">941</span>][MainThread:<span class="number">7220</span>][task_id:core.core][core.py:<span class="number">20</span>][INFO][登录成功]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">47</span>,<span class="number">222</span>][MainThread:<span class="number">7220</span>][task_id:core.core][core.py:<span class="number">20</span>][INFO][登录成功]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">32</span>:<span class="number">51</span>,<span class="number">949</span>][MainThread:<span class="number">7220</span>][task_id:core.core][core.py:<span class="number">25</span>][ERROR][用户名不存在]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">33</span>:<span class="number">00</span>,<span class="number">213</span>][MainThread:<span class="number">7220</span>][task_id:core.core][core.py:<span class="number">20</span>][INFO][登录成功]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">33</span>:<span class="number">50</span>,<span class="number">118</span>][MainThread:<span class="number">8500</span>][task_id:conf.my_log_settings][my_log_settings.py:<span class="number">75</span>][INFO][It works!]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">33</span>:<span class="number">55</span>,<span class="number">845</span>][MainThread:<span class="number">8500</span>][task_id:core.core][core.py:<span class="number">20</span>][INFO][登录成功]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">34</span>:<span class="number">06</span>,<span class="number">837</span>][MainThread:<span class="number">8500</span>][task_id:core.core][core.py:<span class="number">25</span>][ERROR][用户名不存在]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">34</span>:<span class="number">09</span>,<span class="number">405</span>][MainThread:<span class="number">8500</span>][task_id:core.core][core.py:<span class="number">25</span>][ERROR][用户名不存在]</span><br><span class="line">[<span class="number">2017</span><span class="number">-07</span><span class="number">-29</span> <span class="number">00</span>:<span class="number">34</span>:<span class="number">10</span>,<span class="number">645</span>][MainThread:<span class="number">8500</span>][task_id:core.core][core.py:<span class="number">25</span>][ERROR][用户名不存在]</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/08/python全栈/第01部分：基础+模块+面向对象+网络编程/模块/常用模块（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/08/python全栈/第01部分：基础+模块+面向对象+网络编程/模块/常用模块（二）/" itemprop="url">常用模块（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-08T18:11:31+08:00">
                2019-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-01部分-模块和包/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -01部分 -模块和包</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="（三）常用模块（二）"><a href="#（三）常用模块（二）" class="headerlink" title="（三）常用模块（二）"></a>（三）常用模块（二）</h2><h3 id="一、hashlib模块"><a href="#一、hashlib模块" class="headerlink" title="一、hashlib模块"></a>一、hashlib模块</h3><h4 id="1、算法介绍"><a href="#1、算法介绍" class="headerlink" title="1、算法介绍"></a>1、算法介绍</h4><p>​        Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。</p>
<p>​        什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。</p>
<p>​        摘要算法就是通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是为了发现原始数据是否被人篡改过。</p>
<p>​        摘要算法之所以能指出数据是否被篡改过，就是因为摘要函数是一个单向函数，计算f(data)很容易，但通过digest反推data却非常困难。而且，对原始数据做一个bit的修改，都会导致计算出的摘要完全不同。</p>
<p>我们以常见的摘要算法MD5为例，计算出一个字符串的MD5值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(<span class="string">'how to use md5 in python hashlib?'</span>)</span><br><span class="line"><span class="keyword">print</span> md5.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">计算结果如下：</span></span><br><span class="line"><span class="string">d26a53750bc40b38b65a520292f69306</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>如果数据量很大，可以分块多次调用update()，最后计算的结果是一样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(<span class="string">'how to use md5 in '</span>)</span><br><span class="line">md5.update(<span class="string">'python hashlib?'</span>)</span><br><span class="line"><span class="keyword">print</span> md5.hexdigest()</span><br></pre></td></tr></table></figure>

<p>MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"> </span><br><span class="line">sha1 = hashlib.sha1()</span><br><span class="line">sha1.update(<span class="string">'how to use sha1 in '</span>)</span><br><span class="line">sha1.update(<span class="string">'python hashlib?'</span>)</span><br><span class="line"><span class="keyword">print</span> sha1.hexdigest()</span><br></pre></td></tr></table></figure>

<p>SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法越慢，而且摘要长度更长。</p>
<h4 id="2、摘要算法应用"><a href="#2、摘要算法应用" class="headerlink" title="2、摘要算法应用"></a>2、摘要算法应用</h4><p>任何允许用户登录的网站都会存储用户登录的用户名和口令。如何存储用户名和口令呢？方法是存到数据库表中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name    | password</span><br><span class="line">--------+----------</span><br><span class="line">michael | 123456</span><br><span class="line">bob     | abc999</span><br><span class="line">alice   | alice2008</span><br></pre></td></tr></table></figure>

<p>​        如果以明文保存用户口令，如果数据库泄露，所有用户的口令就落入黑客的手里。此外，网站运维人员是可以访问数据库的，也就是能获取到所有用户的口令。正确的保存口令的方式是不存储用户的明文口令，而是存储用户口令的摘要，比如MD5：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">username | password</span><br><span class="line">---------+---------------------------------</span><br><span class="line">michael  | e10adc3949ba59abbe56e057f20f883e</span><br><span class="line">bob      | 878ef96e86145580c38c87f0410ad153</span><br><span class="line">alice    | 99b1c2188db85afee403b1536010c2c9</span><br></pre></td></tr></table></figure>

<p>​        考虑这么个情况，很多用户喜欢用123456，888888，password这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>: <span class="string">'123456'</span></span><br><span class="line"><span class="string">'21218cca77804d2ba1922c33e0151105'</span>: <span class="string">'888888'</span></span><br><span class="line"><span class="string">'5f4dcc3b5aa765d61d8327deb882cf99'</span>: <span class="string">'password'</span></span><br></pre></td></tr></table></figure>

<p>​        这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。</p>
<p>​        对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？</p>
<p>​        由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashlib.md5(<span class="string">"salt"</span>.encode(<span class="string">"utf8"</span>))</span><br></pre></td></tr></table></figure>

<p>​        经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。</p>
<p>​        但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？</p>
<p>​        如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。</p>
<p>​        摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。</p>
<h3 id="二、configparser模块"><a href="#二、configparser模块" class="headerlink" title="二、configparser模块"></a>二、configparser模块</h3><p>​        该模块适用于配置文件的格式与windows ini文件类似，可以包含一个或多个节（section），每个节可以有多个参数（键=值）。</p>
<h4 id="1、创建文件"><a href="#1、创建文件" class="headerlink" title="1、创建文件"></a>1、创建文件</h4><p><strong>来看一个好多软件的常见文档格式如下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">ServerAliveInterval = <span class="number">45</span></span><br><span class="line">Compression = yes</span><br><span class="line">CompressionLevel = <span class="number">9</span></span><br><span class="line">ForwardX11 = yes</span><br><span class="line">  </span><br><span class="line">[bitbucket.org]</span><br><span class="line">User = hg</span><br><span class="line">  </span><br><span class="line">[topsecret.server.com]</span><br><span class="line">Port = <span class="number">50022</span></span><br><span class="line">ForwardX11 = no</span><br></pre></td></tr></table></figure>

<p>如果想用python生成一个这样的文档怎么做呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config[<span class="string">"DEFAULT"</span>] = &#123;<span class="string">'ServerAliveInterval'</span>: <span class="string">'45'</span>,</span><br><span class="line">                      <span class="string">'Compression'</span>: <span class="string">'yes'</span>,</span><br><span class="line">                     <span class="string">'CompressionLevel'</span>: <span class="string">'9'</span>,</span><br><span class="line">                     <span class="string">'ForwardX11'</span>:<span class="string">'yes'</span></span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">config[<span class="string">'bitbucket.org'</span>] = &#123;<span class="string">'User'</span>:<span class="string">'hg'</span>&#125;</span><br><span class="line"></span><br><span class="line">config[<span class="string">'topsecret.server.com'</span>] = &#123;<span class="string">'Host Port'</span>:<span class="string">'50022'</span>,<span class="string">'ForwardX11'</span>:<span class="string">'no'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'example.ini'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> configfile:</span><br><span class="line"></span><br><span class="line">   config.write(configfile)</span><br></pre></td></tr></table></figure>

<h4 id="2、查找文件"><a href="#2、查找文件" class="headerlink" title="2、查找文件"></a>2、查找文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------查找文件内容,基于字典的形式</span></span><br><span class="line"></span><br><span class="line">print(config.sections())        <span class="comment">#  []</span></span><br><span class="line"></span><br><span class="line">config.read(<span class="string">'example.ini'</span>)</span><br><span class="line"></span><br><span class="line">print(config.sections())        <span class="comment">#   ['bitbucket.org', 'topsecret.server.com']</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'bytebong.com'</span> <span class="keyword">in</span> config) <span class="comment"># False</span></span><br><span class="line">print(<span class="string">'bitbucket.org'</span> <span class="keyword">in</span> config) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(config[<span class="string">'bitbucket.org'</span>][<span class="string">"user"</span>])  <span class="comment"># hg</span></span><br><span class="line"></span><br><span class="line">print(config[<span class="string">'DEFAULT'</span>][<span class="string">'Compression'</span>]) <span class="comment">#yes</span></span><br><span class="line"></span><br><span class="line">print(config[<span class="string">'topsecret.server.com'</span>][<span class="string">'ForwardX11'</span>])  <span class="comment">#no</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(config[<span class="string">'bitbucket.org'</span>])          <span class="comment">#&lt;Section: bitbucket.org&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> config[<span class="string">'bitbucket.org'</span>]:     <span class="comment"># 注意,有default会默认default的键</span></span><br><span class="line">    print(key)</span><br><span class="line"></span><br><span class="line">print(config.options(<span class="string">'bitbucket.org'</span>))  <span class="comment"># 同for循环,找到'bitbucket.org'下所有键</span></span><br><span class="line"></span><br><span class="line">print(config.items(<span class="string">'bitbucket.org'</span>))    <span class="comment">#找到'bitbucket.org'下所有键值对</span></span><br><span class="line"></span><br><span class="line">print(config.get(<span class="string">'bitbucket.org'</span>,<span class="string">'compression'</span>)) <span class="comment"># yes       get方法Section下的key对应的value</span></span><br></pre></td></tr></table></figure>

<h4 id="3、增删改操作"><a href="#3、增删改操作" class="headerlink" title="3、增删改操作"></a>3、增删改操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">'example.ini'</span>)</span><br><span class="line"></span><br><span class="line">config.add_section(<span class="string">'yuan'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config.remove_section(<span class="string">'bitbucket.org'</span>)</span><br><span class="line">config.remove_option(<span class="string">'topsecret.server.com'</span>,<span class="string">"forwardx11"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config.set(<span class="string">'topsecret.server.com'</span>,<span class="string">'k1'</span>,<span class="string">'11111'</span>)</span><br><span class="line">config.set(<span class="string">'yuan'</span>,<span class="string">'k2'</span>,<span class="string">'22222'</span>)</span><br><span class="line"></span><br><span class="line">config.write(open(<span class="string">'new2.ini'</span>, <span class="string">"w"</span>))</span><br></pre></td></tr></table></figure>

<h3 id="三、logging模块"><a href="#三、logging模块" class="headerlink" title="三、logging模块"></a>三、logging模块</h3><h4 id="1、函数式简单配置"><a href="#1、函数式简单配置" class="headerlink" title="1、函数式简单配置"></a>1、函数式简单配置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line">logging.debug(<span class="string">'debug message'</span>)  </span><br><span class="line">logging.info(<span class="string">'info message'</span>)  </span><br><span class="line">logging.warning(<span class="string">'warning message'</span>)  </span><br><span class="line">logging.error(<span class="string">'error message'</span>)  </span><br><span class="line">logging.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure>

<p>默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG），默认的日志格式为日志级别：Logger名称：用户输出消息。</p>
<p><strong>灵活配置日志级别，日志格式，输出位置:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">file_handler = logging.FileHandler(filename=<span class="string">'x1.log'</span>, mode=<span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>,)</span><br><span class="line">logging.basicConfig(</span><br><span class="line">    format=<span class="string">'%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s'</span>,</span><br><span class="line">    datefmt=<span class="string">'%Y-%m-%d %H:%M:%S %p'</span>,</span><br><span class="line">    handlers=[file_handler,],</span><br><span class="line">    level=logging.ERROR</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">logging.error(<span class="string">'你好'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>日志切割</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> logging <span class="keyword">import</span> handlers</span><br><span class="line"></span><br><span class="line">sh = logging.StreamHandler()</span><br><span class="line">rh = handlers.RotatingFileHandler(<span class="string">'myapp.log'</span>, maxBytes=<span class="number">1024</span>,backupCount=<span class="number">5</span>)</span><br><span class="line">fh = handlers.TimedRotatingFileHandler(filename=<span class="string">'x2.log'</span>, when=<span class="string">'s'</span>, interval=<span class="number">5</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">logging.basicConfig(</span><br><span class="line">    format=<span class="string">'%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s'</span>,</span><br><span class="line">    datefmt=<span class="string">'%Y-%m-%d %H:%M:%S %p'</span>,</span><br><span class="line">    handlers=[fh,sh,rh],</span><br><span class="line">    level=logging.ERROR</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">100000</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    logging.error(<span class="string">'KeyboardInterrupt error %s'</span>%str(i))</span><br></pre></td></tr></table></figure>

<p><strong>配置参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有：</span><br><span class="line"></span><br><span class="line">filename：用指定的文件名创建FiledHandler，这样日志会被存储在指定的文件中。</span><br><span class="line">filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。</span><br><span class="line">format：指定handler使用的日志显示格式。</span><br><span class="line">datefmt：指定日期时间格式。</span><br><span class="line">level：设置rootlogger（后边会讲解具体概念）的日志级别</span><br><span class="line">stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open(‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。</span><br><span class="line"></span><br><span class="line">format参数中可能用到的格式化串：</span><br><span class="line">%(name)s Logger的名字</span><br><span class="line">%(levelno)s 数字形式的日志级别</span><br><span class="line">%(levelname)s 文本形式的日志级别</span><br><span class="line">%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有</span><br><span class="line">%(filename)s 调用日志输出函数的模块的文件名</span><br><span class="line">%(module)s 调用日志输出函数的模块名</span><br><span class="line">%(funcName)s 调用日志输出函数的函数名</span><br><span class="line">%(lineno)d 调用日志输出函数的语句所在的代码行</span><br><span class="line">%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示</span><br><span class="line">%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数</span><br><span class="line">%(asctime)s 字符串形式的当前时间。默认格式是 “<span class="number">2003</span><span class="number">-07</span><span class="number">-08</span> <span class="number">16</span>:<span class="number">49</span>:<span class="number">45</span>,<span class="number">896</span>”。逗号后面的是毫秒</span><br><span class="line">%(thread)d 线程ID。可能没有</span><br><span class="line">%(threadName)s 线程名。可能没有</span><br><span class="line">%(process)d 进程ID。可能没有</span><br><span class="line">%(message)s用户输出的消息</span><br></pre></td></tr></table></figure>

<h4 id="2、logger对象配置"><a href="#2、logger对象配置" class="headerlink" title="2、logger对象配置"></a>2、logger对象配置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line"><span class="comment"># 创建一个handler，用于写入日志文件</span></span><br><span class="line">fh = logging.FileHandler(<span class="string">'test.log'</span>,encoding=<span class="string">'utf-8'</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 再创建一个handler，用于输出到控制台 </span></span><br><span class="line">ch = logging.StreamHandler() </span><br><span class="line">formatter = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line"></span><br><span class="line">fh.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">fh.setFormatter(formatter) </span><br><span class="line">ch.setFormatter(formatter) </span><br><span class="line">logger.addHandler(fh) <span class="comment">#logger对象可以添加多个fh和ch对象 </span></span><br><span class="line">logger.addHandler(ch) </span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">'logger debug message'</span>) </span><br><span class="line">logger.info(<span class="string">'logger info message'</span>) </span><br><span class="line">logger.warning(<span class="string">'logger warning message'</span>) </span><br><span class="line">logger.error(<span class="string">'logger error message'</span>) </span><br><span class="line">logger.critical(<span class="string">'logger critical message'</span>)</span><br></pre></td></tr></table></figure>

<p>​        logging库提供了多个组件：Logger、Handler、Filter、Formatter。Logger对象提供应用程序可直接使用的接口，Handler发送日志到适当的目的地，Filter提供了过滤日志信息的方法，Formatter指定日志显示格式。另外，可以通过：</p>
<p>logger.setLevel(logging.Debug)设置级别,</p>
<p>当然，也可以通过</p>
<p>fh.setLevel(logging.Debug)单对文件流设置某个级别。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/08/python全栈/第02部分：并发编程+数据库+前端/并发编程/线程（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/08/python全栈/第02部分：并发编程+数据库+前端/并发编程/线程（二）/" itemprop="url">线程（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-08T07:39:55+08:00">
                2019-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-02部分-并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -02部分 -并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="（二）线程和python"><a href="#（二）线程和python" class="headerlink" title="（二）线程和python"></a>（二）线程和python</h2><h3 id="一、理论知识"><a href="#一、理论知识" class="headerlink" title="一、理论知识"></a>一、理论知识</h3><h4 id="1、全局解释器锁GIL（Cpython解释器下）"><a href="#1、全局解释器锁GIL（Cpython解释器下）" class="headerlink" title="1、全局解释器锁GIL（Cpython解释器下）"></a>1、全局解释器锁GIL（Cpython解释器下）</h4><p>​        Python代码的执行由Python虚拟机(也叫解释器主循环)来控制。Python在设计之初就考虑到要在主循环中，同时只有一个线程在执行。虽然 Python 解释器中可以“运行”多个线程，但在任意时刻只有一个线程在解释器中运行。<br>　　对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。</p>
<p>　　在多线程环境中，Python 虚拟机按以下方式执行：</p>
<p>　　a、设置 GIL；</p>
<p>　　b、切换到一个线程去运行；</p>
<p>　　c、运行指定数量的字节码指令或者线程主动让出控制(可以调用 time.sleep(0))；</p>
<p>　　d、把线程设置为睡眠状态；</p>
<p>　　e、解锁 GIL；</p>
<p>　　d、再次重复以上所有步骤。<br>　　在调用外部代码(如 C/C++扩展函数)的时候，GIL将会被锁定，直到这个函数结束为止(由于在这期间没有Python的字节码被运行，所以不会做线程切换)编写扩展的程序员可以主动解锁GIL。</p>
<h4 id="2、python线程模块的选择"><a href="#2、python线程模块的选择" class="headerlink" title="2、python线程模块的选择"></a>2、python线程模块的选择</h4><p>​        Python提供了几个用于多线程编程的模块，包括thread、threading和Queue等。thread和threading模块允许程序员创建和管理线程。thread模块提供了基本的线程和锁的支持，threading提供了更高级别、功能更强的线程管理的功能。Queue模块允许用户创建一个可以用于多个线程之间共享数据的队列数据结构。<br>　　避免使用thread模块，因为更高级别的threading模块更为先进，对线程的支持更为完善，而且使用thread模块里的属性有可能会与threading出现冲突；其次低级别的thread模块的同步原语很少(实际上只有一个)，而threading模块则有很多；再者，thread模块中当主线程结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作，至少threading模块能确保重要的子线程退出后进程才退出。 </p>
<p>　　thread模块不支持守护线程，当主线程退出时，所有的子线程不论它们是否还在工作，都会被强行退出。而threading模块支持守护线程，守护线程一般是一个等待客户请求的服务器，如果没有客户提出请求它就在那等着，如果设定一个线程为守护线程，就表示这个线程是不重要的，在进程退出的时候，不用等待这个线程退出。</p>
<h3 id="二、threading模块"><a href="#二、threading模块" class="headerlink" title="二、threading模块"></a>二、threading模块</h3><p>multiprocess模块的完全模仿了threading模块的接口，二者在使用层面，有很大的相似性，因而不再详细介绍（<a href="https://docs.python.org/3/library/threading.html?highlight=threading#" target="_blank" rel="noopener">官方链接</a>）</p>
<h4 id="1、线程的创建-Threading-Thread类"><a href="#1、线程的创建-Threading-Thread类" class="headerlink" title="1、线程的创建 Threading.Thread类"></a>1、线程的创建 Threading.Thread类</h4><h5 id="（1）线程的创建"><a href="#（1）线程的创建" class="headerlink" title="（1）线程的创建"></a>（1）线程的创建</h5><p>创建线程的方式1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = Thread(target=func, args=(i,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<p>创建线程的方式2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.arg = arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(self.arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = MyTread(i)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<h5 id="（2）多线程与多进程"><a href="#（2）多线程与多进程" class="headerlink" title="（2）多线程与多进程"></a>（2）多线程与多进程</h5><p>pid的比较</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>,os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#part1:在主进程下开启多个线程,每个线程都跟主进程的pid一样</span></span><br><span class="line">    t1=Thread(target=work)</span><br><span class="line">    t2=Thread(target=work)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程pid'</span>,os.getpid())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#part2:开多个进程,每个进程都有不同的pid</span></span><br><span class="line">    p1=Process(target=work)</span><br><span class="line">    p2=Process(target=work)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    print(<span class="string">'主线程/主进程pid'</span>,os.getpid())</span><br></pre></td></tr></table></figure>

<p>开启效率的较量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    t_lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=func,args=(i,))</span><br><span class="line">        t.start()</span><br><span class="line">        t_lst.append(t)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> t_lst:t.join()</span><br><span class="line">    t1 = time.time() - start</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    t_lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t = Process(target=func, args=(i,))</span><br><span class="line">        t.start()</span><br><span class="line">        t_lst.append(t)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> t_lst: t.join()</span><br><span class="line">    t2 = time.time() - start</span><br><span class="line">    print(t1,t2)</span><br></pre></td></tr></table></figure>

<p>内存数据的共享问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g</span><br><span class="line">    g = <span class="number">0</span></span><br><span class="line">    print(g,os.getpid())</span><br><span class="line"></span><br><span class="line">g = <span class="number">100</span></span><br><span class="line">t_lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = Thread(target=func,args=(i,<span class="number">5</span>))</span><br><span class="line">    t.start()</span><br><span class="line">    t_lst.append(t)</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span>  t_lst : t.join()</span><br><span class="line">print(g)</span><br></pre></td></tr></table></figure>

<h5 id="（3）练习：多线程实现socket"><a href="#（3）练习：多线程实现socket" class="headerlink" title="（3）练习：多线程实现socket"></a>（3）练习：多线程实现socket</h5><p>server</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        print(data)</span><br><span class="line">        conn.send(data.upper())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn,addr=s.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        p=threading.Thread(target=action,args=(conn,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>client</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    data=s.recv(<span class="number">1024</span>)</span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure>

<h5 id="（4）Thread类的其他方法"><a href="#（4）Thread类的其他方法" class="headerlink" title="（4）Thread类的其他方法"></a>（4）Thread类的其他方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread实例对象的方法</span><br><span class="line">  <span class="comment"># isAlive(): 返回线程是否活动的。</span></span><br><span class="line">  <span class="comment"># getName(): 返回线程名。</span></span><br><span class="line">  <span class="comment"># setName(): 设置线程名。</span></span><br><span class="line"></span><br><span class="line">threading模块提供的一些方法：</span><br><span class="line">  <span class="comment"># threading.currentThread(): 返回当前的线程变量。</span></span><br><span class="line">  <span class="comment"># threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</span></span><br><span class="line">  <span class="comment"># threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</span></span><br></pre></td></tr></table></figure>

<p>代码示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wahaha</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(n,threading.current_thread(),threading.get_ident())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>  range(<span class="number">10</span>):</span><br><span class="line">    threading.Thread(target=wahaha,args=(i,)).start()</span><br><span class="line">print(threading.active_count())    <span class="comment"># 10</span></span><br><span class="line">print(threading.current_thread())</span><br><span class="line">print(threading.enumerate())</span><br></pre></td></tr></table></figure>

<p>join方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(name)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'%s say hello'</span> %name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t=Thread(target=sayhi,args=(<span class="string">'egon'</span>,))</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    print(<span class="string">'主线程'</span>)</span><br><span class="line">    print(t.is_alive())</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    egon say hello</span></span><br><span class="line"><span class="string">    主线程</span></span><br><span class="line"><span class="string">    False</span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></table></figure>

<h5 id="（5）守护线程"><a href="#（5）守护线程" class="headerlink" title="（5）守护线程"></a>（5）守护线程</h5><p><strong>无论是进程还是线程，都遵循：守护xx会等待主xx运行完毕后被销毁。</strong></p>
<p><strong>需要强调的是：运行完毕并非终止运行</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.对主进程来说，运行完毕指的是主进程代码运行完毕</span></span><br><span class="line"><span class="comment">#2.对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕（其实 主线程会等待子线程的结束）</span></span><br></pre></td></tr></table></figure>

<p>详细解释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束，</span></span><br><span class="line"><span class="comment">#2 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。</span></span><br></pre></td></tr></table></figure>

<p>守护线程例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time                 </span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span>                </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:             </span><br><span class="line">        print(<span class="string">'*'</span>*<span class="number">10</span>)       </span><br><span class="line">        time.sleep(<span class="number">1</span>)       </span><br><span class="line">                            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span>                </span><br><span class="line">    print(<span class="string">'in func2'</span>)       </span><br><span class="line">    time.sleep(<span class="number">5</span>)           </span><br><span class="line">                            </span><br><span class="line">t = Thread(target=func1,)   </span><br><span class="line">t.daemon = <span class="literal">True</span>             </span><br><span class="line">t.start()                   </span><br><span class="line">t2 = Thread(target=func2,)  </span><br><span class="line">t2.start()                  </span><br><span class="line"><span class="comment"># t2.join()                 </span></span><br><span class="line">print(<span class="string">'主线程'</span>)                </span><br><span class="line">                            </span><br><span class="line"><span class="comment"># 守护进程随着主进程代码的执行结束而结束       </span></span><br><span class="line"><span class="comment"># 守护线程会在主线程结束之后等待其他子线程的结束才结束</span></span><br></pre></td></tr></table></figure>

<h4 id="2、锁"><a href="#2、锁" class="headerlink" title="2、锁"></a>2、锁</h4><h5 id="（1）、锁与GIL"><a href="#（1）、锁与GIL" class="headerlink" title="（1）、锁与GIL"></a>（1）、锁与GIL</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程</span><br><span class="line">    线程是进程中的执行单位</span><br><span class="line">    线程是cpu执行的最小单位</span><br><span class="line">    线城之间资源共享</span><br><span class="line">    线程的开启和关闭以及切换的时间开销远远小于进程</span><br><span class="line">    线程本身可以在同一时间使用多个cpu</span><br><span class="line">python 与 线程</span><br><span class="line">    Cpython解释器在解释代码过程中容易产生数据不安全的问题</span><br><span class="line">    GIL 全局解释器锁 锁的是线程</span><br></pre></td></tr></table></figure>

<h5 id="（2）、同步锁"><a href="#（2）、同步锁" class="headerlink" title="（2）、同步锁"></a>（2）、同步锁</h5><p>多个线程抢占资源的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    temp=n</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)	<span class="comment"># 此处通过sleep阻断了GIL锁（模拟时间片的切换）</span></span><br><span class="line">    <span class="comment"># 虽然此处注释该语句，结果为0，但不能否认的是，有可能时间片的切换强制该线程还钥匙，计算的结果还没来得及放回</span></span><br><span class="line">    <span class="comment"># 这就是为什么有了GIL锁，数据还是不能保证彻底安全</span></span><br><span class="line">    n=temp<span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n=<span class="number">100</span></span><br><span class="line">    l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        p=Thread(target=work)</span><br><span class="line">        l.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> l:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    print(n) <span class="comment">#结果可能为99</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">R=threading.Lock()</span><br><span class="line">R.acquire()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">对公共数据的操作</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">R.release()</span><br></pre></td></tr></table></figure>

<p>同步锁的引用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    lock.acquire()</span><br><span class="line">    temp=n</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    n=temp<span class="number">-1</span></span><br><span class="line">    lock.release()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock=Lock()</span><br><span class="line">    n=<span class="number">100</span></span><br><span class="line">    l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        p=Thread(target=work)</span><br><span class="line">        l.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> l:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    print(n) <span class="comment">#结果肯定为0，由原来的并发执行变成串行，牺牲了执行效率保证了数据安全</span></span><br></pre></td></tr></table></figure>

<p>互斥锁与join的区别</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不加锁:并发执行,速度快,数据不安全</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread,Thread,Lock</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    print(<span class="string">'%s is running'</span> %current_thread().getName())</span><br><span class="line">    temp=n</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    n=temp<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n=<span class="number">100</span></span><br><span class="line">    lock=Lock()</span><br><span class="line">    threads=[]</span><br><span class="line">    start_time=time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t=Thread(target=task)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    stop_time=time.time()</span><br><span class="line">    print(<span class="string">'主:%s n:%s'</span> %(stop_time-start_time,n))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Thread-1 is running</span></span><br><span class="line"><span class="string">Thread-2 is running</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">Thread-100 is running</span></span><br><span class="line"><span class="string">主:0.5216062068939209 n:99</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#不加锁:未加锁部分并发执行,加锁部分串行执行,速度慢,数据安全</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread,Thread,Lock</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#未加锁的代码并发运行</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'%s start to run'</span> %current_thread().getName())</span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    <span class="comment">#加锁的代码串行运行</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    temp=n</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    n=temp<span class="number">-1</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n=<span class="number">100</span></span><br><span class="line">    lock=Lock()</span><br><span class="line">    threads=[]</span><br><span class="line">    start_time=time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t=Thread(target=task)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    stop_time=time.time()</span><br><span class="line">    print(<span class="string">'主:%s n:%s'</span> %(stop_time-start_time,n))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Thread-1 is running</span></span><br><span class="line"><span class="string">Thread-2 is running</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">Thread-100 is running</span></span><br><span class="line"><span class="string">主:53.294203758239746 n:0</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#有的同学可能有疑问:既然加锁会让运行变成串行,那么我在start之后立即使用join,就不用加锁了啊,也是串行的效果啊</span></span><br><span class="line"><span class="comment">#没错:在start之后立刻使用jion,肯定会将100个任务的执行变成串行,毫无疑问,最终n的结果也肯定是0,是安全的,但问题是</span></span><br><span class="line"><span class="comment">#start后立即join:任务内的所有代码都是串行执行的,而加锁,只是加锁的部分即修改共享数据的部分是串行的</span></span><br><span class="line"><span class="comment">#单从保证数据安全方面,二者都可以实现,但很明显是加锁的效率更高.</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread,Thread,Lock</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'%s start to run'</span> %current_thread().getName())</span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    temp=n</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    n=temp<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n=<span class="number">100</span></span><br><span class="line">    lock=Lock()</span><br><span class="line">    start_time=time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t=Thread(target=task)</span><br><span class="line">        t.start()</span><br><span class="line">        t.join()</span><br><span class="line">    stop_time=time.time()</span><br><span class="line">    print(<span class="string">'主:%s n:%s'</span> %(stop_time-start_time,n))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Thread-1 start to run</span></span><br><span class="line"><span class="string">Thread-2 start to run</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">Thread-100 start to run</span></span><br><span class="line"><span class="string">主:350.6937336921692 n:0 #耗时是多么的恐怖</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">）</span><br></pre></td></tr></table></figure>

<h5 id="（3）死锁与递归锁"><a href="#（3）死锁与递归锁" class="headerlink" title="（3）死锁与递归锁"></a>（3）死锁与递归锁</h5><p>进程也有死锁与递归锁，在进程那里忘记说了，放到这里一切说了额</p>
<p>所谓死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，如下就是死锁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock <span class="keyword">as</span> Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">mutexA=Lock()</span><br><span class="line">mutexA.acquire()</span><br><span class="line">mutexA.acquire()</span><br><span class="line">print(<span class="number">123</span>)</span><br><span class="line">mutexA.release()</span><br><span class="line">mutexA.release()</span><br></pre></td></tr></table></figure>

<p>解决方法，递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。</p>
<p>这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> RLock <span class="keyword">as</span> Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">mutexA=Lock()</span><br><span class="line">mutexA.acquire()</span><br><span class="line">mutexA.acquire()</span><br><span class="line">print(<span class="number">123</span>)</span><br><span class="line">mutexA.release()</span><br><span class="line">mutexA.release()</span><br></pre></td></tr></table></figure>

<p>典型问题：科学家吃面</p>
<p>死锁问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock,Thread</span><br><span class="line">noodle_lock  = Lock()		<span class="comment"># 互斥锁</span></span><br><span class="line">fork_lock = Lock()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat1</span><span class="params">(name)</span>:</span></span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span>%name)</span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span>%name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span>%name)</span><br><span class="line">    fork_lock.release()</span><br><span class="line">    noodle_lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat2</span><span class="params">(name)</span>:</span></span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span>%name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)   <span class="comment"># 产生死锁</span></span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span>%name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span>%name)</span><br><span class="line">    noodle_lock.release()</span><br><span class="line">    fork_lock.release()</span><br><span class="line"></span><br><span class="line">Thread(target=eat1,args=(<span class="string">'alex'</span>,)).start()</span><br><span class="line">Thread(target=eat2,args=(<span class="string">'Egon'</span>,)).start()</span><br><span class="line">Thread(target=eat1,args=(<span class="string">'bossjin'</span>,)).start()</span><br><span class="line">Thread(target=eat2,args=(<span class="string">'nezha'</span>,)).start()</span><br></pre></td></tr></table></figure>

<p>递归锁解决死锁问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,RLock   <span class="comment"># 递归锁</span></span><br><span class="line">fork_lock = noodle_lock  = RLock()   <span class="comment"># 一个钥匙串上的两把钥匙，拿到一个钥匙即意味着拿到了一串钥匙</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat1</span><span class="params">(name)</span>:</span></span><br><span class="line">    noodle_lock.acquire()            <span class="comment"># 一把钥匙</span></span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span>%name)</span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span>%name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span>%name)</span><br><span class="line">    fork_lock.release()</span><br><span class="line">    noodle_lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat2</span><span class="params">(name)</span>:</span></span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到叉子了'</span>%name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">'%s拿到面条啦'</span>%name)</span><br><span class="line">    print(<span class="string">'%s吃面'</span>%name)</span><br><span class="line">    noodle_lock.release()</span><br><span class="line">    fork_lock.release()</span><br><span class="line"></span><br><span class="line">Thread(target=eat1,args=(<span class="string">'alex'</span>,)).start()</span><br><span class="line">Thread(target=eat2,args=(<span class="string">'Egon'</span>,)).start()</span><br><span class="line">Thread(target=eat1,args=(<span class="string">'bossjin'</span>,)).start()</span><br><span class="line">Thread(target=eat2,args=(<span class="string">'nezha'</span>,)).start()</span><br></pre></td></tr></table></figure>

<h4 id="3、信号量"><a href="#3、信号量" class="headerlink" title="3、信号量"></a>3、信号量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Semaphore,Thread</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(sem,a,b)</span>:</span></span><br><span class="line">    sem.acquire()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(a+b)</span><br><span class="line">    sem.release()</span><br><span class="line"></span><br><span class="line">sem = Semaphore(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = Thread(target=func,args=(sem,i,i+<span class="number">5</span>))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<h4 id="4、事件"><a href="#4、事件" class="headerlink" title="4、事件"></a>4、事件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Event</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect_db</span><span class="params">(e)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line">        e.wait(<span class="number">0.5</span>)   <span class="comment"># 状态为False的时候,我只等待1s就结束</span></span><br><span class="line">        <span class="keyword">if</span> e.is_set() == <span class="literal">True</span>:</span><br><span class="line">            print(<span class="string">'连接数据库'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            print(<span class="string">'第%s次连接失败'</span>%count)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TimeoutError(<span class="string">'数据库连接超时'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_web</span><span class="params">(e)</span>:</span></span><br><span class="line">    time.sleep(random.randint(<span class="number">0</span>,<span class="number">3</span>))</span><br><span class="line">    e.set()</span><br><span class="line"></span><br><span class="line">e = Event()</span><br><span class="line">t1 = Thread(target=connect_db,args=(e,))</span><br><span class="line">t2 = Thread(target=check_web,args=(e,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>

<h4 id="5、条件"><a href="#5、条件" class="headerlink" title="5、条件"></a>5、条件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Condition</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(con,i)</span>:</span></span><br><span class="line">    con.acquire()</span><br><span class="line">    con.wait() <span class="comment"># 等钥匙</span></span><br><span class="line">    print(<span class="string">'在第%s个循环里'</span>%i)</span><br><span class="line">    con.release()</span><br><span class="line">con = Condition()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    Thread(target=func,args = (con,i)).start()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    num = int(input(<span class="string">'&gt;&gt;&gt;'</span>))</span><br><span class="line">    con.acquire()</span><br><span class="line">    con.notify(num)  <span class="comment"># 造钥匙</span></span><br><span class="line">    con.release()</span><br></pre></td></tr></table></figure>

<h4 id="6、定时器"><a href="#6、定时器" class="headerlink" title="6、定时器"></a>6、定时器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'时间同步'</span>)   <span class="comment">#1-3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    t = Timer(<span class="number">5</span>,func).start()   <span class="comment"># 非阻塞的</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h4 id="7、线程队列"><a href="#7、线程队列" class="headerlink" title="7、线程队列"></a>7、线程队列</h4><p>queue队列 ：使用import queue，用法与进程Queue一样</p>
<p>queue is especially useful in threaded programming when information must be exchanged safely between multiple threads.</p>
<ul>
<li><p><strong>class queue.Queue(maxsize=0) #先进先出</strong></p>
<p>先进先出:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q=queue.Queue()</span><br><span class="line">q.put(<span class="string">'first'</span>)</span><br><span class="line">q.put(<span class="string">'second'</span>)</span><br><span class="line">q.put(<span class="string">'third'</span>)</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">结果(先进先出):</span></span><br><span class="line"><span class="string">first</span></span><br><span class="line"><span class="string">second</span></span><br><span class="line"><span class="string">third</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>class queue.LifoQueue(maxsize=0) #last in fisrt out</strong></p>
<p>后进先出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q=queue.LifoQueue()</span><br><span class="line">q.put(<span class="string">'first'</span>)</span><br><span class="line">q.put(<span class="string">'second'</span>)</span><br><span class="line">q.put(<span class="string">'third'</span>)</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">结果(后进先出):</span></span><br><span class="line"><span class="string">third</span></span><br><span class="line"><span class="string">second</span></span><br><span class="line"><span class="string">first</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>class queue.PriorityQueue(maxsize=0) #存储数据时可设置优先级的队列</strong></p>
<p>优先级队列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q=queue.PriorityQueue()</span><br><span class="line"><span class="comment">#put进入一个元组,元组的第一个元素是优先级(通常是数字,也可以是非数字之间的比较),数字越小优先级越高。第一个元素一致时，按第二个排</span></span><br><span class="line">q.put((<span class="number">20</span>,<span class="string">'a'</span>))</span><br><span class="line">q.put((<span class="number">10</span>,<span class="string">'b'</span>))</span><br><span class="line">q.put((<span class="number">30</span>,<span class="string">'c'</span>))</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">结果(数字越小优先级越高,优先级高的优先出队):</span></span><br><span class="line"><span class="string">(10, 'b')</span></span><br><span class="line"><span class="string">(20, 'a')</span></span><br><span class="line"><span class="string">(30, 'c')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>更多方法说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Constructor for a priority queue. maxsize is an integer that sets the upperbound limit on the number of items that can be placed in the queue. Insertion will block once this size has been reached, until queue items are consumed. If maxsize is less than or equal to zero, the queue size is infinite.</span><br><span class="line"></span><br><span class="line">The lowest valued entries are retrieved first (the lowest valued entry is the one returned by sorted(list(entries))[0]). A typical pattern for entries is a tuple in the form: (priority_number, data).</span><br><span class="line"></span><br><span class="line">exception queue.Empty</span><br><span class="line">Exception raised when non-blocking get() (or get_nowait()) is called on a Queue object which is empty.</span><br><span class="line"></span><br><span class="line">exception queue.Full</span><br><span class="line">Exception raised when non-blocking put() (or put_nowait()) is called on a Queue object which is full.</span><br><span class="line"></span><br><span class="line">Queue.qsize()</span><br><span class="line">Queue.empty() #return True if empty  </span><br><span class="line">Queue.full() # return True if full </span><br><span class="line">Queue.put(item, block=True, timeout=None)</span><br><span class="line">Put item into the queue. If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case).</span><br><span class="line"></span><br><span class="line">Queue.put_nowait(item)</span><br><span class="line">Equivalent to put(item, False).</span><br><span class="line"></span><br><span class="line">Queue.get(block=True, timeout=None)</span><br><span class="line">Remove and return an item from the queue. If optional args block is true and timeout is None (the default), block if necessary until an item is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. Otherwise (block is false), return an item if one is immediately available, else raise the Empty exception (timeout is ignored in that case).</span><br><span class="line"></span><br><span class="line">Queue.get_nowait()</span><br><span class="line">Equivalent to get(False).</span><br><span class="line"></span><br><span class="line">Two methods are offered to support tracking whether enqueued tasks have been fully processed by daemon consumer threads.</span><br><span class="line"></span><br><span class="line">Queue.task_done()</span><br><span class="line">Indicate that a formerly enqueued task is complete. Used by queue consumer threads. For each get() used to fetch a task, a subsequent call to task_done() tells the queue that the processing on the task is complete.</span><br><span class="line"></span><br><span class="line">If a join() is currently blocking, it will resume when all items have been processed (meaning that a task_done() call was received for every item that had been put() into the queue).</span><br><span class="line"></span><br><span class="line">Raises a ValueError if called more times than there were items placed in the queue.</span><br><span class="line"></span><br><span class="line">Queue.join() block直到queue被消费完毕</span><br></pre></td></tr></table></figure>

<h4 id="8、Python标准模块——concurrent-futures"><a href="#8、Python标准模块——concurrent-futures" class="headerlink" title="8、Python标准模块——concurrent.futures"></a>8、Python标准模块——concurrent.futures</h4><p><strong><a href="https://docs.python.org/dev/library/concurrent.futures.html" target="_blank" rel="noopener">https://docs.python.org/dev/library/concurrent.futures.html</a></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1 介绍</span></span><br><span class="line">concurrent.futures模块提供了高度封装的异步调用接口</span><br><span class="line">ThreadPoolExecutor：线程池，提供异步调用</span><br><span class="line">ProcessPoolExecutor: 进程池，提供异步调用</span><br><span class="line">Both implement the same interface, which <span class="keyword">is</span> defined by the abstract Executor <span class="class"><span class="keyword">class</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#2 基本方法</span></span><br><span class="line"><span class="class">#<span class="title">submit</span><span class="params">(fn, *args, **kwargs)</span></span></span><br><span class="line"><span class="class">异步提交任务</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">map</span><span class="params">(func, *iterables, timeout=None, chunksize=<span class="number">1</span>)</span> </span></span><br><span class="line"><span class="class">取代<span class="title">for</span>循环<span class="title">submit</span>的操作</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#<span class="title">shutdown</span><span class="params">(wait=True)</span> </span></span><br><span class="line"><span class="class">相当于进程池的<span class="title">pool</span>.<span class="title">close</span><span class="params">()</span>+<span class="title">pool</span>.<span class="title">join</span><span class="params">()</span>操作</span></span><br><span class="line">wait=True，等待池内所有任务执行完毕回收完资源后才继续</span><br><span class="line">wait=<span class="literal">False</span>，立即返回，并不会等待池内的任务执行完毕</span><br><span class="line">但不管wait参数为何值，整个程序都会等到所有任务执行完毕</span><br><span class="line">submit和map必须在shutdown之前</span><br><span class="line"></span><br><span class="line"><span class="comment">#result(timeout=None)</span></span><br><span class="line">取得结果</span><br><span class="line"></span><br><span class="line"><span class="comment">#add_done_callback(fn)</span></span><br><span class="line">回调函数</span><br><span class="line"></span><br><span class="line"><span class="comment"># done()</span></span><br><span class="line">判断某一个线程是否完成</span><br><span class="line"></span><br><span class="line"><span class="comment"># cancle()</span></span><br><span class="line">取消某个任务</span><br></pre></td></tr></table></figure>

<p>ProcessPoolExecutor</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#介绍</span></span><br><span class="line">The ProcessPoolExecutor class is an Executor subclass that uses a pool of processes to execute calls asynchronously. ProcessPoolExecutor uses the multiprocessing module, which allows it to side-step the Global Interpreter Lock but also means that only picklable objects can be executed and returned.</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">concurrent</span>.<span class="title">futures</span>.<span class="title">ProcessPoolExecutor</span><span class="params">(max_workers=None, mp_context=None)</span></span></span><br><span class="line">An Executor subclass that executes calls asynchronously using a pool of at most max_workers processes. If max_workers is None or not given, it will default to the number of processors on the machine. If max_workers is lower or equal to 0, then a ValueError will be raised.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#用法</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor,ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s is runing'</span> %os.getpid())</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    executor=ProcessPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    futures=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>):</span><br><span class="line">        future=executor.submit(task,i)</span><br><span class="line">        futures.append(future)</span><br><span class="line">    executor.shutdown(<span class="literal">True</span>)</span><br><span class="line">    print(<span class="string">'+++&gt;'</span>)</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">        print(future.result())</span><br></pre></td></tr></table></figure>

<p>ThreadPoolExecutor</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#介绍</span></span><br><span class="line">ThreadPoolExecutor <span class="keyword">is</span> an Executor subclass that uses a pool of threads to execute calls asynchronously.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">concurrent</span>.<span class="title">futures</span>.<span class="title">ThreadPoolExecutor</span><span class="params">(max_workers=None, thread_name_prefix=<span class="string">''</span>)</span></span></span><br><span class="line"><span class="class"><span class="title">An</span> <span class="title">Executor</span> <span class="title">subclass</span> <span class="title">that</span> <span class="title">uses</span> <span class="title">a</span> <span class="title">pool</span> <span class="title">of</span> <span class="title">at</span> <span class="title">most</span> <span class="title">max_workers</span> <span class="title">threads</span> <span class="title">to</span> <span class="title">execute</span> <span class="title">calls</span> <span class="title">asynchronously</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Changed</span> <span class="title">in</span> <span class="title">version</span> 3.5:</span> If max_workers <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> given, it will default to the number of processors on the machine, multiplied by <span class="number">5</span>, assuming that ThreadPoolExecutor <span class="keyword">is</span> often used to overlap I/O instead of CPU work <span class="keyword">and</span> the number of workers should be higher than the number of workers <span class="keyword">for</span> ProcessPoolExecutor.</span><br><span class="line"></span><br><span class="line">New <span class="keyword">in</span> version <span class="number">3.6</span>: The thread_name_prefix argument was added to allow users to control the threading.Thread names <span class="keyword">for</span> worker threads created by the pool <span class="keyword">for</span> easier debugging.</span><br><span class="line"></span><br><span class="line"><span class="comment">#用法</span></span><br><span class="line">与ProcessPoolExecutor相同</span><br></pre></td></tr></table></figure>

<p>map的用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor,ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s is runing'</span> %os.getpid())</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    executor=ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in range(11):</span></span><br><span class="line">    <span class="comment">#     future=executor.submit(task,i)</span></span><br><span class="line"></span><br><span class="line">    executor.map(task,range(<span class="number">1</span>,<span class="number">12</span>)) <span class="comment">#map取代了for+submit</span></span><br></pre></td></tr></table></figure>

<p>回调函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor,ProcessPoolExecutor</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;进程%s&gt; get %s'</span> %(os.getpid(),url))</span><br><span class="line">    respone=requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> respone.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'url'</span>:url,<span class="string">'text'</span>:respone.text&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(res)</span>:</span></span><br><span class="line">    res=res.result()</span><br><span class="line">    print(<span class="string">'&lt;进程%s&gt; parse %s'</span> %(os.getpid(),res[<span class="string">'url'</span>]))</span><br><span class="line">    parse_res=<span class="string">'url:&lt;%s&gt; size:[%s]\n'</span> %(res[<span class="string">'url'</span>],len(res[<span class="string">'text'</span>]))</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'db.txt'</span>,<span class="string">'a'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(parse_res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    urls=[</span><br><span class="line">        <span class="string">'https://www.baidu.com'</span>,</span><br><span class="line">        <span class="string">'https://www.python.org'</span>,</span><br><span class="line">        <span class="string">'https://www.openstack.org'</span>,</span><br><span class="line">        <span class="string">'https://help.github.com/'</span>,</span><br><span class="line">        <span class="string">'http://www.sina.com.cn/'</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># p=Pool(3)</span></span><br><span class="line">    <span class="comment"># for url in urls:</span></span><br><span class="line">    <span class="comment">#     p.apply_async(get_page,args=(url,),callback=pasrse_page)</span></span><br><span class="line">    <span class="comment"># p.close()</span></span><br><span class="line">    <span class="comment"># p.join()</span></span><br><span class="line"></span><br><span class="line">    p=ProcessPoolExecutor(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        p.submit(get_page,url).add_done_callback(parse_page) <span class="comment">#parse_page拿到的是一个future对象obj，需要用obj.result()拿到结果</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/05/Python Data Analysis/第二章：NumPy数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/Python Data Analysis/第二章：NumPy数组/" itemprop="url">第二章：NumPy数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-05T18:44:53+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python-Data-Analysis/" itemprop="url" rel="index">
                    <span itemprop="name">Python Data Analysis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h3 id="2-1-NumPy数组对象"><a href="#2-1-NumPy数组对象" class="headerlink" title="2.1 NumPy数组对象"></a>2.1 NumPy数组对象</h3><p>NumPy中的多维数组数组称为ndarray， 它有两个组成部分。</p>
<ul>
<li>数据本身</li>
<li>描述数据的元数据</li>
</ul>
<p>在数组的处理过程中，原始数据不受影响，变化的只是元数据而已。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ndarray 与 arange()</span><br><span class="line"></span><br><span class="line">用arange()函数来生成的数组是一维数组，而ndarray则可以具有一个以上的维度。</span><br></pre></td></tr></table></figure>

<h4 id="NumPy数组的优势："><a href="#NumPy数组的优势：" class="headerlink" title="NumPy数组的优势："></a>NumPy数组的优势：</h4><p><strong>NumPy数组通常是由相同种类的元素组成的，即数组中的数据项的数据类型必须一致。</strong></p>
<ul>
<li>NumPy数组元素类型一致<ul>
<li>好处：由于知道数组元素的类型相同，所以能轻松确定存储数组所需空间的大小。</li>
</ul>
</li>
<li>NumPy数组能够运用向量化运算来处理整个数组<ul>
<li>而完成同样的任务，Python列表则通常必须借助循环语句遍历列表，并对逐个元素进行相应的处理。</li>
</ul>
</li>
<li>NumPy使用了优化过的C API，所以运算速度格外的快。</li>
</ul>
<p><code>In : a = arange(5)</code>                                                           </p>
<p><code>In : a.dtype</code>                                                                 </p>
<p><code>Out: dtype(&#39;int64&#39;)</code></p>
<p>此处使用了arange（）来建立数组，并且查看了该数组的数据类型。</p>
<p><code>In: a</code>                                                                       </p>
<p><code>Out: array([0, 1, 2, 3, 4])</code></p>
<p><code>In: a.shape</code>                                                                 </p>
<p><code>Out: (5,)</code></p>
<p>如你所见，该向量有5个元素，它们的值分别是从0到4。</p>
<p>该数组的shape属性是一个元组（就本例而言，这是一个单元素元组），存放的是数组在每一个维度的长度。</p>
<h3 id="2-2-创建多维数组"><a href="#2-2-创建多维数组" class="headerlink" title="2.2 创建多维数组"></a>2.2 创建多维数组</h3><ol>
<li><p>创建多维数组，代码如下：</p>
<p><code>In: m = array([arange(2), arange(2)])</code>                                       </p>
<p><code>In: m</code>                                                                       </p>
<p><code>Out:</code> </p>
<p><code>array([[0, 1],</code></p>
<p>​              <code>[0, 1]])</code></p>
</li>
<li><p>显示该数组的形状，代码如下：</p>
<p><code>In: m.shape</code>                                                                 </p>
<p><code>Out: (2, 2)</code></p>
</li>
</ol>
<p>创建一个 ndarray 只需调用 NumPy 的 array 函数即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(object, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">object</td>
<td align="left">数组或嵌套的数列</td>
</tr>
<tr>
<td align="left">dtype</td>
<td align="left">数组元素的数据类型，可选</td>
</tr>
<tr>
<td align="left">copy</td>
<td align="left">对象是否需要复制，可选</td>
</tr>
<tr>
<td align="left">order</td>
<td align="left">创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</td>
</tr>
<tr>
<td align="left">subok</td>
<td align="left">默认返回一个与基类类型一致的数组</td>
</tr>
<tr>
<td align="left">ndmin</td>
<td align="left">指定生成数组的最小维度</td>
</tr>
</tbody></table>
<h3 id="2-3-选择NumPy数组元素"><a href="#2-3-选择NumPy数组元素" class="headerlink" title="2.3 选择NumPy数组元素"></a>2.3 选择NumPy数组元素</h3><p><code>In: a = array([[1, 2], [3, 4]])</code>                                             </p>
<p><code>In: a</code>                                                                       </p>
<p><code>Out:</code> </p>
<p><code>array([[1, 2],</code></p>
<p>​              <code>[3, 4]])</code></p>
<p>上面的矩阵是通过向array()函数传递一个由列表组成的列表得到的。</p>
<p>下面，通过下标来逐个选择矩阵的各个元素。</p>
<p><code>In: a[0, 0]</code>                                                                 </p>
<p><code>Out: 1</code></p>
<p><code>In: a[0, 1]</code>                                                                 </p>
<p><code>Out: 2</code>                                                           </p>
<p><code>In : a[1, 0]</code>                                                                 </p>
<p><code>Out: 3</code></p>
<p><code>In: a[1, 1]</code>                                                                </p>
<p><code>Out: 4</code></p>
<p>可见，对于数组a，只要通过<code>a[m, n]</code>的形式，就能访问数组内的元素，其中m和n为数组元素的下标。数组元素的下标如下所示：</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%20Data%20Analysis/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20NumPy%E6%95%B0%E7%BB%84/1.png" alt="1"></p>
<h3 id="2-4-NumPy的数值类型"><a href="#2-4-NumPy的数值类型" class="headerlink" title="2.4 NumPy的数值类型"></a>2.4 NumPy的数值类型</h3><p>下表概述了NumPy的各种数值类型：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bool</td>
<td align="left">布尔型数据类型（True 或者 False），占用1比特</td>
</tr>
<tr>
<td align="left">inti</td>
<td align="left">其长度取决于平台的整数（通常为int32 或 int64）</td>
</tr>
<tr>
<td align="left">int8</td>
<td align="left">字节类型（-128 to 127）</td>
</tr>
<tr>
<td align="left">int16</td>
<td align="left">整型（-32768 to 32767）</td>
</tr>
<tr>
<td align="left">int32</td>
<td align="left">整型（-$2^{31}$  to  $2^{31}-1$）</td>
</tr>
<tr>
<td align="left">int64</td>
<td align="left">整型（-$2^{63}$  to  $2^{63}-1$））</td>
</tr>
<tr>
<td align="left">uint8</td>
<td align="left">无符号整型（0 to 255）</td>
</tr>
<tr>
<td align="left">uint16</td>
<td align="left">无符号整型（0 to 65535）</td>
</tr>
<tr>
<td align="left">uint32</td>
<td align="left">无符号整型（0 to $2^{31}-1$）</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">无符号整型（0 to $2^{63}-1$）</td>
</tr>
<tr>
<td align="left">float16</td>
<td align="left">半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td>
</tr>
<tr>
<td align="left">float32</td>
<td align="left">单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td>
</tr>
<tr>
<td align="left">float64或float</td>
<td align="left">双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td>
</tr>
<tr>
<td align="left">complex_</td>
<td align="left">complex128 类型的简写，即 128 位复数</td>
</tr>
<tr>
<td align="left">complex64</td>
<td align="left">复数，表示双 32 位浮点数（实数部分和虚数部分）</td>
</tr>
<tr>
<td align="left">complex128</td>
<td align="left">复数，表示双 64 位浮点数（实数部分和虚数部分）</td>
</tr>
</tbody></table>
<p>注：NumPy跟数学运算有关的数据类型的名称都以数字结尾。这个数字指示了该类型的变量所占用的二进制位数。</p>
<p>每一种数据类型都有相应的转换函数：</p>
<p><code>In: float64(32)</code>                                                            </p>
<p><code>Out: 32.0</code></p>
<p><code>In: int8(42.0)</code>                                                             </p>
<p><code>Out: 42</code></p>
<p><code>In: bool(42)</code>                                                               </p>
<p><code>Out: True</code></p>
<p><code>In: bool(0)</code>                                                                </p>
<p><code>Out: False</code></p>
<p><code>In: bool(42.0)</code>                                                             </p>
<p><code>Out: True</code></p>
<p><code>In: float(True)</code>                                                            </p>
<p><code>Out: 1.0</code></p>
<p><code>In: float(False)</code>                                                           </p>
<p><code>Out: 0.0</code></p>
<p>许多函数都带有一个指定数据类型的参数，该参数通常是可选的：</p>
<p><code>In: arange(7, dtype=uint16)</code>                                                </p>
<p><code>Out: array([0, 1, 2, 3, 4, 5, 6], dtype=uint16)</code></p>
<p>注：</p>
<ol>
<li><p>不允许把复数类型转化成整型。会引发TypeError错误：</p>
<p><code>In: float(42.0 + 1.j)</code>                                                      </p>
<p><code>Traceback (most recent call last)</code></p>
<p><code>&lt;ipython-input-20-c164c131df24&gt; in &lt;module&gt;</code></p>
<p>​    <code>float(42.0 + 1.j)</code></p>
<p><code>TypeError: can&#39;t convert complex to float</code></p>
</li>
<li><p>同样也不允许复数转化成浮点数</p>
</li>
<li><p>允许把浮点数转换成复数  如：complex(1.0)是合法的</p>
</li>
<li><p>复数的实部和虚部分别使用 real( ) 函数和 imag( ) 函数来提取</p>
</li>
</ol>
<h4 id="2-4-1-数据类型对象"><a href="#2-4-1-数据类型对象" class="headerlink" title="2.4.1 数据类型对象"></a>2.4.1 数据类型对象</h4><p><strong>数据类型对象</strong>是numpy.dtype类的实例。</p>
<p>数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面：</p>
<ul>
<li>数据的类型（整数，浮点数或者 Python 对象）</li>
<li>数据的大小（例如， 整数使用多少个字节存储）</li>
<li>数据的字节顺序（小端法或大端法）</li>
<li>在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分</li>
<li>如果数据类型是子数组，它的形状和数据类型</li>
</ul>
<p>数据类型对象表明了数据占用的字节数。所占用的具体数目一般存放在 dtype 的 itemsize 属性中：</p>
<p><code>In: a = array([[1,2],[3,4]])</code><br><code>In: a.dtype.itemsize</code><br><code>Out: 8</code></p>
<h4 id="2-4-2-字符码"><a href="#2-4-2-字符码" class="headerlink" title="2.4.2 字符码"></a>2.4.2 字符码</h4><p>NumPy之所以提供字符码，是为了和其前身Numeric向后兼容。</p>
<p>一般不建议使用字符码。</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">对应类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">b</td>
<td align="left">布尔型</td>
</tr>
<tr>
<td align="left">i</td>
<td align="left">(有符号) 整型</td>
</tr>
<tr>
<td align="left">u</td>
<td align="left">无符号整型 integer</td>
</tr>
<tr>
<td align="left">f</td>
<td align="left">单精度浮点型</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">双精度浮点型</td>
</tr>
<tr>
<td align="left">c</td>
<td align="left">复数浮点型</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">timedelta（时间间隔）</td>
</tr>
<tr>
<td align="left">M</td>
<td align="left">datetime（日期时间）</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">复数型</td>
</tr>
<tr>
<td align="left">O</td>
<td align="left">(Python) 对象</td>
</tr>
<tr>
<td align="left">S, a</td>
<td align="left">(byte-)字符串</td>
</tr>
<tr>
<td align="left">U</td>
<td align="left">Unicode</td>
</tr>
<tr>
<td align="left">V</td>
<td align="left">原始数据 (void)</td>
</tr>
</tbody></table>
<p><code>In: arange(7, dtype=&#39;f&#39;)</code>                                                   </p>
<p><code>Out: array([0., 1., 2., 3., 4., 5., 6.], dtype=float32)</code></p>
<p><code>In:  arange(7, dtype=&#39;D&#39;)</code>                                                  </p>
<p><code>Out: array([0.+0.j, 1.+0.j, 2.+0.j, 3.+0.j, 4.+0.j, 5.+0.j, 6.+0.j])</code></p>
<h4 id="2-4-3-Dtype-构造函数"><a href="#2-4-3-Dtype-构造函数" class="headerlink" title="2.4.3 Dtype 构造函数"></a>2.4.3 Dtype 构造函数</h4><p>创建数据类型时，手段有很多，下面以浮点型数据为例进行说明。</p>
<ul>
<li><p>可以用Python自带的常规浮点型</p>
<p><code>In: dtype(float)</code><br><code>Out: float64</code></p>
</li>
<li><p>可以用字符码规定单精度浮点数</p>
<p><code>In: dtype(&#39;f&#39;)</code><br><code>Out: float32</code></p>
</li>
<li><p>可以用字符码规定双精度浮点数</p>
<p><code>In: dtype(&#39;d&#39;)</code><br><code>Out: loat64</code></p>
</li>
<li><p>可以通过dtype构造函数传递一个双字符码。</p>
<ul>
<li>第一个字符表示数据类型</li>
<li>第二个字符表示一个数字，表示该类型占用的字节数（数字2、4、8分别对应16位、32位、64位浮点数）</li>
</ul>
<p><code>In: dtype(&#39;f8&#39;)</code><br><code>Out: float64</code></p>
</li>
</ul>
<p>可以通过sctypeDict.keys()函数列出所有数据类型的字符码。</p>
<p><code>In: sctypeDict.keys()</code>                                                      </p>
<p><code>Out: dict_keys([&#39;?&#39;, 0, &#39;byte&#39;, &#39;b&#39;, 1, &#39;ubyte&#39;, &#39;B&#39;, 2, &#39;short&#39;, &#39;h&#39;, 3, &#39;ushort&#39;, &#39;H&#39;, 4, &#39;i&#39;, 5, &#39;uint&#39;, &#39;I&#39;, 6, &#39;intp&#39;, &#39;p&#39;, 7, &#39;uintp&#39;, &#39;P&#39;, 8, &#39;long&#39;, &#39;l&#39;, &#39;L&#39;, &#39;longlong&#39;, &#39;q&#39;, 9, &#39;ulonglong&#39;, &#39;Q&#39;, 10, &#39;half&#39;, &#39;e&#39;, 23, &#39;f&#39;, 11, &#39;double&#39;, &#39;d&#39;, 12, &#39;longdouble&#39;, &#39;g&#39;, 13, &#39;cfloat&#39;, &#39;F&#39;, 14, &#39;cdouble&#39;, &#39;D&#39;, 15, &#39;clongdouble&#39;, &#39;G&#39;, 16, &#39;O&#39;, 17, &#39;S&#39;, 18, &#39;unicode&#39;, &#39;U&#39;, 19, &#39;void&#39;, &#39;V&#39;, 20, &#39;M&#39;, 21, &#39;m&#39;, 22, &#39;bool8&#39;, &#39;Bool&#39;, &#39;b1&#39;, &#39;int64&#39;, &#39;Int64&#39;, &#39;i8&#39;, &#39;uint64&#39;, &#39;Uint64&#39;, &#39;u8&#39;, &#39;float16&#39;, &#39;Float16&#39;, &#39;f2&#39;, &#39;float32&#39;, &#39;Float32&#39;, &#39;f4&#39;, &#39;float64&#39;, &#39;Float64&#39;, &#39;f8&#39;, &#39;float128&#39;, &#39;Float128&#39;, &#39;f16&#39;, &#39;complex64&#39;, &#39;Complex32&#39;, &#39;c8&#39;, &#39;complex128&#39;, &#39;Complex64&#39;, &#39;c16&#39;, &#39;complex256&#39;, &#39;Complex128&#39;, &#39;c32&#39;, &#39;object0&#39;, &#39;Object0&#39;, &#39;bytes0&#39;, &#39;Bytes0&#39;, &#39;str0&#39;, &#39;Str0&#39;, &#39;void0&#39;, &#39;Void0&#39;, &#39;datetime64&#39;, &#39;Datetime64&#39;, &#39;M8&#39;, &#39;timedelta64&#39;, &#39;Timedelta64&#39;, &#39;m8&#39;, &#39;UInt64&#39;, &#39;int32&#39;, &#39;Int32&#39;, &#39;i4&#39;, &#39;uint32&#39;, &#39;UInt32&#39;, &#39;u4&#39;, &#39;int16&#39;, &#39;Int16&#39;, &#39;i2&#39;, &#39;uint16&#39;, &#39;UInt16&#39;, &#39;u2&#39;, &#39;int8&#39;, &#39;Int8&#39;, &#39;i1&#39;, &#39;uint8&#39;, &#39;UInt8&#39;, &#39;u1&#39;, &#39;complex_&#39;, &#39;int0&#39;, &#39;uint0&#39;, &#39;single&#39;, &#39;csingle&#39;, &#39;singlecomplex&#39;, &#39;float_&#39;, &#39;intc&#39;, &#39;uintc&#39;, &#39;int_&#39;, &#39;longfloat&#39;, &#39;clongfloat&#39;, &#39;longcomplex&#39;, &#39;bool_&#39;, &#39;bytes_&#39;, &#39;string_&#39;, &#39;unicode_&#39;, &#39;object_&#39;, &#39;str_&#39;, &#39;int&#39;, &#39;float&#39;, &#39;complex&#39;, &#39;bool&#39;, &#39;object&#39;, &#39;str&#39;, &#39;bytes&#39;, &#39;a&#39;])</code></p>
<h4 id="2-4-4-dtype属性"><a href="#2-4-4-dtype属性" class="headerlink" title="2.4.4 dtype属性"></a>2.4.4 dtype属性</h4><p>dtype 对象是使用以下语法构造的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.dtype(object, align, copy)</span><br></pre></td></tr></table></figure>

<ul>
<li>object - 要转换为的数据类型对象</li>
<li>align - 如果为 true，填充字段使其类似 C 的结构体。</li>
<li>copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用</li>
</ul>
<p>dtype的属性str中保存的是一个表示数据类型的字符串</p>
<ul>
<li>第一个字符描述字节顺序<ul>
<li>字节顺序是通过对数据类型预先设定”&lt;”或”&gt;”来决定的。”&lt;”意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。”&gt;”意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。</li>
</ul>
</li>
<li>如果需要，后面会跟着字符码和数字，用来表示存储每个数组元素所需的字节数</li>
</ul>
<p><code>In: t = dtype(&#39;Float64&#39;)</code>                                                    </p>
<p><code>In: t.str</code>                                                                   </p>
<p><code>Out: &#39;&lt;f8&#39;</code></p>
<h3 id="2-5-一维数组的切片与索引"><a href="#2-5-一维数组的切片与索引" class="headerlink" title="2.5 一维数组的切片与索引"></a>2.5 一维数组的切片与索引</h3><p>一维NumPy数组的切片操作与Python列表的切片一样。</p>
<p><code>In: a = arange(9)</code>                                                           </p>
<p><code>In: a[3:7]</code>                                                                  </p>
<p><code>Out: array([3, 4, 5, 6])</code>                                                            </p>
<p><code>In: a[:7:2]</code>                                                                 </p>
<p><code>Out: array([0, 2, 4, 6])</code></p>
<p><code>In: a[::-1]</code>                                                                 </p>
<p><code>Out: array([8, 7, 6, 5, 4, 3, 2, 1, 0])</code></p>
<h3 id="2-6-处理数组形状"><a href="#2-6-处理数组形状" class="headerlink" title="2.6 处理数组形状"></a>2.6 处理数组形状</h3><p>首先，先创建数组：</p>
<p><code>b = np.arange(24).reshape(2, 3, 4)</code></p>
<ul>
<li><p><strong>拆解</strong>    </p>
<ul>
<li>可以用 ravel() 函数将多维数组变成一维数组</li>
</ul>
<p><code>In: b</code></p>
<p><code>Out:</code></p>
<p><code>[[[ 0  1  2  3]</code><br>  <code>[ 4  5  6  7]</code><br>  <code>[ 8  9 10 11]]</code><br> <code>[[12 13 14 15]</code><br>  <code>[16 17 18 19]</code><br>  <code>[20 21 22 23]]]</code></p>
</li>
</ul>
<p>  <code>In: b.ravel()</code></p>
<p>  <code>Out:</code></p>
<p>  <code>[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]</code></p>
<ul>
<li><p><strong>拉直</strong>    </p>
<ul>
<li>flatten() 函数其功能与 ravel() 相同<ul>
<li>但 flatten() 函数返回的是真实的数组，需要分配新的内存空间</li>
<li>而 ravel() 函数返回的只是数组的视图 </li>
</ul>
</li>
</ul>
<p><code>In: b.flatten()</code></p>
<p><code>Out:</code></p>
<p><code>[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]</code></p>
</li>
</ul>
<ul>
<li><p><strong>用元组指定数组形状</strong>    </p>
<ul>
<li>除 reshape() 函数外，还可以用元组来轻松定义数组的形状</li>
</ul>
<p><code>In: b.shape = (6,4)</code><br><code>In: b</code></p>
<p><code>Out:</code></p>
<p><code>[[ 0  1  2  3]</code><br> <code>[ 4  5  6  7]</code><br> <code>[ 8  9 10 11]</code><br> <code>[12 13 14 15]</code><br> <code>[16 17 18 19]</code><br> <code>[20 21 22 23]]</code></p>
</li>
</ul>
<ul>
<li><p><strong>转置</strong></p>
<p><code>In: b.transpose()</code></p>
<p><code>Out:</code></p>
<p><code>[[ 0  4  8 12 16 20]</code><br> <code>[ 1  5  9 13 17 21]</code><br> <code>[ 2  6 10 14 18 22]</code><br> <code>[ 3  7 11 15 19 23]]</code></p>
</li>
</ul>
<ul>
<li><p><strong>调整大小</strong></p>
<ul>
<li>函数 resize() 的作用类似于 reshape() ，但是会改变所作用的数组</li>
</ul>
<p><code>In: b.resize((2,12))</code><br><code>In: b</code></p>
<p><code>Out:</code></p>
<p><code>[[ 0  1  2  3  4  5  6  7  8  9 10 11]</code><br> <code>[12 13 14 15 16 17 18 19 20 21 22 23]]</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">b = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)      <span class="comment"># 创建了一个三维数组</span></span><br><span class="line">print(<span class="string">'b:\n'</span>, b)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\nb.ravel()\n'</span>, b.ravel())    <span class="comment"># 拆解，利用ravel（）函数将多维数组变成一维数组</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\nb.flatten()\n'</span>,b.flatten())    <span class="comment"># 拉直</span></span><br><span class="line"></span><br><span class="line">b.shape = (<span class="number">6</span>, <span class="number">4</span>)    <span class="comment"># 重新规定形状</span></span><br><span class="line">print(<span class="string">'\nb.shape = (6, 4)\n'</span>, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\nb.transpose()\n'</span>,b.transpose())    <span class="comment"># 转置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b.resize((<span class="number">2</span>, <span class="number">12</span>))    <span class="comment"># 调整大小</span></span><br><span class="line">print(<span class="string">'\nb.resize((2, 12))\n'</span>, b)</span><br></pre></td></tr></table></figure>

<h4 id="2-6-1-堆叠数组"><a href="#2-6-1-堆叠数组" class="headerlink" title="2.6.1 堆叠数组"></a>2.6.1 堆叠数组</h4><p>从深度看，数组既可以横向叠放，也可以竖向叠放。</p>
<p>首先，先建立数组：</p>
<p><code>In: a = arange(9).reshape(3,3)</code></p>
<p><code>In: a</code></p>
<p><code>Out:</code></p>
<p><code>[[0 1 2]</code><br> <code>[3 4 5]</code><br> <code>[6 7 8]]</code></p>
<p><code>In: b = 2 * a</code></p>
<p><code>In: b</code></p>
<p><code>Out:</code></p>
<p><code>[[ 0  2  4]</code><br> <code>[ 6  8 10]</code><br> <code>[12 14 16]]</code></p>
<ul>
<li><p><strong>水平叠加</strong></p>
<ul>
<li><strong>hstack()</strong> 函数</li>
</ul>
<p><code>In: hstack((a, b))</code></p>
<p><code>Out:</code></p>
<p><code>[[ 0  1  2  0  2  4]</code><br> <code>[ 3  4  5  6  8 10]</code><br> <code>[ 6  7  8 12 14 16]]</code></p>
</li>
</ul>
<ul>
<li><p>用 <strong>concatenate()</strong> 函数也能达到同样的效果</p>
<p><code>In: concatenate((a, b), axis=1)</code></p>
<p><code>Out:</code></p>
<p><code>[[ 0  1  2  0  2  4]  [ 3  4  5  6  8 10]  [ 6  7  8 12 14 16]]</code></p>
</li>
</ul>
<ul>
<li><p><strong>垂直叠加</strong></p>
<ul>
<li><p><strong>vsatck()</strong> 函数</p>
<p><code>In: vstack((a, b))</code><br><code>[[ 0  1  2]</code><br> <code>[ 3  4  5]</code><br> <code>[ 6  7  8]</code><br> <code>[ 0  2  4]</code><br> <code>[ 6  8 10]</code><br> <code>[12 14 16]]</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>当参数 axis 置 0 时，<strong>concatenate()</strong> 函数也会得到同样的效果</p>
<p><code>In: concatenate((a, b), axis=0)</code><br><code>[[ 0  1  2]</code><br> <code>[ 3  4  5]</code><br> <code>[ 6  7  8]</code><br> <code>[ 0  2  4]</code><br> <code>[ 6  8 10]</code><br><code>[12 14 16]]</code></p>
</li>
</ul>
<ul>
<li><p><strong>深度叠加</strong></p>
<ul>
<li><p><strong>dstack()</strong> 函数</p>
<ul>
<li>这种方法是沿着第三个坐标轴（纵向）的方向来叠加一摞数组</li>
<li>举例来说，可以在一个图像数据的二维数组上叠加另一幅图像的数据</li>
</ul>
<p><code>In: dstack((a, b))</code><br><code>[[[ 0  0]</code><br>  <code>[ 1  2]</code><br>  <code>[ 2  4]]</code><br> <code>[[ 3  6]</code><br>  <code>[ 4  8]</code><br>  <code>[ 5 10]]</code><br> <code>[[ 6 12]</code><br>  <code>[ 7 14]</code><br>  <code>[ 8 16]]]</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>列式堆叠</strong></p>
<ul>
<li><p><strong>column_stack()</strong></p>
<p><code>In: oned = arange(2)</code><br><code>In: oned</code><br><code>[0 1]</code><br><code>In: twice_oned = 2 * oned</code><br><code>In: twice_oned</code><br><code>[0 2]</code><br><code>In: column_stack((oned, twice_oned))</code><br><code>[[0 0]</code><br> <code>[1 2]]</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>用这种方法堆叠二维数组，过程类似于 <strong>hstack()</strong> 函数</p>
<p><code>In: column_stack((a, b))</code><br><code>[[ 0  1  2  0  2  4]</code><br> <code>[ 3  4  5  6  8 10]</code><br> <code>[ 6  7  8 12 14 16]]</code></p>
<p><code>In: column_stack((a, b)) == hstack((a, b))</code><br><code>[[ True  True  True  True  True  True]</code><br> <code>[ True  True  True  True  True  True]</code><br><code>[ True  True  True  True  True  True]]</code></p>
</li>
</ul>
<ul>
<li><p><strong>行式堆叠</strong></p>
<ul>
<li><p><strong>row_stack()</strong></p>
<p><code>In: row_stack((oned, twice_oned))</code><br><code>[[0 1]</code><br> <code>[0 2]]</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>对于二维数组，row_stack() 函数相当于 <strong>vstack()</strong> 函数</p>
<p><code>In: row_stack((a, b))</code><br><code>[[ 0  1  2]</code><br> <code>[ 3  4  5]</code><br> <code>[ 6  7  8]</code><br> <code>[ 0  2  4]</code><br> <code>[ 6  8 10]</code><br> <code>[12 14 16]]</code><br><code>In: row_stack((a,b)) == vstack((a, b))</code><br><code>[[ True  True  True]</code><br> <code>[ True  True  True]</code><br> <code>[ True  True  True]</code><br> <code>[ True  True  True]</code><br> <code>[ True  True  True]</code><br><code>[ True  True  True]]</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line">a = numpy.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">b = <span class="number">2</span> * a</span><br><span class="line"></span><br><span class="line">print(<span class="string">'a:\n'</span>, a)</span><br><span class="line">print(<span class="string">'\nb\n'</span>,b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 水平叠加  hstack</span></span><br><span class="line">print(<span class="string">'\nhstack((a, b)):\n'</span>, numpy.hstack((a, b)))</span><br><span class="line">print(<span class="string">'\nnumpy.concatenate((a, b), axis=1):\n'</span>, numpy.concatenate((a, b), axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 垂直叠加  vstack</span></span><br><span class="line">print(<span class="string">'\nvstack((a, b)):\n'</span>, numpy.vstack((a, b)))</span><br><span class="line">print(<span class="string">'\nnumpy.concatenate((a, b), axis=0):\n'</span>, numpy.concatenate((a, b), axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 深度叠加  dstack</span></span><br><span class="line">print(<span class="string">'\ndstack((a, b))\n:'</span>, numpy.dstack((a, b)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列式堆叠 column_stack</span></span><br><span class="line">oned = numpy.arange(<span class="number">2</span>)</span><br><span class="line">twice_oned = <span class="number">2</span> * oned</span><br><span class="line">print(<span class="string">'\noned:\n'</span>, oned)</span><br><span class="line">print(<span class="string">'\ntwice_oned:\n'</span>, twice_oned)</span><br><span class="line">print(<span class="string">'\nnumpy.column_stack((oned, twice_oned):\n'</span>, numpy.column_stack((oned, twice_oned)))</span><br><span class="line">print(<span class="string">'\nnumpy.column_stack((a, b):\n'</span>, numpy.column_stack((a, b)))</span><br><span class="line">print(<span class="string">'\nnumpy.column_stack((a, b))==numpy.hstack((a, b)):\n'</span>, numpy.column_stack((a, b))==numpy.hstack((a, b)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 行式堆叠 row_stack</span></span><br><span class="line">oned = numpy.arange(<span class="number">2</span>)</span><br><span class="line">twice_oned = <span class="number">2</span> * oned</span><br><span class="line">print(<span class="string">'\noned:\n'</span>, oned)</span><br><span class="line">print(<span class="string">'\ntwice_oned:\n'</span>, twice_oned)</span><br><span class="line">print(<span class="string">'\nnumpy.row_stack((oned, twice_oned):\n'</span>, numpy.row_stack((oned, twice_oned)))</span><br><span class="line">print(<span class="string">'\nnumpy.row_stack((a, b):\n'</span>, numpy.row_stack((a, b)))</span><br><span class="line">print(<span class="string">'\nnumpy.row_stack((a, b))==numpy.vstack((a, b)):\n'</span>, numpy.row_stack((a, b))==numpy.vstack((a, b)))</span><br></pre></td></tr></table></figure>

<h4 id="2-6-2-拆分数组"><a href="#2-6-2-拆分数组" class="headerlink" title="2.6.2 拆分数组"></a>2.6.2 拆分数组</h4><p>可以从纵向、横向和深度方向来拆分数组。</p>
<ul>
<li><p><strong>横向拆分</strong></p>
<ul>
<li><p><strong>hspilt()</strong></p>
<ul>
<li>对于一个 $3 \times 3$ 数组，可以沿着横轴方向将其分解为3部分，并且各部分的大小和形状完全一致</li>
</ul>
<p><code>In: a = arange(9).reshape(3, 3)</code><br><code>In: a</code><br><code>[[0 1 2]</code><br> <code>[3 4 5]</code><br> <code>[6 7 8]]</code></p>
<p><code>In: hsplit(a, 3)</code><br><code>[array([[0],</code></p>
<pre><code>`[3],`
`[6]]),` </code></pre><p><code>array([[1],</code></p>
<pre><code>`[4],`
`[7]]),` </code></pre><p><code>array([[2],</code></p>
<pre><code>`[5],`
`[8]])]`</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li><p>这相当于调用了参数 axis=1 的 <strong>split()</strong> 函数</p>
<p><code>In: split(a, 3, axis=1)</code><br><code>[array([[0]</code>,</p>
<pre><code>`[3],`
`[6]]), `</code></pre><p><code>array([[1],</code></p>
<pre><code>`[4],`
`[7]]), `</code></pre><p><code>array([[2],</code></p>
<pre><code>`[5],`
`[8]])]`</code></pre></li>
</ul>
<ul>
<li><p><strong>纵向拆分</strong></p>
<ul>
<li><p><strong>vsplit()</strong> 函数将沿着纵轴方向分解数组</p>
<p><code>In: vsplit(a, 3)</code><br><code>[array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>当参数 axis=0 时，<strong>split()</strong> 函数也会沿着纵轴方向分解数组</p>
<p><code>In: split(a, 3, axis=0)</code><br><code>[array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]</code></p>
</li>
</ul>
<ul>
<li><p><strong>深向拆分</strong></p>
<ul>
<li><p><strong>dsplit()</strong></p>
<ul>
<li>dsplit() 函数会沿着深度方向分解数组</li>
<li>dsplit() 函数只处理三位及以上的数组</li>
</ul>
<p><code>In: c = arange(27).reshape(3, 3, 3)</code><br><code>In: c</code><br><code>[[[ 0  1  2]</code><br>  <code>[ 3  4  5]</code><br>  <code>[ 6  7  8]]</code></p>
<p> <code>[[ 9 10 11]</code><br>  <code>[12 13 14]</code><br>  <code>[15 16 17]]</code></p>
<p> <code>[[18 19 20]</code><br>  <code>[21 22 23]</code><br>  <code>[24 25 26]]]</code></p>
</li>
</ul>
</li>
</ul>
<pre><code>`In: dsplit(c, 3)`
`[array([[[ 0],`
                  `[ 3],`
                  `[ 6]],`

                  `[[ 9],`
                    `[12],`
                    `[15]],`

​                  `[[18],`
​                    `[21],`
​                    `[24]]]),`

 `array([[[ 1],`
                 `[ 4],`
                 `[ 7]],`

​               `[[10],`
                 `[13],`
​                 `[16]],`

​               `[[19],`
                 `[22],`
                 `[25]]]),` 

`array([[[ 2],`
                `[ 5],`
                `[ 8]],`

​              `[[11],`
​                `[14],`
​                `[17]],`

​              `[[20],`
​                `[23],`
​                `[26]]])]`</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line">a = numpy.arange(<span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'a:\n'</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 横向拆分  hsplit()</span></span><br><span class="line">print(<span class="string">'\nnumpy.hsplit(a, 3):\n'</span>, numpy.hsplit(a, <span class="number">3</span>))</span><br><span class="line">print(<span class="string">'\nnumpy.split(a, 3, axis=1:\n'</span>, numpy.split(a, <span class="number">3</span>, axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 纵向拆分  vsplit()</span></span><br><span class="line">print(<span class="string">'\nnumpy.vsplit(a, 3):\n'</span>, numpy.vsplit(a, <span class="number">3</span>))</span><br><span class="line">print(<span class="string">'\nnumpy.split(a, 3, axis=0:\n'</span>, numpy.split(a, <span class="number">3</span>, axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 深向拆分  dsplit()    只适用于3维及以上的数组</span></span><br><span class="line">c = numpy.arange(<span class="number">27</span>).reshape(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">print(<span class="string">'\nc:\n'</span>, c)</span><br><span class="line">print(<span class="string">'\nnumpy.dsplit(c, 3):\n'</span>, numpy.dsplit(c, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h4 id="2-6-3-NumPy数组的属性"><a href="#2-6-3-NumPy数组的属性" class="headerlink" title="2.6.3 NumPy数组的属性"></a>2.6.3 NumPy数组的属性</h4><ul>
<li><p><strong>ndim</strong> 属性</p>
<ul>
<li>存储的是维度的数量</li>
</ul>
<p><code>In: b</code><br><code>[[ 0  1  2  3  4  5  6  7  8  9 10 11]</code><br> <code>[12 13 14 15 16 17 18 19 20 21 22 23]]</code><br><code>In: b.ndim</code><br><code>2</code></p>
</li>
</ul>
<ul>
<li><p><strong>size</strong>属性</p>
<ul>
<li>用来保存元素的数量</li>
</ul>
<p><code>In: b.size</code><br><code>24</code></p>
</li>
</ul>
<ul>
<li><p><strong>itemsize</strong>属性</p>
<ul>
<li>可以返回数组中各个元素所占用的字节数</li>
</ul>
<p><code>In: b.itemsize</code><br><code>8</code></p>
</li>
</ul>
<ul>
<li><p><strong>nbytes</strong> 属性</p>
<ul>
<li>返回存储整个数组所需的字节数 = itemsize * size</li>
</ul>
<p><code>In: b.nbytes</code><br><code>192</code></p>
<p><code>In: b.size * b.itemsize</code><br><code>192</code></p>
</li>
</ul>
<ul>
<li><p><strong>T</strong> 属性 </p>
<ul>
<li>转置，与 transpose() 函数相同</li>
</ul>
<p><code>In: b.resize(6,4)</code><br><code>None</code></p>
<p><code>In: b</code><br><code>[[ 0  1  2  3]</code><br> <code>[ 4  5  6  7]</code><br> <code>[ 8  9 10 11]</code><br> <code>[12 13 14 15]</code><br> <code>[16 17 18 19]</code><br> <code>[20 21 22 23]]</code></p>
<p><code>In: b.T</code><br><code>[[ 0  4  8 12 16 20]</code><br> <code>[ 1  5  9 13 17 21]</code><br> <code>[ 2  6 10 14 18 22]</code><br><code>[ 3  7 11 15 19 23]]</code></p>
</li>
</ul>
<ul>
<li><p>使用复数生成一个数组</p>
<p><code>In: b = array([1.j + 1, 2.j + 3])</code><br><code>In: b</code><br><code>[1.+1.j 3.+2.j]</code></p>
</li>
</ul>
<ul>
<li><p><strong>real</strong> 属性</p>
<ul>
<li>返回数组的实部，当数组元素全为实数时，就返回数组本身</li>
</ul>
<p><code>In: b.real</code><br><code>[1. 3.]</code></p>
</li>
</ul>
<ul>
<li><p><strong>imag</strong> 属性</p>
<ul>
<li>存放数组的虚部</li>
</ul>
<p><code>In: b.imag</code><br><code>[1. 2.]</code></p>
</li>
</ul>
<ul>
<li><p>如果数组含有复数，那么它的数据类型将自动变为复数型</p>
<p><code>In: b.dtype</code><br><code>complex128</code><br><code>In: b.dtype.str</code><br><code>&lt;c16</code></p>
</li>
</ul>
<ul>
<li><p><strong>flat</strong> 属性</p>
<ul>
<li><p>可返回一个 <strong>numpy.flatiter</strong> 对象，这是获得 <strong>flatiter</strong> 对象的唯一方法，</p>
</li>
<li><p>但我们无法访问 <strong>flatiter</strong> 的构造函数。可以使用 <strong>flat的迭代器</strong> 来遍历数组。</p>
</li>
</ul>
</li>
</ul>
<p>  <code>In: b = arange(4).reshape(2,2)</code><br>  <code>In: b</code><br>  <code>[[0 1]</code><br>   <code>[2 3]]</code><br>  <code>In: f = b.flat</code><br>  <code>In: f</code><br>  <code>&lt;numpy.flatiter object at 0x10207a200&gt;</code><br>  <code>In: for it in f: print it</code><br>  <code>0</code><br>  <code>1</code><br>  <code>2</code><br>  <code>3</code></p>
<ul>
<li><p>获取元素</p>
<p><code>In: b.flat[2]</code><br><code>2</code><br><code>In: b.flat[[1,3]]</code><br><code>[1 3]</code></p>
</li>
</ul>
<ul>
<li><p>给 flat 属性赋值。</p>
<ul>
<li>这个值将会覆盖整个数组内所有元素的值</li>
</ul>
<p><code>In: b.flat = 7</code><br><code>[[7 7]</code><br><code>[7 7]]</code></p>
<p><code>In: e.flat[[1, 3]] = 1</code><br><code>[[7 1]</code><br><code>[7 1]]</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">b = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">12</span>)</span><br><span class="line">print(<span class="string">'\n b: \n'</span>, b)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\b b.ndim: \n'</span>, b.ndim)      <span class="comment"># ndim属性存储的是维度的数量</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\b b.size: \n'</span>, b.size)      <span class="comment"># size属性用来保存元素的数量</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\b b.itemsize: \n'</span>, b.itemsize)      <span class="comment"># itemsize属性可以返回数组中各个元素所占用的字节数</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\b b.nbytes: \n'</span>, b.nbytes)      <span class="comment"># nbytes属性返回存储整个数组所需的字节数 = itemsize * size</span></span><br><span class="line">print(<span class="string">'\b b.itemsize * b.size: \n'</span>, b.itemsize * b.size)</span><br><span class="line"></span><br><span class="line">b.resize(<span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line">print(<span class="string">'\b b: \n'</span>, b)</span><br><span class="line">print(<span class="string">'\b b.T: \n'</span>, b.T)      <span class="comment"># T属性 转置</span></span><br><span class="line"></span><br><span class="line">c = np.arange(<span class="number">5</span>).reshape(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">print(<span class="string">'\b c.ndim: \n'</span>, c.ndim)      <span class="comment"># ndim属性</span></span><br><span class="line">print(<span class="string">'\b c.T: \n'</span>, c.T)      <span class="comment"># T属性 转置</span></span><br><span class="line"></span><br><span class="line">d = np.array([<span class="number">1.j</span> + <span class="number">1</span>, <span class="number">2.j</span> + <span class="number">3</span>])</span><br><span class="line">print(<span class="string">'\n d: \n'</span>, d)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n d.real: \n'</span>, d.real)      <span class="comment"># real属性返回数组的实部，当数组元素全为实数时，就返回数组本身</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n d.imag: \n'</span>, d.imag)      <span class="comment"># imag属性存放数组的虚部</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n d.dtype: \n'</span>, d.dtype)</span><br><span class="line">print(<span class="string">'\n d.dtype.str: \n'</span>, d.dtype.str)</span><br><span class="line"></span><br><span class="line">e = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">print(<span class="string">'\n e: \n'</span>, e)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n e.flat: \n'</span>, e.flat)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">flat属性可返回一个numpy.flatiter对象，这是获得flatiter对象的唯一方法，</span></span><br><span class="line"><span class="string">但我们无法访问flatiter的构造函数。可以使用flat的迭代器来遍历数组。</span></span><br><span class="line"><span class="string"> '''</span></span><br><span class="line">f = e.flat</span><br><span class="line">print(<span class="string">'\n e.flat_print: '</span>)</span><br><span class="line">[print(it) <span class="keyword">for</span> it <span class="keyword">in</span> f]</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n e.flat[2]: \n'</span>, e.flat[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n e.flat[[1, 3]]: \n'</span>, e.flat[[<span class="number">1</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">e.flat = <span class="number">7</span></span><br><span class="line">print(<span class="string">'\n e.flat = 7, e: \n'</span>, e)</span><br><span class="line"></span><br><span class="line">e.flat[[<span class="number">1</span>, <span class="number">3</span>]] = <span class="number">1</span></span><br><span class="line">print(<span class="string">'\n e.flat[[1, 3]] = 1, e: \n'</span>, e)</span><br></pre></td></tr></table></figure>

<h4 id="2-6-4-数组的转换"><a href="#2-6-4-数组的转换" class="headerlink" title="2.6.4 数组的转换"></a>2.6.4 数组的转换</h4><p>可以把 NumPy 数组转换成 Python 列表，使用 <strong>tolist()</strong> 函数</p>
<ul>
<li><p><strong>转换成列表</strong></p>
<p><code>In: b</code><br><code>[1.+1.j 3.+2.j]</code><br><code>In: b.tolist()</code><br><code>[(1+1j), (3+2j)]</code></p>
</li>
</ul>
<ul>
<li><p><strong>astype()</strong> 函数</p>
<ul>
<li>可以把数组元素转换成指定类型</li>
</ul>
<p><code>In: b.astype(int):</code> </p>
<p><code>/Users/hhh/Desktop/python/python数据分析/第二章：NumPy数组/2-6-4 数组的转换.py:9: ComplexWarning: Casting complex values to real discards the imaginary part</code><br>  <code>print(b.astype(int))</code><br> <code>[1 3]</code></p>
<p> <code>In: b.astype(&#39;comlex&#39;):</code><br> <code>[1.+1.j 3.+2.j]</code></p>
</li>
</ul>
<ul>
<li><strong>提示</strong><ul>
<li>当complex类型转成int类型时，虚部将被丢弃，抛出警告</li>
<li>需要将数据类型的名称以字符串的形式传递给 astype() 函数</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">b = np.array([<span class="number">1.j</span> + <span class="number">1</span>, <span class="number">2.j</span> + <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n b: \n'</span>, b)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n b.tolist(): \n'</span>, b.tolist())</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n b.astype(int): \n'</span>, b.astype(int))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\n b.astype('comlex'): \n"</span>, b.astype(<span class="string">'complex'</span>))</span><br></pre></td></tr></table></figure>

<h3 id="2-7-创建数组的视图和拷贝"><a href="#2-7-创建数组的视图和拷贝" class="headerlink" title="2.7 创建数组的视图和拷贝"></a>2.7 创建数组的视图和拷贝</h3><p>我们可以根据著名的 <strong>ascent</strong> 照片来创建数组，然后创建视图，随后修改它。</p>
<p>这里，ascent肖像的数组是从 <strong>SciPy</strong> 函数获得的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">	此后的代码会将取得的图片命名为 lena，是为了防止与我使用的书（《Python数据分析》（第二版））中的代码相不同。</span><br><span class="line">	这本书所使用的lena图像在新版的 SciPy （我用的是1.3.0）中已经删除，但是我们可以换成 ascent 图像，不影响学习和使用。</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.misc</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">lena = scipy.misc.ascent()</span><br><span class="line"></span><br><span class="line">acopy = lena.copy()</span><br><span class="line">aview = lena.view()</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">231</span>)</span><br><span class="line">plt.title(<span class="string">'lena(befor)'</span>)</span><br><span class="line">plt.imshow(lena)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">232</span>)</span><br><span class="line">plt.title(<span class="string">'acopy(befor)'</span>)</span><br><span class="line">plt.imshow(acopy)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">233</span>)</span><br><span class="line">plt.title(<span class="string">'aview(befor)'</span>)</span><br><span class="line">plt.imshow(aview)</span><br><span class="line"></span><br><span class="line">aview.flat = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">234</span>)</span><br><span class="line">plt.title(<span class="string">'lena(after)'</span>)</span><br><span class="line">plt.imshow(lena)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">235</span>)</span><br><span class="line">plt.title(<span class="string">'acopy(after)'</span>)</span><br><span class="line">plt.imshow(acopy)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">236</span>)</span><br><span class="line">plt.title(<span class="string">'aview(after)'</span>)</span><br><span class="line">plt.imshow(aview)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建一份ascent数组的副本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acopy = lena.copy()</span><br></pre></td></tr></table></figure>
</li>
<li><p>为该数组创建一个视图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aview = lena.view()</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 flat 迭代器将视图中的所有值全部设为0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aview.flat = <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后结果如图</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%20Data%20Analysis/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20NumPy%E6%95%B0%E7%BB%84/2.png" alt="2"></p>
<p>可见，在程序部分修改视图，同时改变了原来的数组。</p>
<p><strong><em>所以一定要记住：视图不是只读的</em></strong></p>
<h3 id="2-8-花式索引"><a href="#2-8-花式索引" class="headerlink" title="2.8 花式索引"></a>2.8 花式索引</h3><p>花式索引是一种传统的索引方法，它不使用整数或者切片。</p>
<p>这里，我们利用花式索引把图片对角线上的值全部置0，相当于沿着两条交叉的对角线画两条黑线。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.misc</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">lena = scipy.misc.ascent()</span><br><span class="line"></span><br><span class="line">xmax = lena.shape[<span class="number">0</span>]</span><br><span class="line">ymax = lena.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">lena[range(xmax), range(ymax)] = <span class="number">0</span></span><br><span class="line">lena[range(xmax<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>), range(ymax)] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">plt.imshow(lena)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<ol>
<li><p>将第一条对角线上的值设为0</p>
<p>为了给对角线上的值置0，需要给 x 和 y 值（直角坐标系中的坐标）规定两个不同的范围</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lena[range(xmax), range(ymax)] = <span class="number">0</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>将另一条对角线上的值设为0</p>
<p>要设置另一条对角线上的值，需要规定两个不同的取值范围，但是规则不变</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lena[range(xmax<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>), range(ymax)] = <span class="number">0</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>效果</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%20Data%20Analysis/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20NumPy%E6%95%B0%E7%BB%84/3.png" alt="3"></p>
</li>
</ol>
<p>我们给 x 和 y 规定了不同的取值范围，这些范围用来索引图片数组。</p>
<p>花式索引是在一个内部的NumPy迭代器对象的基础上实现的，分3部完成：</p>
<ol>
<li>创建迭代器对象</li>
<li>将迭代器对象绑定到数组</li>
<li>经由迭代器访问数组元素，利用位置列表进行索引</li>
</ol>
<h3 id="2-9-基于位置列表的索引方法"><a href="#2-9-基于位置列表的索引方法" class="headerlink" title="2.9 基于位置列表的索引方法"></a>2.9 基于位置列表的索引方法</h3><p>下面利用 <strong>ix_()</strong> 函数将照片中的像素完全打乱。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.misc</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lena = scipy.misc.ascent()</span><br><span class="line"></span><br><span class="line">xmax = lena.shape[<span class="number">0</span>]</span><br><span class="line">ymax = lena.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffle_indices</span><span class="params">(size)</span>:</span></span><br><span class="line">    arr = np.arange(size)</span><br><span class="line">    np.random.shuffle(arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">xindices = shuffle_indices(xmax)</span><br><span class="line">np.testing.assert_equal(len(xindices), xmax)</span><br><span class="line"></span><br><span class="line">yindices = shuffle_indices(ymax)</span><br><span class="line">np.testing.assert_equal(len(yindices), ymax)</span><br><span class="line"></span><br><span class="line">plt.imshow(lena[np.ix_(xindices, yindices)])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p> <strong>ix_()</strong> ：这个函数可以根据多个序列生成一个网格，它需要一个一维序列作为参数，并返回一个由NumPy数组构成的元组。</p>
<p><code>In: ix_([0, 1], [2, 3])</code>                                                     </p>
<p><code>Out:</code> </p>
<p><code>(array([[0],</code></p>
<p>​                <code>[1]]), array([[2, 3]]))</code></p>
<p>利用位置列表索引NumPy数组的过程：</p>
<ol>
<li><p>打乱数组的索引</p>
<p>利用 <strong>numpy.random</strong> 子程序包中的 <strong>shuffle()</strong> 函数把数组中的元素按随机的索引号重新排列，使得数组产生相应变化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffle_indices</span><span class="params">(size)</span>:</span></span><br><span class="line">    arr = np.arange(size)</span><br><span class="line">    np.random.shuffle(arr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>使用下面的代码画出打乱后的索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(lena[np.ix_(xindices, yindices)])</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li>视图</li>
</ol>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%20Data%20Analysis/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20NumPy%E6%95%B0%E7%BB%84/4.png" alt="4"></p>
<h3 id="2-10-用布尔型变量索引NumPy数组"><a href="#2-10-用布尔型变量索引NumPy数组" class="headerlink" title="2.10  用布尔型变量索引NumPy数组"></a>2.10  用布尔型变量索引NumPy数组</h3><p>布尔型索引是指根据布尔型数组来索引元素的方法，属于花式索引系列。</p>
<p>因为布尔型索引是花式索引的一个分类，所以它们的使用方法基本相同。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.misc</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">lena = scipy.misc.ascent()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_indices</span><span class="params">(size)</span>:</span></span><br><span class="line">    arr = np.arange(size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr%<span class="number">4</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">lena1 = lena.copy()</span><br><span class="line"></span><br><span class="line">xindices = get_indices(lena.shape[<span class="number">0</span>])</span><br><span class="line">yindices = get_indices(lena.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">lena1[xindices, yindices] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.imshow(lena1)</span><br><span class="line"></span><br><span class="line">lena2 = lena.copy()</span><br><span class="line">lena2[(lena &gt; lena.max()/<span class="number">4</span>) &amp; (lena &lt; <span class="number">3</span> * lena.max()/<span class="number">4</span>)] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.imshow(lena2)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>上述代码利用一种特殊的迭代器对象来索引元素，下面进行简单说明。</p>
<ol>
<li><p>在对角线上画点。</p>
<p>这类似于花式索引，不过这里选择的是照片对照线上可以被 4 整除的那些位置上的点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_indices</span><span class="params">(size)</span>:</span></span><br><span class="line">    arr = np.arange(size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr%<span class="number">4</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   然后仅绘出选定的那些点</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lena1 = lena.copy()</span><br><span class="line"></span><br><span class="line">xindices = get_indices(lena.shape[0])</span><br><span class="line">yindices = get_indices(lena.shape[1])</span><br><span class="line"></span><br><span class="line">lena1[xindices, yindices] = 0</span><br><span class="line"></span><br><span class="line">plt.subplot(211)</span><br><span class="line">plt.imshow(lena1)</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>根据元素值的情况置0</p>
<p>选取数组之介于最大值的1/4 到 3/4 到那些元素，将其置0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lena2[(lena &gt; lena.max()/<span class="number">4</span>) &amp; (lena &lt; <span class="number">3</span> * lena.max()/<span class="number">4</span>)] = <span class="number">0</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li>两幅新照片如图</li>
</ol>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%20Data%20Analysis/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20NumPy%E6%95%B0%E7%BB%84/5.png" alt="5"></p>
<h3 id="2-11-NumPy数组的广播"><a href="#2-11-NumPy数组的广播" class="headerlink" title="2.11  NumPy数组的广播"></a>2.11  NumPy数组的广播</h3><p>当操作对象的形状不一样，NumPy会尽力进行处理。</p>
<p>例如，假设一个数组要跟一个标量相乘，这时标量需要根据数组的形状进行扩展。然后才可以执行乘法运算，这个扩展的过程叫做 <strong>广播(broadcasting)</strong>。</p>
<p>下面用代码加以说明。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.io.wavfile</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">response = request.urlopen(</span><br><span class="line">    <span class="string">'http://www.crt.com.cn/hsmx/images/hsgq.mp3'</span></span><br><span class="line">    <span class="comment"># 'http://www.thesoundarchive.com/austinpowers/smashingbaby.wav'</span></span><br><span class="line">)</span><br><span class="line">print(response.info())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WAV_FILE = <span class="string">'smashingbaby.wav'</span></span><br><span class="line"></span><br><span class="line">filehandle = open(WAV_FILE, <span class="string">'wb'</span>)</span><br><span class="line">filehandle.write(response.read())</span><br><span class="line">filehandle.close()</span><br><span class="line"></span><br><span class="line">sample_rate, data = scipy.io.wavfile.read(WAV_FILE)</span><br><span class="line">print(<span class="string">"Data type"</span>, data.dtype, <span class="string">"Shape"</span>, data.shape)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">"Original"</span>)</span><br><span class="line">plt.plot(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">newdata = data * <span class="number">0.2</span></span><br><span class="line">newdata = newdata.astype(np.uint8)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Data type"</span>, newdata.dtype, <span class="string">"Shape"</span>, newdata.shape)</span><br><span class="line"></span><br><span class="line">scipy.io.wavfile.write(<span class="string">"quiet.wav"</span>, sample_rate, newdata)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.title(<span class="string">"Quiet"</span>)</span><br><span class="line">plt.plot(newdata)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/04/python全栈/第02部分：并发编程+数据库+前端/并发编程/线程（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/04/python全栈/第02部分：并发编程+数据库+前端/并发编程/线程（一）/" itemprop="url">线程（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-04T18:43:22+08:00">
                2019-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-02部分-并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -02部分 -并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="（一）操作系统线程理论"><a href="#（一）操作系统线程理论" class="headerlink" title="（一）操作系统线程理论"></a>（一）操作系统线程理论</h2><h3 id="一、线程概念的引入背景"><a href="#一、线程概念的引入背景" class="headerlink" title="一、线程概念的引入背景"></a>一、线程概念的引入背景</h3><h4 id="1、线程"><a href="#1、线程" class="headerlink" title="1、线程"></a>1、线程</h4><p>​        之前我们已经了解了操作系统中进程的概念，程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</p>
<h4 id="2、有了进程为什么要有线程"><a href="#2、有了进程为什么要有线程" class="headerlink" title="2、有了进程为什么要有线程"></a>2、有了进程为什么要有线程</h4><p>​        进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：</p>
<ul>
<li>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</li>
<li>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</li>
</ul>
<p>　　如果这两个缺点理解比较困难的话，举个现实的例子也许你就清楚了：如果把我们上课的过程看成一个进程的话，那么我们要做的是耳朵听老师讲课，手上还要记笔记，脑子还要思考问题，这样才能高效的完成听课的任务。而如果只提供进程这个机制的话，上面这三件事将不能同时执行，同一时间只能做一件事，听的时候就不能记笔记，也不能用脑子思考，这是其一；如果老师在黑板上写演算过程，我们开始记笔记，而老师突然有一步推不下去了，阻塞住了，他在那边思考着，而我们呢，也不能干其他事，即使你想趁此时思考一下刚才没听懂的一个问题都不行，这是其二。</p>
<p>　　现在你应该明白了进程的缺陷了，而解决的办法很简单，我们完全可以让听、写、思三个独立的过程，并行起来，这样很明显可以提高听课的效率。而实际的操作系统中，也同样引入了这种类似的机制——线程。</p>
<h4 id="3、线程的出现"><a href="#3、线程的出现" class="headerlink" title="3、线程的出现"></a>3、线程的出现</h4><p>​        60年代，在OS中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入<strong>轻型进程</strong>；二是由于对称多处理机（SMP）出现，<strong>可以满足多个运行单位</strong>，而多个进程并行开销过大。</p>
<p>　　因此在80年代，出现了<strong>能独立运行的基本单位</strong>——线程（Threads）<strong>。</strong></p>
<p>　　<strong>注意：进程是资源分配的最小单位,线程是CPU调度的最小单位.</strong></p>
<p>　　　　　<strong>每一个进程中至少有一个线程。</strong></p>
<h3 id="二、进程和线程的关系"><a href="#二、进程和线程的关系" class="headerlink" title="二、进程和线程的关系"></a>二、进程和线程的关系</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/14.png" alt></p>
<p><strong>线程与进程的区别</strong>可以归纳为以下4点：</p>
<p>　　1）地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</p>
<p>　　2）通信：<a href="https://baike.baidu.com/item/进程间通信" target="_blank" rel="noopener">进程间通信</a><a href="https://baike.baidu.com/item/IPC" target="_blank" rel="noopener">IPC</a>，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要<a href="https://baike.baidu.com/item/进程同步" target="_blank" rel="noopener">进程同步</a>和互斥手段的辅助，以保证数据的一致性。</p>
<p>　　3）调度和切换：线程上下文切换比进程上下文切换要快得多。</p>
<p>　　4）在多线程操作系统中，进程不是一个可执行的实体。</p>
<p>　　<a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">通过漫画了解线程进城</a></p>
<h3 id="三、线程的特点"><a href="#三、线程的特点" class="headerlink" title="三、线程的特点"></a>三、线程的特点</h3><p>在多线程的操作系统中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。</p>
<p>　　1）轻型实体</p>
<p>　　线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。</p>
<p>　　线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TCB包括以下信息：</span><br><span class="line">（1）线程状态。</span><br><span class="line">（2）当线程不运行时，被保存的现场资源。</span><br><span class="line">（3）一组执行堆栈。</span><br><span class="line">（4）存放每个线程的局部变量主存区。</span><br><span class="line">（5）访问同一个进程中的主存和其它资源。</span><br><span class="line">用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</span><br></pre></td></tr></table></figure>

<p>　　2）独立调度和分派的基本单位。</p>
<p>　　在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</p>
<p>　　3）共享进程资源。</p>
<p>　　线程在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的进程id，这意味着，线程可以访问该进程的每一个内存资源；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。</p>
<p>　　4<em>）可并发执行。</em></p>
<p>　　<em>在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</em></p>
<h3 id="四、使用线程的实际场景"><a href="#四、使用线程的实际场景" class="headerlink" title="四、使用线程的实际场景"></a>四、使用线程的实际场景</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/15.png" alt></p>
<p>​        开启一个字处理软件进程，该进程肯定需要办不止一件事情，比如监听键盘输入，处理文字，定时自动将文字保存到硬盘，这三个任务操作的都是同一块数据，因而不能用多进程。只能在一个进程里并发地开启三个线程,如果是单线程，那就只能是，键盘输入时，不能处理文字和自动保存，自动保存时又不能输入和处理文字。</p>
<h3 id="五、内存中的线程"><a href="#五、内存中的线程" class="headerlink" title="五、内存中的线程"></a>五、内存中的线程</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/16.png" alt></p>
<p>​        多个线程共享同一个进程的地址空间中的资源，是对一台计算机上多个进程的模拟，有时也称线程为轻量级的进程。</p>
<p>　　而对一台计算机上多个进程，则共享物理内存、磁盘、打印机等其他物理资源。多线程的运行也多进程的运行类似，是cpu在多个线程之间的快速切换。</p>
<p>　　不同的进程之间是充满敌意的，彼此是抢占、竞争cpu的关系，如果迅雷会和QQ抢资源。而同一个进程是由一个程序员的程序创建，所以同一进程内的线程是合作关系，一个线程可以访问另外一个线程的内存地址，大家都是共享的，一个线程干死了另外一个线程的内存，那纯属程序员脑子有问题。</p>
<p>　　类似于进程，每个线程也有自己的堆栈，不同于进程，线程库无法利用时钟中断强制线程让出CPU，可以调用thread_yield运行线程自动放弃cpu，让另外一个线程运行。</p>
<p>　　线程通常是有益的，但是带来了不小程序设计难度，线程的问题是：</p>
<p>　　1. 父进程有多个线程，那么开启的子线程是否需要同样多的线程</p>
<p>　　2. 在同一个进程中，如果一个线程关闭了文件，而另外一个线程正准备往该文件内写内容呢？</p>
<p>　　因此，在多线程的代码中，需要更多的心思来设计程序的逻辑、保护程序的数据。</p>
<h3 id="六、用户级线程和内核级线程（了解）"><a href="#六、用户级线程和内核级线程（了解）" class="headerlink" title="六、用户级线程和内核级线程（了解）"></a>六、用户级线程和内核级线程（了解）</h3><p>​        线程的实现可以分为两类：用户级线程(User-Level Thread)和内核线线程(Kernel-Level Thread)，后者又称为内核支持的线程或轻量级进程。在多线程操作系统中，各个系统的实现方式并不相同，在有的系统中实现了用户级线程，有的系统中实现了内核级线程。</p>
<h4 id="1、用户级线程"><a href="#1、用户级线程" class="headerlink" title="1、用户级线程"></a>1、用户级线程</h4><p>​        内核的切换由用户态程序自己控制内核切换,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/17.png" alt></p>
<p>​        在用户空间模拟操作系统对进程的调度，来调用一个进程中的线程，每个进程中都会有一个运行时系统，用来调度线程。此时当该进程获取cpu时，进程内再调度出一个线程去执行，同一时刻只有一个线程执行。</p>
<h4 id="2、内核级线程"><a href="#2、内核级线程" class="headerlink" title="2、内核级线程"></a>2、内核级线程</h4><p>​        内核级线程:切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/18.png" alt></p>
<h4 id="3、用户级与内核级线程的对比"><a href="#3、用户级与内核级线程的对比" class="headerlink" title="3、用户级与内核级线程的对比"></a>3、用户级与内核级线程的对比</h4><p>用户级线程和内核级线程的区别:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。</span><br><span class="line">用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。</span><br><span class="line">用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。</span><br><span class="line">在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。</span><br><span class="line">用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。</span><br></pre></td></tr></table></figure>

<p>内核线程的优缺点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：当有多个处理机时，一个进程的多个线程可以同时执行。</span><br><span class="line">缺点：由内核进行调度。</span><br></pre></td></tr></table></figure>

<p>用户级线程的优缺点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">		线程的调度不需要内核直接参与，控制简单。</span><br><span class="line">		可以在不支持线程的操作系统中实现。</span><br><span class="line">		创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。</span><br><span class="line">		允许每个进程定制自己的调度算法，线程管理比较灵活。</span><br><span class="line">		线程能够利用的表空间和堆栈空间比内核级线程多。</span><br><span class="line">		同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题。</span><br><span class="line">		</span><br><span class="line">缺点：</span><br><span class="line">		资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</span><br></pre></td></tr></table></figure>

<h4 id="4、混合实现"><a href="#4、混合实现" class="headerlink" title="4、混合实现"></a>4、混合实现</h4><p>用户级与内核级的多路复用，内核同一调度内核线程，每个内核线程对应n个用户线程</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/19.png" alt></p>
<p><strong>Linux操作系统的NPTL</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">历史</span><br><span class="line">		在内核2.6以前的调度实体都是进程，内核并没有真正支持线程。它是能过一个系统调用clone()来实现的，这个调用创建了一份调用进程的拷贝，跟fork()不同的是,这份进程拷贝完全共享了调用进程的地址空间。LinuxThread就是通过这个系统调用来提供线程在内核级的支持的(许多以前的线程实现都完全是在用户态，内核根本不知道线程的存在)。非常不幸的是，这种方法有相当多的地方没有遵循POSIX标准，特别是在信号处理，调度，进程间通信原语等方面。</span><br><span class="line"></span><br><span class="line">		很显然，为了改进LinuxThread必须得到内核的支持，并且需要重写线程库。为了实现这个需求，开始有两个相互竞争的项目：IBM启动的NGTP(Next Generation POSIX Threads)项目，以及Redhat公司的NPTL。在2003年的年中，IBM放弃了NGTP，也就是大约那时，Redhat发布了最初的NPTL。</span><br><span class="line"></span><br><span class="line">		NPTL最开始在redhat linux 9里发布，现在从RHEL3起内核2.6起都支持NPTL，并且完全成了GNU C库的一部分。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设计</span><br><span class="line">		NPTL使用了跟LinuxThread相同的办法，在内核里面线程仍然被当作是一个进程，并且仍然使用了clone()系统调用(在NPTL库里调用)。但是，NPTL需要内核级的特殊支持来实现，比如需要挂起然后再唤醒线程的线程同步原语futex.</span><br><span class="line"></span><br><span class="line">		NPTL也是一个1*1的线程库，就是说，当你使用pthread_create()调用创建一个线程后，在内核里就相应创建了一个调度实体，在linux里就是一个新进程，这个方法最大可能的简化了线程的实现。</span><br><span class="line"></span><br><span class="line">		除NPTL的1*1模型外还有一个m*n模型，通常这种模型的用户线程数会比内核的调度实体多。在这种实现里，线程库本身必须去处理可能存在的调度，这样在线程库内部的上下文切换通常都会相当的快，因为它避免了系统调用转到内核态。然而这种模型增加了线程实现的复杂性,并可能出现诸如优先级反转的问题，此外，用户态的调度如何跟内核态的调度进行协调也是很难让人满意。</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/03/python全栈/第02部分：并发编程+数据库+前端/并发编程/进程（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/03/python全栈/第02部分：并发编程+数据库+前端/并发编程/进程（二）/" itemprop="url">进程（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-03T20:37:27+08:00">
                2019-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-02部分-并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -02部分 -并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="（二）在python程序中的进程操作"><a href="#（二）在python程序中的进程操作" class="headerlink" title="（二）在python程序中的进程操作"></a>（二）在python程序中的进程操作</h2><p>​        之前我们已经了解了很多进程相关的理论知识，了解进程是什么应该不再困难了，刚刚我们已经了解了，运行中的程序就是一个进程。所有的进程都是通过它的父进程来创建的。因此，运行起来的python程序也是一个进程，那么我们也可以在程序中再创建进程。多个进程可以实现并发效果，也就是说，当我们的程序中存在多个进程的时候，在某些时候，就会让程序的执行速度变快。以我们之前所学的知识，并不能实现创建进程这个功能，所以我们就需要借助python中强大的模块。</p>
<h3 id="一、multiprocess模块"><a href="#一、multiprocess模块" class="headerlink" title="一、multiprocess模块"></a>一、multiprocess模块</h3><p>​        仔细说来，multiprocess不是一个模块而是python中一个操作、管理进程的包。 之所以叫multi是取自multiple的多功能的意思,在这个包中几乎包含了和进程有关的所有子模块。由于提供的子模块非常多，为了方便大家归类记忆，我将这部分大致分为四个部分：创建进程部分，进程同步部分，进程池部分，进程之间数据共享。</p>
<h3 id="二、multiprocess-process模块"><a href="#二、multiprocess-process模块" class="headerlink" title="二、multiprocess.process模块"></a>二、multiprocess.process模块</h3><h4 id="1、process模块介绍"><a href="#1、process模块介绍" class="headerlink" title="1、process模块介绍"></a>1、process模块介绍</h4><p>process模块是一个创建进程的模块，借助这个模块，就可以完成进程的创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</span><br><span class="line"></span><br><span class="line">强调：</span><br><span class="line">1. 需要使用关键字的方式来指定参数</span><br><span class="line">2. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号</span><br><span class="line"></span><br><span class="line">参数介绍：</span><br><span class="line">group参数未使用，值始终为None</span><br><span class="line">target表示调用对象，即子进程要执行的任务</span><br><span class="line">args表示调用对象的位置参数元组，args=(1,2,&apos;egon&apos;,)</span><br><span class="line">kwargs表示调用对象的字典,kwargs=&#123;&apos;name&apos;:&apos;egon&apos;,&apos;age&apos;:18&#125;</span><br><span class="line">name为子进程的名称</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法介绍:</span><br><span class="line">p.start()：启动进程，并调用该子进程中的p.run() </span><br><span class="line">p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  </span><br><span class="line">p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</span><br><span class="line">p.is_alive():如果p仍然运行，返回True</span><br><span class="line">p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性介绍:</span><br><span class="line">p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置</span><br><span class="line">p.name:进程的名称</span><br><span class="line">p.pid：进程的pid</span><br><span class="line">p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)</span><br><span class="line">p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在Windows操作系统中由于没有fork(linux操作系统中创建进程的机制)，在创建子进程的时候会自动 import 启动它的这个文件，而在 import 的时候又执行了整个文件。因此如果将process()直接写在文件中就会无限递归创建子进程报错。所以必须把创建子进程的部分使用if __name__ ==‘__main__’ 判断保护起来，import 的时候  ，就不会递归运行了。</span><br></pre></td></tr></table></figure>

<h4 id="2、使用process模块创建进程"><a href="#2、使用process模块创建进程" class="headerlink" title="2、使用process模块创建进程"></a>2、使用process模块创建进程</h4><p>在一个python进程中开启子进程，start方法和并发效果。</p>
<p>在python中启动的第一个子进程:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line">    print(<span class="string">'我是子进程'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'执行主进程的内容了'</span>)</span><br></pre></td></tr></table></figure>

<p>查看主进程和子进程的进程号:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'子进程id ：'</span>,os.getpid(),<span class="string">'父进程id ：'</span>,os.getppid())</span><br></pre></td></tr></table></figure>

<p>一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(args,args2)</span>:</span></span><br><span class="line">    print(args,args2)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">'子进程 :'</span>, os.getpid())</span><br><span class="line">    print(<span class="string">'子进程的父进程 :'</span>, os.getppid())</span><br><span class="line">    print(<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=func,args=(<span class="string">'参数'</span>,<span class="string">'参数2'</span>))   <span class="comment"># 注册，参数必须为元组类型</span></span><br><span class="line">    <span class="comment"># p是一个进程对象,还没有启动进程</span></span><br><span class="line">    p.start()       <span class="comment"># 开启了一个子进程</span></span><br><span class="line">    print(<span class="string">'*'</span>*<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">'父进程 :'</span>,os.getpid()) <span class="comment"># 查看当前进程的进程号</span></span><br><span class="line">    print(<span class="string">'父进程的父进程 :'</span>,os.getppid()) <span class="comment"># 查看当前进程的父进程，即为pyCharm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程的生命周期</span></span><br><span class="line">    <span class="comment"># 主进程</span></span><br><span class="line">    <span class="comment"># 子进程</span></span><br><span class="line">    <span class="comment"># 开启了子进程的主进程 :</span></span><br><span class="line">        <span class="comment"># 主进程自己的代码如果长,等待自己的代码执行结束,</span></span><br><span class="line">        <span class="comment"># 子进程的执行时间长,主进程会在主进程代码执行完毕之后等待子进程执行完毕之后 主进程才结束</span></span><br></pre></td></tr></table></figure>

<p>join方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># join()</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg1,arg2)</span>:</span></span><br><span class="line">    print(<span class="string">'*'</span>*arg1)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'*'</span>*arg2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=func,args=(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line">    p.start()</span><br><span class="line">    print(<span class="string">'hahahaha'</span>)</span><br><span class="line">    p.join()     <span class="comment"># 是感知一个子进程的结束,将异步的程序改为同步</span></span><br><span class="line">    print(<span class="string">'====== : 运行完了'</span>)</span><br></pre></td></tr></table></figure>

<p>进阶，多个进程同时运行（注意，子进程的执行顺序不是根据启动顺序决定的）</p>
<p>多个进程同时运行:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">        p.start()</span><br><span class="line">        p_lst.append(p)</span><br></pre></td></tr></table></figure>

<p>多个进程同时运行，再谈join方法(1):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">        p.start()</span><br><span class="line">        p_lst.append(p)</span><br><span class="line">        p.join()</span><br><span class="line">    <span class="comment"># [p.join() for p in p_lst]</span></span><br><span class="line">    print(<span class="string">'父进程在执行'</span>)</span><br></pre></td></tr></table></figure>

<p>多个进程同时运行，再谈join方法(2):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>, name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = Process(target=f, args=(<span class="string">'bob'</span>,))</span><br><span class="line">        p.start()</span><br><span class="line">        p_lst.append(p)</span><br><span class="line">    <span class="comment"># [p.join() for p in p_lst]</span></span><br><span class="line">    print(<span class="string">'父进程在执行'</span>)</span><br></pre></td></tr></table></figure>

<p>一个实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(filename,content)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(content*<span class="number">10</span>*<span class="string">'*'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p_lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=func,args=(<span class="string">'info%s'</span>%i,<span class="number">0</span>))</span><br><span class="line">        p_lst.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_lst:p.join()   <span class="comment"># 之前的所有进程必须在这里都执行完才能执行下面的代码</span></span><br><span class="line">    print([i <span class="keyword">for</span> i <span class="keyword">in</span> os.walk(<span class="string">r'/Users/hhh/Desktop/python/全栈/第02部分：并发编程+数据库+前端/并发编程/day37'</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程写文件</span></span><br><span class="line"><span class="comment"># 首先往文件夹中写文件</span></span><br><span class="line"><span class="comment"># 向用户展示写入文件之后文件夹中所有的文件名（此步骤应该确保所有写文件操作已经结束）———— 这就是应用场景</span></span><br></pre></td></tr></table></figure>

<p>除了上面这些开启进程的方法，还有一种以继承Process类的形式开启进程的方式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(os.getpid)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  print(<span class="string">'主：'</span>, os.getpid())</span><br><span class="line">  p1 = MyProcess()</span><br><span class="line">  p1.start()</span><br><span class="line">  p2 = MyProcess()</span><br><span class="line">  p2.start()</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 自定义类 继承Process类</span></span><br><span class="line"><span class="comment"># 必须实现一个run方法,run方法中是在子进程中执行的代码</span></span><br><span class="line"><span class="comment"># start()内部会实现run()方法</span></span><br></pre></td></tr></table></figure>

<p>传参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,arg1,arg2)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.arg1 = arg1</span><br><span class="line">        self.arg2 = arg2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.pid)</span><br><span class="line">        print(self.name)</span><br><span class="line">        print(self.arg1)</span><br><span class="line">        print(self.arg2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p1 = MyProcess(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2 = MyProcess(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    p2.start()</span><br></pre></td></tr></table></figure>

<p>进程之间的数据隔离问题:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进程 与 进程之间</span></span><br><span class="line"><span class="comment"># 几个进程之间，若不通过特殊手段，无法共享数据</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> n   <span class="comment"># 声明了一个全局变量</span></span><br><span class="line">    n = <span class="number">0</span>       <span class="comment"># 重新定义了一个n</span></span><br><span class="line">    print(<span class="string">'pid : %s'</span>%os.getpid(),n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = <span class="number">100</span></span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(os.getpid(),n)</span><br></pre></td></tr></table></figure>

<h4 id="3、守护进程"><a href="#3、守护进程" class="headerlink" title="3、守护进程"></a>3、守护进程</h4><p>会随着主进程的结束而结束。</p>
<p>主进程创建守护进程</p>
<p>　　其一：守护进程会在主进程代码执行结束后就终止</p>
<p>　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children</p>
<p>注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子进程 -- &gt; 守护进程</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        print(<span class="string">'我还活着'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in func2 start'</span>)</span><br><span class="line">    time.sleep(<span class="number">8</span>)</span><br><span class="line">    print(<span class="string">'in func2 finished'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.daemon = <span class="literal">True</span>   <span class="comment"># 设置子进程为守护进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    p2 = Process(target=func2)</span><br><span class="line">    p2.start()</span><br><span class="line">    p2.terminate()     <span class="comment"># 结束一个子进程</span></span><br><span class="line">    print(p2.is_alive())  <span class="comment"># 检验一个进程是否还活着</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(p2.is_alive())  <span class="comment"># 检验一个进程是否还活着</span></span><br><span class="line">    print(p2.name)</span><br><span class="line">    <span class="comment"># i = 0</span></span><br><span class="line">    <span class="comment"># while i&lt;5:</span></span><br><span class="line">    <span class="comment">#     print('我是socket server')</span></span><br><span class="line">    <span class="comment">#     time.sleep(1)</span></span><br><span class="line">    <span class="comment">#     i+=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 守护进程 会 随着 主进程的代码（而不是主进程）执行完毕 而 结束</span></span><br><span class="line"><span class="comment"># 在主进程内结束一个子进程 p.terminate()</span></span><br><span class="line">    <span class="comment">#  结束一个进程不是在执行方法之后立即生效,需要一个操作系统响应的过程</span></span><br><span class="line"><span class="comment"># 检验一个进程是否活着的状态 p.is_alive()</span></span><br><span class="line"><span class="comment"># p.name p.pid 这个进程的名字和进程号</span></span><br></pre></td></tr></table></figure>

<h4 id="4、socket聊天开发实例"><a href="#4、socket聊天开发实例" class="headerlink" title="4、socket聊天开发实例"></a>4、socket聊天开发实例</h4><p>server端:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span><span class="params">(conn)</span>:</span></span><br><span class="line">    ret = <span class="string">'你好'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    conn.send(ret)</span><br><span class="line">    msg = conn.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    print(msg)</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br><span class="line">    sk = socket.socket()</span><br><span class="line">    sk.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line">    sk.listen()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            conn,addr = sk.accept()</span><br><span class="line">            p = Process(target=serve,args=(conn,))</span><br><span class="line">            p.start()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sk.close()</span><br></pre></td></tr></table></figure>

<p>client端:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">msg = sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(msg)</span><br><span class="line">msg2 = input(<span class="string">'&gt;&gt;&gt;'</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">sk.send(msg2)</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<h4 id="5、多进程中的其他方法"><a href="#5、多进程中的其他方法" class="headerlink" title="5、多进程中的其他方法"></a>5、多进程中的其他方法</h4><p>进程对象的其他方法 :  terminate,  is_alive</p>
<p>​        在主进程内结束一个子进程 p.terminate()<br>​             结束一个进程不是在执行方法之后立即生效,需要一个操作系统响应的过程<br>​        检验一个进程是否活着的状态 p.is_alive()</p>
<p>进程对象的其他属性 : pid和name</p>
<p>​        p.name      p.pid 这个进程的名字和进程号</p>
<h3 id="三、进程同步（multiprocess-Lock）"><a href="#三、进程同步（multiprocess-Lock）" class="headerlink" title="三、进程同步（multiprocess.Lock）"></a>三、进程同步（multiprocess.Lock）</h3><h4 id="1、锁-——-multiprocess-Lock"><a href="#1、锁-——-multiprocess-Lock" class="headerlink" title="1、锁 —— multiprocess.Lock"></a>1、锁 —— multiprocess.Lock</h4><pre><code>通过刚刚的学习，我们千方百计实现了程序的异步，让多个任务可以同时在几个进程中并发处理，他们之间的运行没有顺序，一旦开启也不受我们控制。尽管并发编程让我们能更加充分的利用IO资源，但是也给我们带来了新的问题。</code></pre><p>　　  当多个进程使用同一份数据资源的时候，就会引发数据安全或顺序混乱问题。</p>
<p>多进程抢占输出资源:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s: %s is running'</span> %(n,os.getpid()))</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    print(<span class="string">'%s:%s is done'</span> %(n,os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p=Process(target=work,args=(i,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>使用锁维护执行顺序:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由并发变成了串行,牺牲了运行效率,但避免了竞争</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(lock,n)</span>:</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    print(<span class="string">'%s: %s is running'</span> % (n, os.getpid()))</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    print(<span class="string">'%s: %s is done'</span> % (n, os.getpid()))</span><br><span class="line">    lock.release()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock=Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p=Process(target=work,args=(lock,i))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>​        上面这种情况虽然使用加锁的形式实现了顺序的执行，但是程序又重新变成串行了，这样确实会浪费了时间，却保证了数据的安全。</p>
<p>　　接下来，我们以模拟抢票为例，来看看数据安全的重要性。</p>
<p>多进程同时抢购余票:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件db的内容为：&#123;"count":1&#125;</span></span><br><span class="line"><span class="comment">#注意一定要用双引号，不然json无法识别</span></span><br><span class="line"><span class="comment">#并发运行，效率高，但竞争写同一文件，数据写入错乱</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"><span class="keyword">import</span> time,json,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    dic=json.load(open(<span class="string">'db'</span>))</span><br><span class="line">    print(<span class="string">'\033[43m剩余票数%s\033[0m'</span> %dic[<span class="string">'count'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    dic=json.load(open(<span class="string">'db'</span>))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>) <span class="comment">#模拟读数据的网络延迟</span></span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">'count'</span>] &gt;<span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">'count'</span>]-=<span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>) <span class="comment">#模拟写数据的网络延迟</span></span><br><span class="line">        json.dump(dic,open(<span class="string">'db'</span>,<span class="string">'w'</span>))</span><br><span class="line">        print(<span class="string">'\033[43m购票成功\033[0m'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    search()</span><br><span class="line">    get()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): <span class="comment">#模拟并发100个客户端抢票</span></span><br><span class="line">        p=Process(target=task)</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>使用锁来保证数据安全:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件db的内容为：&#123;"count":5&#125;</span></span><br><span class="line"><span class="comment">#注意一定要用双引号，不然json无法识别</span></span><br><span class="line"><span class="comment">#并发运行，效率高，但竞争写同一文件，数据写入错乱</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"><span class="keyword">import</span> time,json,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    dic=json.load(open(<span class="string">'db'</span>))</span><br><span class="line">    print(<span class="string">'\033[43m剩余票数%s\033[0m'</span> %dic[<span class="string">'count'</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    dic=json.load(open(<span class="string">'db'</span>))</span><br><span class="line">    time.sleep(random.random()) <span class="comment">#模拟读数据的网络延迟</span></span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">'count'</span>] &gt;<span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">'count'</span>]-=<span class="number">1</span></span><br><span class="line">        time.sleep(random.random()) <span class="comment">#模拟写数据的网络延迟</span></span><br><span class="line">        json.dump(dic,open(<span class="string">'db'</span>,<span class="string">'w'</span>))</span><br><span class="line">        print(<span class="string">'\033[32m购票成功\033[0m'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'\033[31m购票失败\033[0m'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(lock)</span>:</span></span><br><span class="line">    search()</span><br><span class="line">    lock.acquire()</span><br><span class="line">    get()</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>): <span class="comment">#模拟并发100个客户端抢票</span></span><br><span class="line">        p=Process(target=task,args=(lock,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。</span><br><span class="line">虽然可以用文件共享数据实现进程间通信，但问题是：</span><br><span class="line">1.效率低（共享数据基于文件，而文件是硬盘上的数据）</span><br><span class="line">2.需要自己加锁处理</span><br><span class="line"></span><br><span class="line">#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2、帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。</span><br><span class="line">队列和管道都是将数据存放于内存中</span><br><span class="line">队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，</span><br><span class="line">我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。</span><br></pre></td></tr></table></figure>

<h4 id="2、信号量——-multiprocess-Semaphore"><a href="#2、信号量——-multiprocess-Semaphore" class="headerlink" title="2、信号量—— multiprocess.Semaphore"></a>2、信号量—— multiprocess.Semaphore</h4><p>一套资源  同一时间 只能被n个人访问<br>某一段代码 同一时间 只能被n个进程执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Semaphore</span><br><span class="line"></span><br><span class="line"><span class="comment"># sem = Semaphore(4)</span></span><br><span class="line"><span class="comment"># sem.acquire()</span></span><br><span class="line"><span class="comment"># print('拿到第一把钥匙')</span></span><br><span class="line"><span class="comment"># sem.acquire()</span></span><br><span class="line"><span class="comment"># print('拿到第二把钥匙')</span></span><br><span class="line"><span class="comment"># sem.acquire()</span></span><br><span class="line"><span class="comment"># print('拿到第三把钥匙')</span></span><br><span class="line"><span class="comment"># sem.acquire()</span></span><br><span class="line"><span class="comment"># print('拿到第四把钥匙')</span></span><br><span class="line"><span class="comment"># sem.acquire()</span></span><br><span class="line"><span class="comment"># print('拿到第五把钥匙')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ktv</span><span class="params">(i,sem)</span>:</span></span><br><span class="line">    sem.acquire()    <span class="comment">#获取钥匙</span></span><br><span class="line">    print(<span class="string">'%s走进ktv'</span>%i)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">5</span>))</span><br><span class="line">    print(<span class="string">'%s走出ktv'</span>%i)</span><br><span class="line">    sem.release()   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br><span class="line">    sem = Semaphore(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        p = Process(target=ktv,args=(i,sem))</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁是只有一个进程能进行，而信号量可以允许n个进程同时进行</span></span><br><span class="line"><span class="comment"># 也是引入锁的机制，但加上计数器</span></span><br><span class="line">    <span class="comment"># 每次acquire时+1，release时-1</span></span><br></pre></td></tr></table></figure>

<h4 id="3、事件——-multiprocess-Event"><a href="#3、事件——-multiprocess-Event" class="headerlink" title="3、事件—— multiprocess.Event"></a>3、事件—— multiprocess.Event</h4><p>事件：通过一个信号 来控制 多个进程 同时 执行或者阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一个信号可以使所有的进程都进入阻塞状态</span><br><span class="line"># 也可以控制所有的进程解除阻塞</span><br><span class="line"># 一个事件被创建之后,默认是阻塞状态</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Event</span><br><span class="line"></span><br><span class="line">e = Event()  <span class="comment"># 创建了一个事件</span></span><br><span class="line">print(e.is_set())   <span class="comment"># 查看一个事件的状态,默认被设置成阻塞</span></span><br><span class="line">e.set()      <span class="comment"># 将这个事件的状态改为True</span></span><br><span class="line">print(e.is_set())</span><br><span class="line">e.wait()     <span class="comment"># 是依据e.is_set()的值来决定是否阻塞的</span></span><br><span class="line">print(<span class="number">123456</span>)</span><br><span class="line">e.clear()    <span class="comment"># 将这个事件的状态改为False</span></span><br><span class="line">print(e.is_set())</span><br><span class="line">e.wait()     <span class="comment"># 等待 事件的信号被变成True</span></span><br><span class="line">print(<span class="string">'*'</span>*<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set 和 clear</span><br><span class="line">     分别用来修改一个事件的状态 True或者False</span><br><span class="line">is_set 用来查看一个事件的状态</span><br><span class="line">wait 是依据事件的状态来决定自己是否在wait处阻塞</span><br><span class="line">     False阻塞 True不阻塞</span><br></pre></td></tr></table></figure>

<p>红绿灯事件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Event,Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cars</span><span class="params">(e,i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> e.is_set():</span><br><span class="line">        print(<span class="string">'car%i在等待'</span>%i)</span><br><span class="line">        e.wait()    <span class="comment"># 阻塞 直到得到一个 事件状态变成 True 的信号</span></span><br><span class="line">    print(<span class="string">'\033[0;32;40mcar%i通过\033[0m'</span> % i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">light</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> e.is_set():</span><br><span class="line">            e.clear()</span><br><span class="line">            print(<span class="string">'\033[31m红灯亮了\033[0m'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            e.set()</span><br><span class="line">            print(<span class="string">'\033[32m绿灯亮了\033[0m'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if not car.is_alive():</span></span><br><span class="line">        <span class="comment">#     break</span></span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    e = Event()</span><br><span class="line">    traffic = Process(target=light,args=(e,))</span><br><span class="line">    traffic.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        car = Process(target=cars, args=(e,i))</span><br><span class="line">        car.start()</span><br><span class="line">        time.sleep(random.random())</span><br></pre></td></tr></table></figure>

<h3 id="四、进程间通信——-队列（multiprocess-Queue）"><a href="#四、进程间通信——-队列（multiprocess-Queue）" class="headerlink" title="四、进程间通信—— 队列（multiprocess.Queue）"></a>四、进程间通信—— 队列（multiprocess.Queue）</h3><h4 id="1、进程间通信"><a href="#1、进程间通信" class="headerlink" title="1、进程间通信"></a>1、进程间通信</h4><p><strong>IPC</strong>(Inter-Process Communication)</p>
<h4 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h4><h5 id="（1）概念介绍"><a href="#（1）概念介绍" class="headerlink" title="（1）概念介绍"></a>（1）概念介绍</h5><p>创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Queue([maxsize]) </span><br><span class="line">创建共享的进程队列。</span><br><span class="line">参数 ：maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。</span><br><span class="line">底层队列使用管道和锁定实现。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">方法介绍:</span><br><span class="line">Queue([maxsize]) </span><br><span class="line">创建共享的进程队列。maxsize是队列中允许的最大项数。如果省略此参数，则无大小限制。底层队列使用管道和锁定实现。另外，还需要运行支持线程以便队列中的数据传输到底层管道中。 </span><br><span class="line">Queue的实例q具有以下方法：</span><br><span class="line"></span><br><span class="line">q.get( [ block [ ,timeout ] ] ) </span><br><span class="line">返回q中的一个项目。如果q为空，此方法将阻塞，直到队列中有项目可用为止。block用于控制阻塞行为，默认为True. 如果设置为False，将引发Queue.Empty异常（定义在Queue模块中）。timeout是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可用，将引发Queue.Empty异常。</span><br><span class="line"></span><br><span class="line">q.get_nowait( ) </span><br><span class="line">同q.get(False)方法。</span><br><span class="line"></span><br><span class="line">q.put(item [, block [,timeout ] ] ) </span><br><span class="line">将item放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block控制阻塞行为，默认为True。如果设置为False，将引发Queue.Empty异常（定义在Queue库模块中）。timeout指定在阻塞模式中等待可用空间的时间长短。超时后将引发Queue.Full异常。</span><br><span class="line"></span><br><span class="line">q.qsize() </span><br><span class="line">返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发NotImplementedError异常。</span><br><span class="line"></span><br><span class="line">q.empty() </span><br><span class="line">如果调用此方法时 q为空，返回True。如果其他进程或线程正在往队列中添加项目，结果是不可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。</span><br><span class="line"></span><br><span class="line">q.full() </span><br><span class="line">如果q已满，返回为True. 由于线程的存在，结果也可能是不可靠的（参考q.empty（）方法）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">其他方法(了解):</span><br><span class="line">q.close() </span><br><span class="line">关闭队列，防止队列中加入更多数据。调用此方法时，后台线程将继续写入那些已入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将自动调用此方法。关闭队列不会在队列使用者中生成任何类型的数据结束信号或异常。例如，如果某个使用者正被阻塞在get（）操作上，关闭生产者中的队列不会导致get（）方法返回错误。</span><br><span class="line"></span><br><span class="line">q.cancel_join_thread() </span><br><span class="line">不会再进程退出时自动连接后台线程。这可以防止join_thread()方法阻塞。</span><br><span class="line"></span><br><span class="line">q.join_thread() </span><br><span class="line">连接队列的后台线程。此方法用于在调用q.close()方法后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread()方法可以禁止这种行为。</span><br></pre></td></tr></table></figure>

<h5 id="（2）代码实例"><a href="#（2）代码实例" class="headerlink" title="（2）代码实例"></a>（2）代码实例</h5><p>单看队列用法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">multiprocessing模块支持进程间通信的两种主要形式:管道和队列</span></span><br><span class="line"><span class="string">都是基于消息传递实现的,但是队列接口</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line">q=Queue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#put ,get ,put_nowait,get_nowait,full,empty</span></span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># q.put(3)   # 如果队列已经满了，程序就会停在这里，等待数据被别人取走，再将数据放入队列。</span></span><br><span class="line">           <span class="comment"># 如果队列中的数据一直不被取走，程序就会永远停在这里。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q.put_nowait(<span class="number">3</span>) <span class="comment"># 可以使用put_nowait，如果队列满了不会阻塞，但是会因为队列满了而报错。</span></span><br><span class="line"><span class="keyword">except</span>: <span class="comment"># 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去，但是会丢掉这个消息。</span></span><br><span class="line">    print(<span class="string">'队列已经满了'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此，我们再放入数据之前，可以先看一下队列的状态，如果已经满了，就不继续put了。</span></span><br><span class="line">print(q.full()) <span class="comment">#满了</span></span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="comment"># print(q.get()) # 同put方法一样，如果队列已经空了，那么继续取就会出现阻塞。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    q.get_nowait(<span class="number">3</span>) <span class="comment"># 可以使用get_nowait，如果队列满了不会阻塞，但是会因为没取到值而报错。</span></span><br><span class="line"><span class="keyword">except</span>: <span class="comment"># 因此我们可以用一个try语句来处理这个错误。这样程序不会一直阻塞下去。</span></span><br><span class="line">    print(<span class="string">'队列已经空了'</span>)</span><br><span class="line"></span><br><span class="line">print(q.empty()) <span class="comment">#空了</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子还没有加入进程通信，只是先来看看队列为我们提供的方法，以及这些方法的使用和现象。</p>
<p>子进程发送数据给父进程:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue,Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(q)</span>:</span></span><br><span class="line">    q.put(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(q.get())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p = Process(target=produce,args=(q,))</span><br><span class="line">    p.start()</span><br><span class="line">    c = Process(target=consume, args=(q,))</span><br><span class="line">    c.start()</span><br></pre></td></tr></table></figure>

<p>上面是一个queue的简单应用，使用队列q对象调用get函数来取得队列中最先进入的数据。 接下来看一个稍微复杂一些的例子：</p>
<p>批量生产数据放入队列再批量获取结果 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向queue中输入数据的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inputQ</span><span class="params">(queue)</span>:</span></span><br><span class="line">    info = str(os.getpid()) + <span class="string">'(put):'</span> + str(time.asctime())</span><br><span class="line">    queue.put(info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向queue中输出数据的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outputQ</span><span class="params">(queue)</span>:</span></span><br><span class="line">    info = queue.get()</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'%s%s\033[32m%s\033[0m'</span>%(str(os.getpid()), <span class="string">'(get):'</span>,info))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Main</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    multiprocessing.freeze_support()</span><br><span class="line">    record1 = []   <span class="comment"># store input processes</span></span><br><span class="line">    record2 = []   <span class="comment"># store output processes</span></span><br><span class="line">    queue = multiprocessing.Queue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入进程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        process = multiprocessing.Process(target=inputQ,args=(queue,))</span><br><span class="line">        process.start()</span><br><span class="line">        record1.append(process)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出进程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        process = multiprocessing.Process(target=outputQ,args=(queue,))</span><br><span class="line">        process.start()</span><br><span class="line">        record2.append(process)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> record1:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> record2:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure>

<h5 id="（3）生产者消费者模型"><a href="#（3）生产者消费者模型" class="headerlink" title="（3）生产者消费者模型"></a>（3）生产者消费者模型</h5><p><em>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度</em></p>
<p><strong>为什么要使用生产者和消费者模式</strong></p>
<p><em>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</em></p>
<p><strong>什么是生产者消费者模式</strong></p>
<p><em>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</em></p>
<p><strong>基于队列实现生产者消费者模型</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'\033[45m%s 吃 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">'包子%s'</span> %i</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'\033[44m%s 生产了 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure>

<p>此时的问题是主进程永远不会结束，原因是：生产者p在生产完后就结束了，但是消费者c在取空了q之后，则一直处于死循环中且卡在q.get()这一步。</p>
<p>解决方式无非是让生产者在生产完毕后，往队列中再发一个结束信号，这样消费者在接收到结束信号后就可以break出死循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改良版——生产者消费者模型</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:<span class="keyword">break</span> <span class="comment">#收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'\033[45m%s 吃 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">'包子%s'</span> %i</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'\033[44m%s 生产了 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment">#发送结束信号</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure>

<p>注意：结束信号None，不一定要由生产者发，主进程里同样可以发，但主进程需要等生产者结束后才应该发送该信号</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主进程在生产者生产完毕后发送结束信号None</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:<span class="keyword">break</span> <span class="comment">#收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'\033[45m%s 吃 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">'包子%s'</span> %i</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'\033[44m%s 生产了 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment">#发送结束信号</span></span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure>

<p>但上述解决方式，在有多个生产者和多个消费者时，我们则需要用一个很low的方式去解决</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多个消费者的例子：有几个消费者就需要发送几次结束信号</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:<span class="keyword">break</span> <span class="comment">#收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'\033[45m%s 吃 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(name,q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">'%s%s'</span> %(name,i)</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'\033[44m%s 生产了 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(<span class="string">'包子'</span>,q))</span><br><span class="line">    p2=Process(target=producer,args=(<span class="string">'骨头'</span>,q))</span><br><span class="line">    p3=Process(target=producer,args=(<span class="string">'泔水'</span>,q))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line">    c2=Process(target=consumer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    c1.start()</span><br><span class="line"></span><br><span class="line">    p1.join() <span class="comment">#必须保证生产者全部生产完毕,才应该发送结束信号</span></span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment">#有几个消费者就应该发送几次结束信号None</span></span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment">#发送结束信号</span></span><br><span class="line">    print(<span class="string">'主'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>JoinableQueue([maxsize])</strong><br>创建可连接的共享进程队列。这就像是一个Queue对象，但队列允许项目的使用者通知生产者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。</p>
<p>方法介绍:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JoinableQueue的实例p除了与Queue对象相同的方法之外，还具有以下方法：</span><br><span class="line"></span><br><span class="line">q.task_done() </span><br><span class="line">使用者使用此方法发出信号，表示q.get()返回的项目已经被处理。如果调用此方法的次数大于从队列中删除的项目数量，将引发ValueError异常。</span><br><span class="line"></span><br><span class="line">q.join() </span><br><span class="line">生产者将使用此方法进行阻塞，直到队列中所有项目均被处理。阻塞将持续到为队列中的每个项目均调用q.task_done()方法为止。 </span><br><span class="line">下面的例子说明如何建立永远运行的进程，使用和处理队列上的项目。生产者将项目放入队列，并等待它们被处理。</span><br></pre></td></tr></table></figure>

<p>JoinableQueue队列实现消费之生产者模型:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,JoinableQueue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        print(<span class="string">'\033[45m%s 吃 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line">        q.task_done() <span class="comment">#向q.join()发送一次信号,证明一个数据已经被取走了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(name,q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">'%s%s'</span> %(name,i)</span><br><span class="line">        q.put(res)</span><br><span class="line">        print(<span class="string">'\033[44m%s 生产了 %s\033[0m'</span> %(os.getpid(),res))</span><br><span class="line">    q.join() <span class="comment">#生产完毕，使用此方法进行阻塞，直到队列中所有项目均被处理。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q=JoinableQueue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(<span class="string">'包子'</span>,q))</span><br><span class="line">    p2=Process(target=producer,args=(<span class="string">'骨头'</span>,q))</span><br><span class="line">    p3=Process(target=producer,args=(<span class="string">'泔水'</span>,q))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line">    c2=Process(target=consumer,args=(q,))</span><br><span class="line">    c1.daemon=<span class="literal">True</span></span><br><span class="line">    c2.daemon=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p_l=[p1,p2,p3,c1,c2]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_l:</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    print(<span class="string">'主'</span>) </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#主进程等---&gt;p1,p2,p3等----&gt;c1,c2</span></span><br><span class="line">    <span class="comment">#p1,p2,p3结束了,证明c1,c2肯定全都收完了p1,p2,p3发到队列的数据</span></span><br><span class="line">    <span class="comment">#因而c1,c2也没有存在的价值了,不需要继续阻塞在进程中影响主进程了。应该随着主进程的结束而结束,所以设置成守护进程就可以了。</span></span><br></pre></td></tr></table></figure>

<p>另一个相似的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,JoinableQueue</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(q,name)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        food = q.get()</span><br><span class="line">        print(<span class="string">'\033[31m%s消费了%s\033[0m'</span> % (name,food))</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        q.task_done()     <span class="comment"># count - 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(name,food,q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        f = <span class="string">'%s生产了%s%s'</span>%(name,food,i)</span><br><span class="line">        print(f)</span><br><span class="line">        q.put(f)</span><br><span class="line">    q.join()    <span class="comment"># 阻塞  直到一个队列中的所有数据 全部被处理完毕</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__  == <span class="string">'__main__'</span>:</span><br><span class="line">    q = JoinableQueue(<span class="number">20</span>)</span><br><span class="line">    p1 = Process(target=producer,args=(<span class="string">'Egon'</span>,<span class="string">'包子'</span>,q))</span><br><span class="line">    p2 = Process(target=producer, args=(<span class="string">'wusir'</span>,<span class="string">'泔水'</span>, q))</span><br><span class="line">    c1 = Process(target=consumer, args=(q,<span class="string">'alex'</span>))</span><br><span class="line">    c2 = Process(target=consumer, args=(q,<span class="string">'jinboss'</span>))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    c1.daemon = <span class="literal">True</span>   <span class="comment"># 设置为守护进程 主进程中的代码执行完毕之后,子进程自动结束</span></span><br><span class="line">    c2.daemon = <span class="literal">True</span></span><br><span class="line">    c1.start()</span><br><span class="line">    c2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()      <span class="comment"># 感知一个进程的结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  在消费者这一端:</span></span><br><span class="line">    <span class="comment"># 每次获取一个数据</span></span><br><span class="line">    <span class="comment"># 处理一个数据</span></span><br><span class="line">    <span class="comment"># 发送一个记号 : 标志一个数据被处理成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在生产者这一端:</span></span><br><span class="line">    <span class="comment"># 每一次生产一个数据,</span></span><br><span class="line">    <span class="comment"># 且每一次生产的数据都放在队列中</span></span><br><span class="line">    <span class="comment"># 在队列中刻上一个记号</span></span><br><span class="line">    <span class="comment"># 当生产者全部生产完毕之后,</span></span><br><span class="line">    <span class="comment"># join信号 : 已经停止生产数据了</span></span><br><span class="line">                <span class="comment"># 且要等待之前被刻上的记号都被消费完</span></span><br><span class="line">                <span class="comment"># 当数据都被处理完时,join阻塞结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># consumer 中把所有的任务消耗完</span></span><br><span class="line"><span class="comment"># producer 端 的 join感知到,停止阻塞</span></span><br><span class="line"><span class="comment"># 所有的producer进程结束</span></span><br><span class="line"><span class="comment"># 主进程中的p.join结束</span></span><br><span class="line"><span class="comment"># 主进程中代码结束</span></span><br><span class="line"><span class="comment"># 守护进程(消费者的进程)结束</span></span><br></pre></td></tr></table></figure>

<h4 id="3、管道"><a href="#3、管道" class="headerlink" title="3、管道"></a>3、管道</h4><p>管道可以实现不同进程间的通信。</p>
<p>当管道内无数据时，再接收的话会引发阻塞。</p>
<p>（可通过发送None，通过判断来结束）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pipe,Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(conn1,conn2)</span>:</span></span><br><span class="line">    conn2.close()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span> :</span><br><span class="line">            msg = conn1.recv()</span><br><span class="line">            print(msg)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            conn1.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    conn1, conn2 = Pipe()</span><br><span class="line">    Process(target=func,args = (conn1,conn2)).start()</span><br><span class="line">    conn1.close()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        conn2.send(<span class="string">'吃了么'</span>)</span><br><span class="line">    conn2.close()</span><br></pre></td></tr></table></figure>

<h3 id="五、继承之间的数据共享"><a href="#五、继承之间的数据共享" class="headerlink" title="五、继承之间的数据共享"></a>五、继承之间的数据共享</h3><p>展望未来，基于消息传递的并发编程是大势所趋</p>
<p>即便是使用线程，推荐做法也是将程序设计为大量独立的线程集合，通过消息队列交换数据。</p>
<p>这样极大地减少了对使用锁定和其他同步手段的需求，还可以扩展到分布式系统中。</p>
<p><strong>但进程间应该尽量避免通信，即便需要通信，也应该选择进程安全的工具来避免加锁带来的问题。</strong></p>
<p><strong><em>以后我们会尝试使用数据库来解决现在进程之间的数据共享问题。</em></strong></p>
<p>Manager模块介绍:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进程间数据是独立的，可以借助于队列或管道实现通信，二者都是基于消息传递的</span><br><span class="line">虽然进程间数据独立，但可以通过Manager实现数据共享，事实上Manager的功能远不止于此</span><br><span class="line"></span><br><span class="line">A manager object returned by Manager() controls a server process which holds Python objects and allows other processes to manipulate them using proxies.</span><br><span class="line"></span><br><span class="line">A manager returned by Manager() will support types list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array.</span><br></pre></td></tr></table></figure>

<p>Manager例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager,Process,Lock</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(d,lock)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> lock: <span class="comment">#不加锁而操作共享的数据,肯定会出现数据错乱</span></span><br><span class="line">        d[<span class="string">'count'</span>]-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock=Lock()</span><br><span class="line">    <span class="keyword">with</span> Manager() <span class="keyword">as</span> m:</span><br><span class="line">        dic=m.dict(&#123;<span class="string">'count'</span>:<span class="number">100</span>&#125;)</span><br><span class="line">        p_l=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">            p=Process(target=work,args=(dic,lock))</span><br><span class="line">            p_l.append(p)</span><br><span class="line">            p.start()</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> p_l:</span><br><span class="line">            p.join()</span><br><span class="line">        print(dic)</span><br></pre></td></tr></table></figure>

<h3 id="六、进程池和multiprocess-Pool模块"><a href="#六、进程池和multiprocess-Pool模块" class="headerlink" title="六、进程池和multiprocess.Pool模块"></a>六、进程池和multiprocess.Pool模块</h3><h4 id="1、进程池"><a href="#1、进程池" class="headerlink" title="1、进程池"></a>1、进程池</h4><p>为什么要有进程池?进程池的概念。</p>
<p>​        在程序实际处理问题过程中，忙时会有成千上万的任务需要被执行，闲时可能只有零星任务。那么在成千上万个任务需要被执行的时候，我们就需要去创建成千上万个进程么？首先，创建进程需要消耗时间，销毁进程也需要消耗时间。第二即便开启了成千上万的进程，操作系统也不能让他们同时执行，这样反而会影响程序的效率。因此我们不能无限制的根据任务开启或者结束进程。那么我们要怎么做呢？</p>
<p>​        在这里，要给大家介绍一个进程池的概念，定义一个池子，在里面放上固定数量的进程，有需求来了，就拿一个池中的进程来处理任务，等到处理完毕，进程并不关闭，而是将进程再放回进程池中继续等待任务。如果有很多任务需要执行，池中的进程数量不够，任务就要等待之前的进程执行任务完毕归来，拿到空闲进程才能继续执行。也就是说，池中进程的数量是固定的，那么同一时间最多有固定数量的进程在运行。这样不会增加操作系统的调度难度，还节省了开闭进程的时间，也一定程度上能够实现并发效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">为什么会有进程池的概念</span><br><span class="line">    效率</span><br><span class="line">    每开启进程,开启属于这个进程的内存空间</span><br><span class="line">    寄存器 堆栈 文件</span><br><span class="line">    进程过多 操作系统的调度</span><br><span class="line"></span><br><span class="line">进程池</span><br><span class="line">    python中的 先创建一个属于进程的池子</span><br><span class="line">    这个池子指定能存放n个进程</span><br><span class="line">    先将这些进程创建好</span><br></pre></td></tr></table></figure>

<h4 id="2、multiprocess-Pool模块"><a href="#2、multiprocess-Pool模块" class="headerlink" title="2、multiprocess.Pool模块"></a>2、multiprocess.Pool模块</h4><h5 id="（1）概念介绍-1"><a href="#（1）概念介绍-1" class="headerlink" title="（1）概念介绍"></a>（1）概念介绍</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pool([numprocess  [,initializer [, initargs]]]):创建进程池</span><br></pre></td></tr></table></figure>

<p>参数介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 numprocess:要创建的进程数，如果省略，将默认使用cpu_count()的值</span><br><span class="line">2 initializer：是每个工作进程启动时要执行的可调用对象，默认为None</span><br><span class="line">3 initargs：是要传给initializer的参数组</span><br></pre></td></tr></table></figure>

<p>主要方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.apply(func [, args [, kwargs]]):在一个池工作进程中执行func(*args,**kwargs),然后返回结果。</span><br><span class="line">&apos;&apos;&apos;需要强调的是：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async()&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">p.apply_async(func [, args [, kwargs]]):在一个池工作进程中执行func(*args,**kwargs),然后返回结果。</span><br><span class="line">&apos;&apos;&apos;此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。&apos;&apos;&apos;</span><br><span class="line">   </span><br><span class="line">p.close():关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成</span><br><span class="line"></span><br><span class="line">P.jion():等待所有工作进程退出。此方法只能在close（）或teminate()之后调用</span><br></pre></td></tr></table></figure>

<p>其他方法(了解):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法apply_async()和map_async（）的返回值是AsyncResul的实例obj。实例具有以下方法</span><br><span class="line">obj.get():返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发一场。如果远程操作中引发了异常，它将在调用此方法时再次被引发。</span><br><span class="line">obj.ready():如果调用完成，返回True</span><br><span class="line">obj.successful():如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常</span><br><span class="line">obj.wait([timeout]):等待结果变为可用。</span><br><span class="line">obj.terminate()：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数</span><br></pre></td></tr></table></figure>

<h5 id="（2）代码实例-1"><a href="#（2）代码实例-1" class="headerlink" title="（2）代码实例"></a>（2）代码实例</h5><p><strong>进程池和多进程效率对比</strong></p>
<p>p.map进程池和进程效率测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool,Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    pool = Pool(<span class="number">5</span>)               <span class="comment"># 5个进程</span></span><br><span class="line">    pool.map(func,range(<span class="number">100</span>))    <span class="comment"># 100个任务，第二个参数必须为可迭代对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pool.map(func,range(100))  相当于：</span></span><br><span class="line">    <span class="comment"># for i in range(100):</span></span><br><span class="line">        <span class="comment"># p = Process(target=func,args=(i,))</span></span><br><span class="line">        <span class="comment"># p.start()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool,Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(n+<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    pool = Pool(<span class="number">5</span>)               <span class="comment"># 5个进程</span></span><br><span class="line">    pool.map(func,range(<span class="number">100</span>))    <span class="comment"># 100个任务</span></span><br><span class="line">    pool.map(func2,[(<span class="string">'alex'</span>,<span class="number">1</span>),<span class="string">'egon'</span>])    <span class="comment"># 100个任务</span></span><br><span class="line">    t1 = time.time() - start</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    p_lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        p = Process(target=func,args=(i,))</span><br><span class="line">        p_lst.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_lst :p.join()</span><br><span class="line">    t2 = time.time() - start</span><br><span class="line">    print(t1,t2)</span><br></pre></td></tr></table></figure>

<p><strong>同步和异步</strong></p>
<p>进程池的同步调用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s run'</span> %os.getpid())</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p=Pool(<span class="number">3</span>) <span class="comment">#进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务</span></span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res=p.apply(work,args=(i,)) <span class="comment"># 同步调用，直到本次任务执行完毕拿到res，等待任务work执行的过程中可能有阻塞也可能没有阻塞</span></span><br><span class="line">                                    <span class="comment"># 但不管该任务是否存在阻塞，同步调用都会在原地等着</span></span><br><span class="line">    print(res_l)</span><br></pre></td></tr></table></figure>

<p>进程池的异步调用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'%s run'</span> %os.getpid())</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p=Pool(<span class="number">3</span>) <span class="comment">#进程池中从无到有创建三个进程,以后一直是这三个进程在执行任务</span></span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res=p.apply_async(work,args=(i,)) <span class="comment"># 异步运行，根据进程池中有的进程数，每次最多3个子进程在异步执行</span></span><br><span class="line">                                          <span class="comment"># 返回结果之后，将结果放入列表，归还进程，之后再执行新的任务</span></span><br><span class="line">                                          <span class="comment"># 需要注意的是，进程池中的三个进程不会同时开启或者同时结束</span></span><br><span class="line">                                          <span class="comment"># 而是执行完一个就释放一个进程，这个进程就去接收新的任务。  </span></span><br><span class="line">        res_l.append(res)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 异步apply_async用法：如果使用异步提交的任务，主进程需要使用jion，等待进程池内任务都处理完，然后可以用get收集结果</span></span><br><span class="line">    <span class="comment"># 否则，主进程结束，进程池可能还没来得及执行，也就跟着一起结束了</span></span><br><span class="line">    p.close()		<span class="comment"># 结束进程池接收任务</span></span><br><span class="line">    p.join()</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> res_l:</span><br><span class="line">        print(res.get()) <span class="comment">#使用get来获取apply_aync的结果,如果是apply,则没有get方法,因为apply是同步执行,立刻获取结果,也根本无需get</span></span><br></pre></td></tr></table></figure>

<p><strong>练习</strong></p>
<p>server：进程池版socket并发聊天</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send(<span class="string">b'hello'</span>)</span><br><span class="line">    print(conn.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    sk = socket.socket()</span><br><span class="line">    sk.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line">    sk.listen()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, addr = sk.accept()</span><br><span class="line">        p.apply_async(func,args=(conn,))</span><br><span class="line">    sk.close()</span><br></pre></td></tr></table></figure>

<p>client:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">ret = sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(ret)</span><br><span class="line">msg = input(<span class="string">'&gt;&gt;&gt;'</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">sk.send(msg)</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>发现：并发开启多个客户端，服务端同一时间只有4个不同的pid，只能结束一个客户端，另外一个客户端才会进来.</p>
<p><strong>进程池的返回值</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> i*i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res = p.apply(func,args=(i,))   <span class="comment"># apply的结果就是func的返回值</span></span><br><span class="line">        print(res)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> i*i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res = p.apply_async(func,args=(i,))   <span class="comment"># apply的结果就是func的返回值</span></span><br><span class="line">        print(res.get()) <span class="comment">#阻塞 等着 func的计算结果的过程是同步的，即使异步提交</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> i*i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    res_l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res = p.apply_async(func,args=(i,))   <span class="comment"># apply的结果就是func的返回值</span></span><br><span class="line">        res_l.append(res)</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> res_l:</span><br><span class="line">        print(res.get()) <span class="comment">#等着 func的计算结果</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> i*i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    ret = p.map(func,range(<span class="number">100</span>))</span><br><span class="line">    print(ret)</span><br><span class="line">	<span class="comment"># map 自带join和close的</span></span><br></pre></td></tr></table></figure>

<p><strong>回调函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需要回调函数的场景：进程池中任何一个任务一旦处理完了，就立即告知主进程：我好了额，你可以处理我的结果了。主进程则调用一个函数去处理该结果，该函数即回调函数</span><br><span class="line"></span><br><span class="line">我们可以把耗时间（阻塞）的任务放到进程池中，然后指定回调函数（主进程负责执行），这样主进程在执行回调函数时就省去了I/O的过程，直接拿到的是任务的结果。</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回调函数</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'in func1'</span>,os.getpid())</span><br><span class="line">    <span class="keyword">return</span> n*n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(nn)</span>:</span></span><br><span class="line">    print(<span class="string">'in func2'</span>,os.getpid())</span><br><span class="line">    print(nn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'主进程 :'</span>,os.getpid())</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p.apply_async(func1,args=(<span class="number">10</span>,),callback=func2)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<p>使用多进程请求多个url来减少网络等待浪费的时间:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="comment"># 200 网页正常的返回</span></span><br><span class="line"><span class="comment"># 404 网页找不到</span></span><br><span class="line"><span class="comment"># 502 504</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(url)</span>:</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> url,response.content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_back</span><span class="params">(args)</span>:</span></span><br><span class="line">    url,content = args</span><br><span class="line">    print(url,len(content))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url_lst = [</span><br><span class="line">        <span class="string">'https://www.cnblogs.com/'</span>,</span><br><span class="line">        <span class="string">'http://www.baidu.com'</span>,</span><br><span class="line">        <span class="string">'https://www.sogou.com/'</span>,</span><br><span class="line">        <span class="string">'http://www.sohu.com/'</span>,</span><br><span class="line">    ]</span><br><span class="line">    p = Pool(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> url_lst:</span><br><span class="line">        p.apply_async(get,args=(url,),callback=call_back)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;进程%s&gt; get %s'</span> %(os.getpid(),url))</span><br><span class="line">    respone=requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> respone.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'url'</span>:url,<span class="string">'text'</span>:respone.text&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pasrse_page</span><span class="params">(res)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;进程%s&gt; parse %s'</span> %(os.getpid(),res[<span class="string">'url'</span>]))</span><br><span class="line">    parse_res=<span class="string">'url:&lt;%s&gt; size:[%s]\n'</span> %(res[<span class="string">'url'</span>],len(res[<span class="string">'text'</span>]))</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'db.txt'</span>,<span class="string">'a'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(parse_res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    urls=[</span><br><span class="line">        <span class="string">'https://www.baidu.com'</span>,</span><br><span class="line">        <span class="string">'https://www.python.org'</span>,</span><br><span class="line">        <span class="string">'https://www.openstack.org'</span>,</span><br><span class="line">        <span class="string">'https://help.github.com/'</span>,</span><br><span class="line">        <span class="string">'http://www.sina.com.cn/'</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    p=Pool(<span class="number">3</span>)</span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        res=p.apply_async(get_page,args=(url,),callback=pasrse_page)</span><br><span class="line">        res_l.append(res)</span><br><span class="line"></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    print([res.get() <span class="keyword">for</span> res <span class="keyword">in</span> res_l]) <span class="comment">#拿到的是get_page的结果,其实完全没必要拿该结果,该结果已经传给回调函数处理了</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">打印结果:</span></span><br><span class="line"><span class="string">&lt;进程3388&gt; get https://www.baidu.com</span></span><br><span class="line"><span class="string">&lt;进程3389&gt; get https://www.python.org</span></span><br><span class="line"><span class="string">&lt;进程3390&gt; get https://www.openstack.org</span></span><br><span class="line"><span class="string">&lt;进程3388&gt; get https://help.github.com/</span></span><br><span class="line"><span class="string">&lt;进程3387&gt; parse https://www.baidu.com</span></span><br><span class="line"><span class="string">&lt;进程3389&gt; get http://www.sina.com.cn/</span></span><br><span class="line"><span class="string">&lt;进程3387&gt; parse https://www.python.org</span></span><br><span class="line"><span class="string">&lt;进程3387&gt; parse https://help.github.com/</span></span><br><span class="line"><span class="string">&lt;进程3387&gt; parse http://www.sina.com.cn/</span></span><br><span class="line"><span class="string">&lt;进程3387&gt; parse https://www.openstack.org</span></span><br><span class="line"><span class="string">[&#123;'url': 'https://www.baidu.com', 'text': '&lt;!DOCTYPE html&gt;\r\n...',...&#125;]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>爬虫实例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url,pattern)</span>:</span></span><br><span class="line">    <span class="comment"># response=urlopen(url).read().decode('utf-8')</span></span><br><span class="line">    response = requests.get(url).content.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">return</span> pattern,response   <span class="comment"># 正则表达式编译结果 网页内容</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(info)</span>:</span></span><br><span class="line">    pattern,page_content=info</span><br><span class="line">    res=re.findall(pattern,page_content)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">        dic=&#123;</span><br><span class="line">            <span class="string">'index'</span>:item[<span class="number">0</span>].strip(),</span><br><span class="line">            <span class="string">'title'</span>:item[<span class="number">1</span>].strip(),</span><br><span class="line">            <span class="string">'actor'</span>:item[<span class="number">2</span>].strip(),</span><br><span class="line">            <span class="string">'time'</span>:item[<span class="number">3</span>].strip(),</span><br><span class="line">        &#125;</span><br><span class="line">        print(dic)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    regex = <span class="string">r'&lt;dd&gt;.*?&lt;.*?class="board-index.*?&gt;(\d+)&lt;/i&gt;.*?title="(.*?)".*?class="movie-item-info".*?&lt;p class="star"&gt;(.*?)&lt;/p&gt;.*?&lt;p class="releasetime"&gt;(.*?)&lt;/p&gt;'</span></span><br><span class="line">    pattern1=re.compile(regex,re.S)</span><br><span class="line">    url_dic=&#123;<span class="string">'http://maoyan.com/board/7'</span>:pattern1&#125;</span><br><span class="line">    p=Pool()</span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> url,pattern <span class="keyword">in</span> url_dic.items():</span><br><span class="line">        res=p.apply_async(get_page,args=(url,pattern),callback=parse_page)</span><br><span class="line">        res_l.append(res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res_l:</span><br><span class="line">        i.get()</span><br></pre></td></tr></table></figure>

<p><strong>如果在主进程中等待进程池中所有任务都执行完毕后，再统一处理结果，则无需回调函数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无需回调函数</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p=Pool()</span><br><span class="line"></span><br><span class="line">    res_l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res=p.apply_async(work,args=(i,))</span><br><span class="line">        res_l.append(res)</span><br><span class="line"></span><br><span class="line">    p.close()</span><br><span class="line">    p.join() <span class="comment">#等待进程池中所有进程执行完毕</span></span><br><span class="line"></span><br><span class="line">    nums=[]</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> res_l:</span><br><span class="line">        nums.append(res.get()) <span class="comment">#拿到所有结果</span></span><br><span class="line">    print(nums) <span class="comment">#主进程拿到所有的处理结果,可以在主进程中进行统一进行处理</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.python.org/dev/library/concurrent.futures.html" target="_blank" rel="noopener"><strong>进程池的其他实现方式：https://docs.python.org/dev/library/concurrent.futures.html</strong></a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/03/python全栈/第02部分：并发编程+数据库+前端/并发编程/进程（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/03/python全栈/第02部分：并发编程+数据库+前端/并发编程/进程（一）/" itemprop="url">进程（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-03T01:27:51+08:00">
                2019-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-02部分-并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -02部分 -并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="（一）理论知识"><a href="#（一）理论知识" class="headerlink" title="（一）理论知识"></a>（一）理论知识</h2><h3 id="一、操作系统背景知识"><a href="#一、操作系统背景知识" class="headerlink" title="一、操作系统背景知识"></a>一、操作系统背景知识</h3><p>​        <strong>顾名思义，进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。</strong></p>
<p>​        <strong>进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统提供的最古老也是最重要的抽象概念之一。操作系统的其他所有内容都是围绕进程的概念展开的。</strong></p>
<p>​        <strong>所以想要真正了解进程，必须事先了解操作系统，点击进入</strong>    </p>
<p>PS：即使可以利用的cpu只有一个（早期的计算机确实如此），也能保证支持（伪）并发的能力。将一个单独的cpu变成多个虚拟的cpu（多道技术：时间多路复用和空间多路复用+硬件上支持隔离），没有进程的抽象，现代计算机将不复存在。</p>
<p><strong>必备的理论基础：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#一 操作系统的作用：</span><br><span class="line">    1：隐藏丑陋复杂的硬件接口，提供良好的抽象接口</span><br><span class="line">    2：管理、调度进程，并且将多个进程对硬件的竞争变得有序</span><br><span class="line"></span><br><span class="line">#二 多道技术：</span><br><span class="line">    1.产生背景：针对单核，实现并发</span><br><span class="line">    ps：</span><br><span class="line">    现在的主机一般是多核，那么每个核都会利用多道技术</span><br><span class="line">    有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个</span><br><span class="line">    cpu中的任意一个，具体由操作系统调度算法决定。</span><br><span class="line">    </span><br><span class="line">    2.空间上的复用：如内存中同时有多道程序</span><br><span class="line">    3.时间上的复用：复用一个cpu的时间片</span><br><span class="line">       强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样</span><br><span class="line">            才能保证下次切换回来时，能基于上次切走的位置继续运行</span><br></pre></td></tr></table></figure>

<h3 id="二、什么是进程"><a href="#二、什么是进程" class="headerlink" title="二、什么是进程"></a>二、什么是进程</h3><p>​        <strong>进程（Process）</strong>是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是<a href="https://baike.baidu.com/item/操作系统" target="_blank" rel="noopener">操作系统</a>结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
<p>​        <strong>狭义定义：</strong>进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</p>
<p>​        <strong>广义定义：</strong>进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是<a href="https://baike.baidu.com/item/操作系统/192" target="_blank" rel="noopener">操作系统</a>动态执行的<a href="https://baike.baidu.com/item/基本单元" target="_blank" rel="noopener">基本单元</a>，在传统的<a href="https://baike.baidu.com/item/操作系统" target="_blank" rel="noopener">操作系统</a>中，进程既是基本的<a href="https://baike.baidu.com/item/分配单元" target="_blank" rel="noopener">分配单元</a>，也是基本的执行单元。</p>
<h4 id="1、进程的概念"><a href="#1、进程的概念" class="headerlink" title="1、进程的概念"></a>1、进程的概念</h4><p>​        第一，进程是一个实体。每一个进程都有它自己的地址空间（每个进程的地址空间是相互独立的），一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。</p>
<p>​        第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。</p>
<p>​        进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。</p>
<h4 id="2、操作系统引入进程的概念的原因"><a href="#2、操作系统引入进程的概念的原因" class="headerlink" title="2、操作系统引入进程的概念的原因"></a>2、操作系统引入进程的概念的原因</h4><p>从理论角度看，是对正在运行的程序过程的抽象；<br>        从实现角度看，是一种数据结构，目的在于清晰地刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序。</p>
<h4 id="3、进程的特征"><a href="#3、进程的特征" class="headerlink" title="3、进程的特征"></a>3、进程的特征</h4><ul>
<li><strong>动态性：</strong>进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。</li>
<li><strong>并发性：</strong>任何进程都可以同其他进程一起并发执行</li>
<li><strong>独立性：</strong>进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；</li>
<li><strong>异步性：</strong>由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进<br>结构特征：进程由程序、数据和进程控制块三部分组成</li>
</ul>
<p>​        多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</p>
<h4 id="4、进程与程序中的区别"><a href="#4、进程与程序中的区别" class="headerlink" title="4、进程与程序中的区别"></a>4、进程与程序中的区别</h4><p>​        程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。<br>​        而进程是程序在处理机上的一次执行过程，它是一个动态的概念。<br>​        程序可以作为一种软件资料长期存在，而进程是有一定生命期的。<br>​        程序是永久的，进程是暂时的。</p>
<p><strong>注意：</strong></p>
<p>​        <strong>同一个程序执行两次，就会在操作系统中出现两个进程，所以我们可以同时运行一个软件，分别做不同的事情也不会混乱。</strong></p>
<h3 id="三、进程调度"><a href="#三、进程调度" class="headerlink" title="三、进程调度"></a>三、进程调度</h3><p>​        要想多个进程交替运行，操作系统必须对这些进程进行调度，这个调度也不是随即进行的，而是需要遵循一定的法则，由此就有了进程的调度算法。</p>
<h4 id="1、先来先服务的调度算法"><a href="#1、先来先服务的调度算法" class="headerlink" title="1、先来先服务的调度算法"></a>1、先来先服务的调度算法</h4><p>​        先来先服务（FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。由此可知，本算法适合于CPU繁忙型作业，而不利于I/O繁忙型的作业（进程）。</p>
<h4 id="2、短作业优先调度算法"><a href="#2、短作业优先调度算法" class="headerlink" title="2、短作业优先调度算法"></a>2、短作业优先调度算法</h4><p>​        短作业（进程）优先调度算法（SJ/PF）是指对短作业或短进程优先调度的算法，该算法既可用于作业调度，也可用于进程调度。但其对长作业不利；不能保证紧迫性作业（进程）被及时处理；作业的长短只是被估算出来的。</p>
<h4 id="3、时间片轮转法"><a href="#3、时间片轮转法" class="headerlink" title="3、时间片轮转法"></a>3、时间片轮转法</h4><p>​        时间片轮转(Round Robin，RR)法的基本思路是让每个进程在就绪队列中的等待时间与享受服务的时间成比例。在时间片轮转法中，需要将CPU的处理时间分成固定大小的时间片，例如，几十毫秒至几百毫秒。如果一个进程在被调度选中之后用完了系统规定的时间片，但又未完成要求的任务，则它自行释放自己所占有的CPU而排到就绪队列的末尾，等待下一次调度。同时，进程调度程序又去调度当前就绪队列中的第一个进程。<br>​      显然，轮转法只能用来调度分配一些可以抢占的资源。这些可以抢占的资源可以随时被剥夺，而且可以将它们再分配给别的进程。CPU是可抢占资源的一种。但打印机等资源是不可抢占的。由于作业调度是对除了CPU之外的所有系统硬件资源的分配，其中包含有不可抢占资源，所以作业调度不使用轮转法。<br>​        在轮转法中，时间片长度的选取非常重要。首先，时间片长度的选择会直接影响到系统的开销和响应时间。如果时间片长度过短，则调度程序抢占处理机的次数增多。这将使进程上下文切换次数也大大增加，从而加重系统开销。反过来，如果时间片长度选择过长，例如，一个时间片能保证就绪队列中所需执行时间最长的进程能执行完毕，则轮转法变成了先来先服务法。时间片长度的选择是根据系统对响应时间的要求和就绪队列中所允许最大的进程数来确定的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在轮转法中，加入到就绪队列的进程有3种情况：</span><br><span class="line">      一种是分给它的时间片用完，但进程还未完成，回到就绪队列的末尾等待下次调度去继续执行。</span><br><span class="line">      另一种情况是分给该进程的时间片并未用完，只是因为请求I/O或由于进程的互斥与同步关系而被阻塞。当阻塞解除之后再回到就绪队列。</span><br><span class="line">      第三种情况就是新创建进程进入就绪队列。</span><br><span class="line">      如果对这些进程区别对待，给予不同的优先级和时间片从直观上看，可以进一步改善系统服务质量和效率。例如，我们可把就绪队列按照进程到达就绪队列的类型和进程被阻塞时的阻塞原因分成不同的就绪队列，每个队列按FCFS原则排列，各队列之间的进程享有不同的优先级，但同一队列内优先级相同。这样，当一个进程在执行完它的时间片之后，或从睡眠中被唤醒以及被创建之后，将进入不同的就绪队列。</span><br></pre></td></tr></table></figure>

<h4 id="4、多级反馈队列"><a href="#4、多级反馈队列" class="headerlink" title="4、多级反馈队列"></a>4、多级反馈队列</h4><p>​        前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。<br>​        而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。</span><br><span class="line">(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</span><br><span class="line">(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</span><br><span class="line"></span><br><span class="line">(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</span><br></pre></td></tr></table></figure>

<h3 id="四、进程的并行与并发"><a href="#四、进程的并行与并发" class="headerlink" title="四、进程的并行与并发"></a>四、进程的并行与并发</h3><p><strong>并行</strong> : 并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ）</p>
<p><strong>并发</strong> : 并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。</p>
<p><strong>区别</strong>:</p>
<p><strong>并行</strong>是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。<br><strong>并发</strong>是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。</p>
<h3 id="五、同步异步阻塞非阻塞"><a href="#五、同步异步阻塞非阻塞" class="headerlink" title="五、同步异步阻塞非阻塞"></a>五、同步异步阻塞非阻塞</h3><h4 id="1、状态介绍"><a href="#1、状态介绍" class="headerlink" title="1、状态介绍"></a>1、状态介绍</h4><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/10.png" alt></p>
<p>​        在了解其他概念之前，我们首先要了解进程的几个状态。在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪，运行和阻塞。</p>
<p>　　<strong>（1）就绪(Ready)状态</strong></p>
<p>　　当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。</p>
<p>　　<strong>（2）执行/运行（Running）状态</strong></p>
<p>​        当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。</p>
<p>　　<strong>（3）阻塞(Blocked)状态</strong></p>
<p>​        正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/11.png" alt></p>
<h4 id="2、同步和异步"><a href="#2、同步和异步" class="headerlink" title="2、同步和异步"></a>2、同步和异步</h4><p>​        所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</p>
<p>　    所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">比如我去银行办理业务，可能会有两种方式：</span><br><span class="line">第一种 ：选择排队等候；</span><br><span class="line">第二种 ：选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了；</span><br><span class="line"></span><br><span class="line">第一种：前者(排队等候)就是同步等待消息通知，也就是我要一直在等待银行办理业务情况；</span><br><span class="line"></span><br><span class="line">第二种：后者(等待别人通知)就是异步等待消息通知。在异步消息处理中，等待消息通知者(在这个例子中就是等待办理业务的人)往往注册一个回调机制，在所等待的事件被触发时由触发机制(在这里是柜台的人)通过某种机制(在这里是写在小纸条上的号码，喊号)找到等待该事件的人。</span><br></pre></td></tr></table></figure>

<h4 id="3、阻塞与非阻塞"><a href="#3、阻塞与非阻塞" class="headerlink" title="3、阻塞与非阻塞"></a>3、阻塞与非阻塞</h4><p>​        阻塞和非阻塞这两个概念与程序（线程）等待消息通知(无所谓同步或者异步)时的状态有关。也就是说阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">		继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。</span><br><span class="line">		相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。</span><br><span class="line"></span><br><span class="line">		注意：同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。</span><br></pre></td></tr></table></figure>

<h4 id="4、同步-异步-与-阻塞-非阻塞"><a href="#4、同步-异步-与-阻塞-非阻塞" class="headerlink" title="4、同步/异步 与 阻塞/非阻塞"></a>4、同步/异步 与 阻塞/非阻塞</h4><ol>
<li><p><strong>同步阻塞形式</strong></p>
<p>​        效率最低。拿上面的例子来说，就是你专心排队，什么别的事都不做。</p>
</li>
<li><p><strong>异步阻塞形式</strong></p>
<p>​        如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发（通知），也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面；</p>
<p>​        <strong>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</strong></p>
</li>
<li><p><strong>同步非阻塞形式</strong></p>
<p>​        实际上是效率低下的。</p>
<p>　　想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。</p>
</li>
<li><p><strong>异步非阻塞形式</strong></p>
<p>​        效率更高，</p>
<p>　　因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。</p>
<p>　　比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p>
</li>
</ol>
<p>​        很多人会把同步和阻塞混淆，是因为很多时候同步操作会以阻塞的形式表现出来，同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞。</p>
<h3 id="六、进程的创建与结束"><a href="#六、进程的创建与结束" class="headerlink" title="六、进程的创建与结束"></a>六、进程的创建与结束</h3><h4 id="1、进程的创建"><a href="#1、进程的创建" class="headerlink" title="1、进程的创建"></a>1、进程的创建</h4><p>​        但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。</p>
<p>　　而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程：</p>
<p>　　1. 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）</p>
<p>　　2. 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等）</p>
<p>　　3. 用户的交互式请求，而创建一个新进程（如用户双击暴风影音）</p>
<p>　　4. 一个批处理作业的初始化（只在大型机的批处理系统中应用）</p>
<p>　　无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建进程：</span><br><span class="line">1. 在UNIX中该系统调用是：fork，fork会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件（在shell解释器进程中，执行一个命令就会创建一个子进程）</span><br><span class="line"></span><br><span class="line">　　2. 在windows中该系统调用是：CreateProcess，CreateProcess既处理进程的创建，也负责把正确的程序装入新进程。</span><br><span class="line"></span><br><span class="line">　　关于创建子进程，UNIX和windows</span><br><span class="line"></span><br><span class="line">　　1.相同的是：进程创建后，父进程和子进程有各自不同的地址空间（多道技术要求物理层面实现进程之间内存的隔离），任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。</span><br><span class="line"></span><br><span class="line">　　2.不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，从一开始父进程与子进程的地址空间就是不同的。</span><br></pre></td></tr></table></figure>

<h4 id="2、进程的结束"><a href="#2、进程的结束" class="headerlink" title="2、进程的结束"></a>2、进程的结束</h4><ol>
<li><p>正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）</p>
</li>
<li><p>出错退出（自愿，python a.py中a.py不存在）</p>
</li>
<li><p>严重错误（非自愿，执行非法指令，如引用不存在的内存，1/0等，可以捕捉异常，try…except…）</p>
</li>
<li><p>被其他进程杀死（非自愿，如kill -9）</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/02/python全栈/第02部分：并发编程+数据库+前端/并发编程/操作系统的发展史/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/02/python全栈/第02部分：并发编程+数据库+前端/并发编程/操作系统的发展史/" itemprop="url">操作系统的发展史</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-02T22:21:10+08:00">
                2019-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-02部分-并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -02部分 -并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="一、手工操作——穿孔卡片"><a href="#一、手工操作——穿孔卡片" class="headerlink" title="一、手工操作——穿孔卡片"></a>一、手工操作——穿孔卡片</h2><p>1946年第一台计算机诞生–20世纪50年代中期，计算机工作还在采用手工操作方式。此时还没有操作系统的概念。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/01.png" alt> <img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02.png" alt></p>
<p>​        程序员将对应于程序和数据的已穿孔的纸带（或卡片）装入输入机，然后启动输入机把程序和数据输入计算机内存，接着通过控制台开关启动程序针对数据运行；计算完毕，打印机输出计算结果；用户取走结果并卸下纸带（或卡片）后，才让下一个用户上机。</p>
<p>手工操作方式两个特点：</p>
<p>　　（1）用户独占全机。不会出现因资源已被其他用户占用而等待的现象，但资源的利用率低。</p>
<p>　　（2）CPU 等待手工操作。CPU的利用不充分。</p>
<p>​      20世纪50年代后期，出现<a href="https://baike.baidu.com/item/人机矛盾" target="_blank" rel="noopener">人机矛盾</a>：手工操作的慢速度和计算机的高速度之间形成了尖锐矛盾，手工操作方式已严重损害了系统资源的利用率（使资源利用率降为百分之几，甚至更低），不能容忍。唯一的解决办法：只有摆脱人的手工操作，实现作业的自动过渡。这样就出现了成<a href="https://baike.baidu.com/item/批处理" target="_blank" rel="noopener">批处理</a>。</p>
<h2 id="二、批处理——磁带存储"><a href="#二、批处理——磁带存储" class="headerlink" title="二、批处理——磁带存储"></a>二、批处理——磁带存储</h2><p>​        批处理系统：加载在计算机上的一个<a href="https://baike.baidu.com/item/系统软件" target="_blank" rel="noopener">系统软件</a>，在它的控制下，计算机能够自动地、成批地处理一个或多个用户的作业（这作业包括程序、数据和命令）。</p>
<h3 id="1、联机批处理系统"><a href="#1、联机批处理系统" class="headerlink" title="1、联机批处理系统"></a>1、联机批处理系统</h3><p>首先出现的是联机批处理系统，即作业的输入/输出由CPU来处理。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/03.png" alt></p>
<p>​        主机与输入机之间增加一个存储设备——<strong>磁带</strong>，在运行于主机上的监督程序的自动控制下，计算机可自动完成：成批地把输入机上的用户作业读入磁带，依次把磁带上的用户作业读入主机内存并执行并把计算结果向输出机输出。完成了上一批作业后，监督程序又从输入机上输入另一批作业，保存在磁带上，并按上述步骤重复处理。</p>
<p>​        监督程序不停地处理各个作业，从而实现了作业到作业的自动转接，减少了作业建立时间和手工操作时间，有效克服了人机矛盾，提高了计算机的利用率。</p>
<p>​        但是，在作业输入和结果输出时，主机的高速CPU仍处于空闲状态，等待慢速的输入/输出设备完成工作： 主机处于“忙等”状态。</p>
<h3 id="2、脱机批处理系统"><a href="#2、脱机批处理系统" class="headerlink" title="2、脱机批处理系统"></a>2、脱机批处理系统</h3><p>​        为克服与缓解：高速主机与慢速外设的矛盾，提高CPU的利用率，又引入了<a href="https://baike.baidu.com/item/脱机批处理系统" target="_blank" rel="noopener">脱机批处理系统</a>，即输入/输出脱离主机控制。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/04.png" alt></p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/05.png" alt></p>
<p>​        卫星机：一台不与主机直接相连而专门用于与输入/输出设备打交道的。</p>
<p>　　其功能是：</p>
<p>　　（1）从输入机上读取用户作业并放到输入磁带上。</p>
<p>　　（2）从输出磁带上读取执行结果并传给输出机。</p>
<p>​        这样，主机不是直接与慢速的输入/输出设备打交道，而是与速度相对较快的磁带机发生关系，有效缓解了主机与设备的矛盾。主机与卫星机可并行工作，二者分工明确，可以充分发挥主机的高速计算能力。</p>
<p>​        脱机批处理系统:20世纪60年代应用十分广泛，它极大缓解了人机矛盾及主机与外设的矛盾。</p>
<p>　　不足：每次主机内存中仅存放一道作业，每当它运行期间发出输入/输出（I/O）请求后，高速的CPU便处于等待低速的I/O完成状态，致使CPU空闲。</p>
<p>​        为改善CPU的利用率，又引入了多道程序系统。</p>
<h2 id="三、多道程序系统"><a href="#三、多道程序系统" class="headerlink" title="三、多道程序系统"></a>三、多道程序系统</h2><h3 id="1、多道程序设计技术"><a href="#1、多道程序设计技术" class="headerlink" title="1、多道程序设计技术"></a>1、多道程序设计技术</h3><p>​        所谓多道程序设计技术，就是指允许多个程序同时进入内存并运行。即同时把多个程序放入内存，并允许它们交替在CPU中运行，它们共享系统中的各种硬、软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/06.png" alt></p>
<p>​        在A程序计算时，I/O空闲， A程序I/O操作时，CPU空闲（B程序也是同样）；必须A工作完成后，B才能进入内存中开始工作，两者是串行的，全部完成共需时间=T1+T2。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/07.png" alt></p>
<p>​        将A、B两道程序同时存放在内存中，它们在系统的控制下，可相互穿插、交替地在CPU上运行：当A程序因请求I/O操作而放弃CPU时，B程序就可占用CPU运行，这样 CPU不再空闲，而正进行A I/O操作的I/O设备也不空闲，显然，CPU和I/O设备都处于“忙”状态，大大提高了资源的利用率，从而也提高了系统的效率，A、B全部完成所需时间&lt;&lt;T1+T2。</p>
<p>​      多道程序设计技术不仅使CPU得到充分利用，同时改善I/O设备和内存的利用率，从而提高了整个系统的资源利用率和系统吞吐量（单位时间内处理作业（程序）的个数），最终提高了整个系统的效率。</p>
<p>​        单处理机系统中多道程序运行时的特点：</p>
<p>　　（1）多道：计算机内存中同时存放几道相互独立的程序；</p>
<p>　　（2）宏观上并行：同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕；</p>
<p>　　（3）微观上串行：实际上，各道程序轮流地用CPU，并交替运行。</p>
<p>​        <strong>多道程序系统的出现，标志着操作系统渐趋成熟的阶段，先后出现了作业调度管理、处理机管理、存储器管理、外部设备管理、文件系统管理等功能。</strong></p>
<p>​        <strong>由于多个程序同时在计算机中运行，开始有了空间隔离的概念，只有内存空间的隔离，才能让数据更加安全、稳定。</strong></p>
<p>​        <strong>出了空间隔离之外，多道技术还第一次体现了时空复用的特点，遇到IO操作就切换程序，使得cpu的利用率提高了，计算机的工作效率也随之提高。</strong></p>
<h3 id="2、多道批处理系统"><a href="#2、多道批处理系统" class="headerlink" title="2、多道批处理系统"></a>2、多道批处理系统</h3><p>​        20世纪60年代中期，在前述的批处理系统中，引入多道程序设计技术后形成多道批处理系统（简称：批处理系统）。</p>
<p>　　它有两个特点：</p>
<p>　　（1）多道：系统内可同时容纳多个作业。这些作业放在外存中，组成一个后备队列，系统按一定的调度原则每次从后备作业队列中选取一个或多个作业进入内存运行，运行作业结束、退出运行和后备作业进入运行均由系统自动实现，从而在系统中形成一个自动转接的、连续的作业流。</p>
<p>　　（2）成批：在系统运行过程中，不允许用户与其作业发生交互作用，即：作业一旦进入系统，用户就不能直接干预其作业的运行。</p>
<p>　　批处理系统的追求目标：提高系统资源利用率和系统吞吐量，以及作业流程的自动化。</p>
<p>　　批处理系统的一个重要缺点：不提供人机交互能力，给用户使用计算机带来不便。</p>
<p>　　虽然用户独占全机资源，并且直接控制程序的运行，可以随时了解程序运行情况。但这种工作方式因独占全机造成资源效率极低。</p>
<p>　　一种新的追求目标：既能保证计算机效率，又能方便用户使用计算机。 20世纪60年代中期，计算机技术和软件技术的发展使这种追求成为可能。</p>
<h2 id="四、分时系统"><a href="#四、分时系统" class="headerlink" title="四、分时系统"></a>四、分时系统</h2><p>​        由于CPU速度不断提高和采用分时技术，一台计算机可同时连接多个用户终端，而每个用户可在自己的终端上联机使用计算机，好像自己独占机器一样。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/08.png" alt></p>
<p>​        分时技术：把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。</p>
<p>　　若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮时再继续其运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的印象是，好象他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。</p>
<p>​        具有上述特征的计算机系统称为分时系统，它允许多个用户同时联机使用计算机。</p>
<p>　　特点：</p>
<p>　　（1）多路性。若干个用户同时使用一台计算机。微观上看是各用户轮流使用计算机；宏观上看是各用户并行工作。</p>
<p>　　（2）交互性。用户可根据系统对请求的响应结果，进一步向系统提出新的请求。这种能使用户与系统进行人机对话的工作方式，明显地有别于批处理系统，因而，分时系统又被称为交互式系统。</p>
<p>　　（3）独立性。用户之间可以相互独立操作，互不干扰。系统保证各用户程序运行的完整性，不会发生相互混淆或破坏现象。</p>
<p>　　（4）及时性。系统可对用户的输入及时作出响应。分时系统性能的主要指标之一是响应时间，它是指：从终端发出命令到系统予以应答所需的时间。</p>
<p>　　<strong>分时系统的主要目标</strong>：对用户响应的及时性，即不至于用户等待每一个命令的处理时间过长。</p>
<p>​        分时系统可以同时接纳数十个甚至上百个用户，由于内存空间有限，往往采用对换（又称交换）方式的存储方法。即将未“轮到”的作业放入磁盘，一旦“轮到”，再将其调入内存；而时间片用完后，又将作业存回磁盘（俗称“滚进”、“滚出“法），使同一存储区域轮流为多个用户服务。</p>
<p>​        多用户分时系统是当今计算机操作系统中最普遍使用的一类操作系统。</p>
<p>​      <strong>注意：分时系统的分时间片工作，在没有遇到IO操作的时候就用完了自己的时间片被切走了，这样的切换工作其实并没有提高cpu的效率，反而使得计算机的效率降低了。但是我们牺牲了一点效率，却实现了多个程序共同执行的效果，这样你就可以在计算机上一边听音乐一边聊qq了。</strong></p>
<h2 id="五、实时系统"><a href="#五、实时系统" class="headerlink" title="五、实时系统"></a>五、实时系统</h2><p>​        虽然多道批处理系统和分时系统能获得较令人满意的资源利用率和系统响应时间，但却不能满足实时控制与实时信息处理两个应用领域的需求。于是就产生了实时系统，即系统能够及时响应随机发生的外部事件，并在严格的时间范围内完成对该事件的处理。</p>
<p>​        实时系统在一个特定的应用中常作为一种控制设备来使用。</p>
<p>　　  实时系统可分成两类：</p>
<p>　　  （1）实时控制系统。当用于飞机飞行、导弹发射等的自动控制时，要求计算机能尽快处理测量系统测得的数据，及时地对飞机或导弹进行控制，或将有关信息通过显示终端提供给决策人员。当用于轧钢、石化等工业生产过程控制时，也要求计算机能及时处理由各类传感器送来的数据，然后控制相应的执行机构。</p>
<p>　　  （2）实时信息处理系统。当用于预定飞机票、查询有关航班、航线、票价等事宜时，或当用于银行系统、情报检索系统时，都要求计算机能对终端设备发来的服务请求及时予以正确的回答。此类对响应及时性的要求稍弱于第一类。</p>
<p>　　<strong>实时操作系统的主要特点</strong>：</p>
<p>　　（1）及时响应。每一个信息接收、分析处理和发送的过程必须在严格的时间限制内完成。</p>
<p>　　（2）高可靠性。需采取冗余措施，双机系统前后台工作，也包括必要的保密措施等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分时系统和实时系统的比较：</span><br><span class="line">分时——现在流行的PC，服务器都是采用这种运行模式，即把CPU的运行分成若干时间片分别处理不同的运算请求 linux系统</span><br><span class="line">实时——一般用于单片机上、PLC等，比如电梯的上下控制中，对于按键等动作要求进行实时处理</span><br></pre></td></tr></table></figure>

<h2 id="六、通用操作系统"><a href="#六、通用操作系统" class="headerlink" title="六、通用操作系统"></a>六、通用操作系统</h2><p>​        操作系统的三种基本类型：多道批处理系统、分时系统、实时系统。</p>
<p>　　<strong>通用操作系统：具有多种类型操作特征的操作系统。可以同时兼有多道批处理、分时、实时处理的功能，或其中两种以上的功能。</strong></p>
<p>　　例如：实时处理+批处理=实时批处理系统。首先保证优先处理实时任务，插空进行批处理作业。常把实时任务称为前台作业，批作业称为后台作业。</p>
<p>　　再如：分时处理+批处理=分时批处理系统。即：时间要求不强的作业放入“后台”（批处理）处理，需频繁交互的作业在“前台”（分时）处理，处理机优先运行“前台”作业。</p>
<p>　　从上世纪60年代中期，国际上开始研制一些大型的通用操作系统。这些系统试图达到功能齐全、可适应各种应用范围和操作方式变化多端的环境的目标。但是，这些系统过于复杂和庞大，不仅付出了巨大的代价，且在解决其可靠性、可维护性和可理解性方面都遇到很大的困难。</p>
<p>　　相比之下，UNIX操作系统却是一个例外。这是一个通用的多用户分时交互型的操作系统。它首先建立的是一个精干的核心，而其功能却足以与许多大型的操作系统相媲美，在核心层以外，可以支持庞大的软件系统。它很快得到应用和推广，并不断完善，对现代操作系统有着重大的影响。</p>
<p>　　至此，操作系统的基本概念、功能、基本结构和组成都已形成并渐趋完善。</p>
<h2 id="七、操作系统的进一步发展"><a href="#七、操作系统的进一步发展" class="headerlink" title="七、操作系统的进一步发展"></a>七、操作系统的进一步发展</h2><p>​        进入20世纪80年代，大规模集成电路工艺技术的飞跃发展，微处理机的出现和发展，掀起了计算机大发展大普及的浪潮。一方面迎来了个人计算机的时代，同时又向计算机网络、分布式处理、巨型计算机和智能化方向发展。于是，操作系统有了进一步的发展，如：个人计算机操作系统、网络操作系统、分布式操作系统等。</p>
<h3 id="1、个人计算机操作系统"><a href="#1、个人计算机操作系统" class="headerlink" title="1、个人计算机操作系统"></a>1、个人计算机操作系统</h3><p>​        个人计算机上的操作系统是联机交互的单用户操作系统，它提供的联机交互功能与通用分时系统提供的功能很相似。</p>
<p>　　由于是个人专用，因此一些功能会简单得多。然而，由于个人计算机的应用普及，对于提供更方便友好的用户接口和丰富功能的文件系统的要求会愈来愈迫切。</p>
<h3 id="2、网络操作系统"><a href="#2、网络操作系统" class="headerlink" title="2、网络操作系统"></a>2、网络操作系统</h3><p>​        计算机网络：通过通信设施，将地理上分散的、具有自治功能的多个计算机系统互连起来，实现信息交换、资源共享、互操作和协作处理的系统。</p>
<p>　　网络操作系统：在原来各自计算机操作系统上，按照网络体系结构的各个协议标准增加网络管理模块，其中包括：通信、资源共享、系统安全和各种网络应用服务。</p>
<h3 id="3、分布式操作系统"><a href="#3、分布式操作系统" class="headerlink" title="3、分布式操作系统"></a>3、分布式操作系统</h3><p>​        表面上看，分布式系统与计算机网络系统没有多大区别。分布式操作系统也是通过通信网络，将地理上分散的具有自治功能的数据处理系统或计算机系统互连起来，实现信息交换和资源共享，协作完成任务。——硬件连接相同。</p>
<p>　　但有如下一些明显的区别：</p>
<p>　　（1）分布式系统要求一个统一的操作系统，实现系统操作的统一性。</p>
<p>　　（2）分布式操作系统管理分布式系统中的所有资源，它负责全系统的资源分配和调度、任务划分、信息传输和控制协调工作，并为用户提供一个统一的界面。</p>
<p>　　（3）用户通过这一界面，实现所需要的操作和使用系统资源，至于操作定在哪一台计算机上执行，或使用哪台计算机的资源，则是操作系统完成的，用户不必知道，此谓：系统的透明性。</p>
<p>　　（4）分布式系统更强调分布式计算和处理，因此对于多机合作和系统重构、坚强性和容错能力有更高的要求，希望系统有：更短的响应时间、高吞吐量和高可靠性。</p>
<h2 id="八、操作系统的作用"><a href="#八、操作系统的作用" class="headerlink" title="八、操作系统的作用"></a>八、操作系统的作用</h2><p>​        现代的计算机系统主要是由一个或者多个处理器，主存，硬盘，键盘，鼠标，显示器，打印机，网络接口及其他输入输出设备组成。</p>
<p>　　一般而言，现代计算机系统是一个复杂的系统。</p>
<p>　　其一：如果每位应用程序员都必须掌握该系统所有的细节，那就不可能再编写代码了（严重影响了程序员的开发效率：全部掌握这些细节可能需要一万年….）</p>
<p>　　其二：并且管理这些部件并加以优化使用，是一件极富挑战性的工作，于是，计算安装了一层软件（系统软件），称为操作系统。它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型，并管理刚才提到的所有设备。</p>
<p>　　<strong>总结：</strong></p>
<p>　　<strong>程序员无法把所有的硬件操作细节都了解到，管理这些硬件并且加以优化使用是非常繁琐的工作，这个繁琐的工作就是操作系统来干的，有了他，程序员就从这些繁琐的工作中解脱了出来，只需要考虑自己的应用软件的编写就可以了，应用软件直接使用操作系统提供的功能来间接使用硬件。</strong></p>
<p>　　<strong>精简的说的话，操作系统就是一个协调、管理和控制计算机硬件资源和软件资源的控制程序。操作系统所处的位置如图</strong></p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC02%E9%83%A8%E5%88%86%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2B%E6%95%B0%E6%8D%AE%E5%BA%93%2B%E5%89%8D%E7%AB%AF/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/09.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">细说的话，操作系统应该分成两部分功能：</span><br><span class="line">#一：隐藏了丑陋的硬件调用接口，为应用程序员提供调用硬件资源的更好，更简单，更清晰的模型（系统调用接口）。应用程序员有了这些接口后，就不用再考虑操作硬件的细节，专心开发自己的应用程序即可。</span><br><span class="line">例如：操作系统提供了文件这个抽象概念，对文件的操作就是对磁盘的操作，有了文件我们无需再去考虑关于磁盘的读写控制（比如控制磁盘转动，移动磁头读写数据等细节），</span><br><span class="line"></span><br><span class="line">#二：将应用程序对硬件资源的竞态请求变得有序化</span><br><span class="line">例如：很多应用软件其实是共享一套计算机硬件，比方说有可能有三个应用程序同时需要申请打印机来输出内容，那么a程序竞争到了打印机资源就打印，然后可能是b竞争到打印机资源，也可能是c，这就导致了无序，打印机可能打印一段a的内容然后又去打印c...,操作系统的一个功能就是将这种无序变得有序。</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/29/python全栈/第01部分：基础+模块+面向对象+网络编程/网络编程/计算机网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/29/python全栈/第01部分：基础+模块+面向对象+网络编程/网络编程/计算机网络/" itemprop="url">计算机网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-29T22:57:50+08:00">
                2019-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-01部分-网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -01部分 -网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="（一）计算机网络的发展及基础网络概念"><a href="#（一）计算机网络的发展及基础网络概念" class="headerlink" title="（一）计算机网络的发展及基础网络概念"></a>（一）计算机网络的发展及基础网络概念</h2><h3 id="一、早期：联机"><a href="#一、早期：联机" class="headerlink" title="一、早期：联机"></a>一、早期：联机</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11.png" alt></p>
<h3 id="二、以太网：局域网与交换机"><a href="#二、以太网：局域网与交换机" class="headerlink" title="二、以太网：局域网与交换机"></a>二、以太网：局域网与交换机</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/12.png" alt></p>
<p>交换机——解决多台电脑的通信问题(广播、单播、组播)</p>
<h4 id="1、广播"><a href="#1、广播" class="headerlink" title="1、广播"></a>1、广播</h4><p>​        主机之间“一对所有”的通讯模式，网络对其中每一台主机发出的信号都进行无条件复制并转发，<strong>所有主机都可以接收到所有信息（不管你是否需要）</strong>，由于其不用路径选择，所以其网络成本可以很低廉。有线电视网就是典型的广播型网络，我们的电视机实际上是接受到所有频道的信号，但只将一个频道的信号还原成画面。在数据网络中也允许广播的存在，但其被限制在二层交换机的局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机。</p>
<p>​        <a href="https://baike.baidu.com/item/广播风暴/3574878?fr=aladdin" target="_blank" rel="noopener">广播风暴</a>：简单的讲是指当广播数据充斥网络无法处理，并占用大量<a href="https://baike.baidu.com/item/网络带宽/6120475" target="_blank" rel="noopener">网络带宽</a>，导致正常业务不能运行，甚至彻底瘫痪，这就发生了“广播风暴”。一个<a href="https://baike.baidu.com/item/数据帧/10571824" target="_blank" rel="noopener">数据帧</a>或包被传输到本地<a href="https://baike.baidu.com/item/网段/11026985" target="_blank" rel="noopener">网段</a> （由<a href="https://baike.baidu.com/item/广播域/5293530" target="_blank" rel="noopener">广播域</a>定义）上的每个<a href="https://baike.baidu.com/item/节点/865052" target="_blank" rel="noopener">节点</a>就是广播；由于<a href="https://baike.baidu.com/item/网络拓扑/4804125" target="_blank" rel="noopener">网络拓扑</a>的设计和连接问题，或其他原因导致广播在网段内大量复制，传播<a href="https://baike.baidu.com/item/数据帧/10571824" target="_blank" rel="noopener">数据帧</a>，导致网络性能下降，甚至<a href="https://baike.baidu.com/item/网络瘫痪/5928979" target="_blank" rel="noopener">网络瘫痪</a>，这就是广播风暴。</p>
<h4 id="2、ip地址与ip协议"><a href="#2、ip地址与ip协议" class="headerlink" title="2、ip地址与ip协议"></a>2、ip地址与ip协议</h4><ul>
<li>规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示</li>
<li>范围0.0.0.0-255.255.255.255</li>
<li>一个ip地址通常写成四段十进制数，例：172.16.10.1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ip保留地址：</span><br><span class="line"></span><br><span class="line">a类网   10.0.0.0~10.255.255.255</span><br><span class="line"></span><br><span class="line">b类网   172.16.0.0~172.31.255.255</span><br><span class="line"></span><br><span class="line">c类网   192.168.0.0~192.168.255.255</span><br></pre></td></tr></table></figure>

<h4 id="3、mac地址"><a href="#3、mac地址" class="headerlink" title="3、mac地址"></a>3、mac地址</h4><p>​        head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址。</p>
<p>　　mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）</p>
<h4 id="4、arp协议——查询IP地址和MAC地址的对应关系"><a href="#4、arp协议——查询IP地址和MAC地址的对应关系" class="headerlink" title="4、arp协议——查询IP地址和MAC地址的对应关系"></a>4、arp协议——查询IP地址和MAC地址的对应关系</h4><p>​        地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。</p>
<p>　　主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址。</p>
<p>　　收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p>
<p>　　地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。</p>
<h3 id="三、广域网与路由器"><a href="#三、广域网与路由器" class="headerlink" title="三、广域网与路由器"></a>三、广域网与路由器</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/13.png" alt></p>
<h4 id="1、网关"><a href="#1、网关" class="headerlink" title="1、网关"></a>1、网关</h4><p>​        大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送消息，也必须经过一道“关口”，这道关口就是网关。顾名思义网关（Gateway）就是一个网络连接到另一个网络的“关口”。也就是网络关卡。</p>
<p>​        网关(Gateway)又称网间连接器、协议转换器。默认网关在网络层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连 [1]  。</p>
<p>​        网关ip：局域网内的机器访问公网ip，就通过网关访问</p>
<h4 id="2、路由器"><a href="#2、路由器" class="headerlink" title="2、路由器"></a>2、路由器</h4><p>​        路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。 路由器是互联网络的枢纽，”交通警察”。目前路由器已经广泛应用于各行各业，各种不同档次的产品已成为实现各种骨干网内部连接、骨干网间互联和骨干网与互联网互联互通业务的主力军。路由和交换机之间的主要区别就是交换机发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层。这一区别决定了路由和交换机在移动信息的过程中需使用不同的控制信息，所以说两者实现各自功能的方式是不同的。</p>
<p>　　路由器（Router）又称网关设备（Gateway）是用于连接多个逻辑上分开的网络，所谓逻辑网络是代表一个单独的网络或者一个子网。当数据从一个子网传输到另一个子网时，可通过路由器的路由功能来完成。因此，路由器具有判断网络地址和选择IP路径的功能，它能在多网络互联环境中，建立灵活的连接，可用完全不同的数据分组和介质访问方法连接各种子网，路由器只接受源站或其他路由器的信息，属网络层的一种互联设备。</p>
<h4 id="3、局域网"><a href="#3、局域网" class="headerlink" title="3、局域网"></a>3、局域网</h4><p>​        局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。</p>
<h3 id="三、子网掩码"><a href="#三、子网掩码" class="headerlink" title="三、子网掩码"></a>三、子网掩码</h3><p>​    所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p>
<p>　　<strong>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。</strong>方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">比如，已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，</span><br><span class="line"></span><br><span class="line">172.16.10.1：10101100.00010000.00001010.000000001</span><br><span class="line">255255.255.255.0:11111111.11111111.11111111.00000000</span><br><span class="line">AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">172.16.10.2：10101100.00010000.00001010.00000010</span><br><span class="line">255255.255.255.0:11111111.11111111.11111111.00000000</span><br><span class="line">AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</span><br><span class="line">结果都是172.16.10.0，因此它们在同一个子网络。</span><br></pre></td></tr></table></figure>

<p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p>
<h3 id="四、tcp协议和udp协议"><a href="#四、tcp协议和udp协议" class="headerlink" title="四、tcp协议和udp协议"></a>四、tcp协议和udp协议</h3><p>​        用于应用程序之间的通信。如果说ip地址和mac地址帮我们确定唯一的一台机器，那么我们怎么找到一台机器上的一个软件呢？</p>
<h4 id="1、端口"><a href="#1、端口" class="headerlink" title="1、端口"></a>1、端口</h4><p>​        我们知道，一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。</p>
<p>​        在计算机上，每一个需要网络通信的程序，都会开一个端口。在同一时间只会有一个程序占用一个端口，不可能在同一时间有两个及以上程序占用同一个端口。所以通过端口来找到程序。</p>
<p>​        端口的范围： 0 - 65535， 一般我们使用8000之后的端口。靠前的端口有可能是系统默认使用的。</p>
<p>​        IP —— 确定唯一一台机器</p>
<p>​        端口 —— 确定唯一一台程序</p>
<p>​        IP+端口 —— 找到唯一的一台机器上的唯一的一个程序</p>
<h4 id="2、TCP协议"><a href="#2、TCP协议" class="headerlink" title="2、TCP协议"></a>2、TCP协议</h4><p>​        当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。</p>
<p>​        全双工：双方都能互相收发消息。</p>
<p>　　这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/14.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tcp的三次握手:</span><br><span class="line">			TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK[1]，并最终对对方的 SYN 执行 ACK 确认。这种建立连接的方法可以防止产生错误的连接。[1] </span><br><span class="line">TCP三次握手的过程如下：</span><br><span class="line">客户端发送SYN（SEQ=x）报文给服务器端，进入SYN_SEND状态。</span><br><span class="line">服务器端收到SYN报文，回应一个SYN （SEQ=y）ACK(ACK=x+1）报文，进入SYN_RECV状态。</span><br><span class="line">客户端收到服务器端的SYN报文，回应一个ACK(ACK=y+1）报文，进入Established状态。</span><br><span class="line">三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tcp的四次挥手:</span><br><span class="line">建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。</span><br><span class="line">(1) 某个应用进程首先调用close，称该端执行“主动关闭”（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。</span><br><span class="line">(2) 接收到这个FIN的对端执行 “被动关闭”（passive close），这个FIN由TCP确认。</span><br><span class="line">注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</span><br><span class="line">(3) 一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。</span><br><span class="line">(4) 接收这个最终FIN的原发送端TCP（即执行主动关闭的那一端）确认这个FIN。[1] </span><br><span class="line">既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。</span><br><span class="line">注意：</span><br><span class="line">(1) “通常”是指，某些情况下，步骤1的FIN随数据一起发送，另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。[2] </span><br><span class="line">(2) 在步骤2与步骤3之间，从执行被动关闭一端到执行主动关闭一端流动数据是可能的，这称为“半关闭”（half-close）。</span><br><span class="line">(3) 当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个FIN。</span><br><span class="line">无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。[2]</span><br></pre></td></tr></table></figure>

<h4 id="3、UDP协议"><a href="#3、UDP协议" class="headerlink" title="3、UDP协议"></a>3、UDP协议</h4><p>　　当应用程序希望通过UDP与一个应用程序通信时，传输数据之前源端和终端不建立连接。</p>
<p>　　当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。</p>
<h3 id="五、tcp和udp的对比"><a href="#五、tcp和udp的对比" class="headerlink" title="五、tcp和udp的对比"></a>五、tcp和udp的对比</h3><p>​        TCP—传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>​        UDP—用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快</p>
<p>​        tcp：打电话</p>
<p>​        udp：发短信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">更多：</span><br><span class="line">		现在Internet上流行的协议是TCP/IP协议，该协议中对低于1024的端口都有确切的定义，他们对应着Internet上一些常见的服务。这些常见的服务可以分为使用TCP端口（面向连接）和使用UDP端口（面向无连接）两种。 </span><br><span class="line">		说到TCP和UDP,首先要明白“连接”和“无连接”的含义，他们的关系可以用一个形象地比喻来说明，就是打电话和写信。两个人如果要通话，首先要建立连接——即打电话时的拨号，等待响应后——即接听电话后，才能相互传递信息，最后还要断开连接——即挂电话。写信就比较简单了，填写好收信人的地址后将信投入邮筒，收信人就可以收到了。从这个分析可以看出，建立连接可以在需要痛心地双方建立一个传递信息的通道，在发送方发送请求连接信息接收方响应后，由于是在接受方响应后才开始传递信息，而且是在一个通道中传送，因此接受方能比较完整地收到发送方发出的信息，即信息传递的可靠性比较高。但也正因为需要建立连接，使资源开销加大（在建立连接前必须等待接受方响应，传输信息过程中必须确认信息是否传到及断开连接时发出相应的信号等），独占一个通道，在断开连接钱不能建立另一个连接，即两人在通话过程中第三方不能打入电话。而无连接是一开始就发送信息（严格说来，这是没有开始、结束的），只是一次性的传递，是先不需要接受方的响应，因而在一定程度上也无法保证信息传递的可靠性了，就像写信一样，我们只是将信寄出去，却不能保证收信人一定可以收到。 </span><br><span class="line">		TCP是面向连接的，有比较高的可靠性， 一些要求比较高的服务一般使用这个协议，如FTP、Telnet、SMTP、HTTP、POP3等。</span><br><span class="line">而UDP是面向无连接的，使用这个协议的常见服务有DNS、SNMP、QQ等。对于QQ必须另外说明一下，QQ2003以前是只使用UDP协议的，其服务器使用8000端口，侦听是否有信息传来，客户端使用4000端口，向外发送信息（这也就不难理解在一般的显IP的QQ版本中显示好友的IP地址信息中端口常为4000或其后续端口的原因了），即QQ程序既接受服务又提供服务，在以后的QQ版本中也支持使用TCP协议了。</span><br></pre></td></tr></table></figure>

<h2 id="（二）互联网协议与osi模型"><a href="#（二）互联网协议与osi模型" class="headerlink" title="（二）互联网协议与osi模型"></a>（二）互联网协议与osi模型</h2><p>互联网协议按照功能不同分为osi七层或tcp/ip五层或tcp/ip四层</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.png" alt></p>
<h3 id="一、每层运行常见物理设备"><a href="#一、每层运行常见物理设备" class="headerlink" title="一、每层运行常见物理设备"></a>一、每层运行常见物理设备</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/16.png" alt></p>
<h3 id="二、每层运行常见的协议"><a href="#二、每层运行常见的协议" class="headerlink" title="二、每层运行常见的协议"></a>二、每层运行常见的协议</h3><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/17.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/python全栈/第01部分：基础+模块+面向对象+网络编程/模块/常用模块（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/python全栈/第01部分：基础+模块+面向对象+网络编程/模块/常用模块（一）/" itemprop="url">常用模块（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-24T00:25:31+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-01部分-模块和包/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -01部分 -模块和包</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h2 id="（一）认识模块"><a href="#（一）认识模块" class="headerlink" title="（一）认识模块"></a>（一）认识模块</h2><h3 id="一、什么是模块"><a href="#一、什么是模块" class="headerlink" title="一、什么是模块"></a>一、什么是模块</h3><h4 id="1、什么是模块"><a href="#1、什么是模块" class="headerlink" title="1、什么是模块"></a>1、什么是模块</h4><p>常见的场景：一个模块就是一个包含了python定义和声明的文件，文件名就是模块名字加上.py的后缀。</p>
<p>   但其实import加载的模块分为四个通用类别：　</p>
<ol>
<li>使用python编写的代码（.py文件）</li>
<li>已被编译为共享库或DLL的C或C++扩展</li>
<li>包好一组模块的包</li>
<li>使用C编写并链接到python解释器的内置模块</li>
</ol>
<h4 id="2、为何要使用模块"><a href="#2、为何要使用模块" class="headerlink" title="2、为何要使用模块"></a>2、为何要使用模块</h4><p>​        如果你退出python解释器然后重新进入，那么你之前定义的函数或者变量都将丢失，因此我们通常将程序写到文件中以便永久保存下来，需要时就通过python test.py方式去执行，此时test.py被称为脚本script。</p>
<p>​        随着程序的发展，功能越来越多，为了方便管理，我们通常将程序分成一个个的文件，这样做程序的结构更清晰，方便管理。这时我们不仅仅可以把这些文件当做脚本去执行，还可以把他们当做模块来导入到其他的模块中，实现了功能的重复利用</p>
<h3 id="二、模块的导入和使用"><a href="#二、模块的导入和使用" class="headerlink" title="二、模块的导入和使用"></a>二、模块的导入和使用</h3><p>见 “模块和包”</p>
<h2 id="（二）常用模块（一）"><a href="#（二）常用模块（一）" class="headerlink" title="（二）常用模块（一）"></a>（二）常用模块（一）</h2><h3 id="一、collections模块"><a href="#一、collections模块" class="headerlink" title="一、collections模块"></a>一、collections模块</h3><p>在内置数据类型（dict、list、set、tuple）的基础上，collections模块还提供了几个额外的数据类型：Counter、deque、defaultdict、namedtuple和OrderedDict等。</p>
<ol>
<li>namedtuple: 生成可以使用名字来访问元素内容的tuple</li>
<li>deque: 双端队列，可以快速的从另外一侧追加和推出对象</li>
<li>Counter: 计数器，主要用来计数 </li>
<li>OrderedDict: 有序字典 </li>
<li>defaultdict: 带有默认值的字典</li>
</ol>
<h4 id="1、namedtuple"><a href="#1、namedtuple" class="headerlink" title="1、namedtuple"></a>1、namedtuple</h4><p>我们知道tuple可以表示不变集合，例如，一个点的二维坐标就可以表示成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = (<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>但是，看到(1, 2)，很难看出这个tuple是用来表示一个坐标的。</p>
<p>这时，namedtuple就派上了用场：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point = namedtuple(<span class="string">'Point'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.y</span><br></pre></td></tr></table></figure>

<p>类似的，如果要用坐标和半径表示一个圆，也可以用namedtuple定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#namedtuple('名称', [属性list]):</span></span><br><span class="line">Circle = namedtuple(<span class="string">'Circle'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'r'</span>])</span><br></pre></td></tr></table></figure>

<h4 id="2、deque"><a href="#2、deque" class="headerlink" title="2、deque"></a>2、deque</h4><p>​        使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。</p>
<p>​         deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="string">'x'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.appendleft(<span class="string">'y'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="string">'y'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'x'</span>])</span><br></pre></td></tr></table></figure>

<p>deque除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>
<h4 id="3、OrderedDict"><a href="#3、OrderedDict" class="headerlink" title="3、OrderedDict"></a>3、OrderedDict</h4><p>使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。</p>
<p>如果要保持Key的顺序，可以用<code>OrderedDict</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d <span class="comment"># dict的Key是无序的</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od = OrderedDict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od <span class="comment"># OrderedDict的Key是有序的</span></span><br><span class="line">OrderedDict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br></pre></td></tr></table></figure>

<p>注意，<code>OrderedDict</code>的Key会按照插入的顺序排列，不是Key本身排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>od = OrderedDict()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od[<span class="string">'z'</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od[<span class="string">'y'</span>] = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od[<span class="string">'x'</span>] = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od.keys() <span class="comment"># 按照插入的Key的顺序返回</span></span><br><span class="line">[<span class="string">'z'</span>, <span class="string">'y'</span>, <span class="string">'x'</span>]</span><br></pre></td></tr></table></figure>

<h4 id="4、defaultdict"><a href="#4、defaultdict" class="headerlink" title="4、defaultdict"></a>4、defaultdict</h4><p>有如下值集合 [<code>11</code>,<code>22</code>,<code>33</code>,<code>44</code>,<code>55</code>,<code>66</code>,<code>77</code>,<code>88</code>,<code>99</code>,<code>90.</code>..]，将所有大于 66的值保存至字典的第一个key中，将小于 66的值保存至第二个key的值中。<br>即： {k1: 大于66, k2: 小于66}</p>
<p><strong>原生字典解决方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">values = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>,<span class="number">90</span>]</span><br><span class="line"></span><br><span class="line">my_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span>  values:</span><br><span class="line">    <span class="keyword">if</span> value&gt;<span class="number">66</span>:</span><br><span class="line">        <span class="keyword">if</span> my_dict.has_key(<span class="string">'k1'</span>):</span><br><span class="line">            my_dict[<span class="string">'k1'</span>].append(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            my_dict[<span class="string">'k1'</span>] = [value]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> my_dict.has_key(<span class="string">'k2'</span>):</span><br><span class="line">            my_dict[<span class="string">'k2'</span>].append(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            my_dict[<span class="string">'k2'</span>] = [value]</span><br></pre></td></tr></table></figure>

<p><strong>defaultdict字典解决方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">values = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>,<span class="number">90</span>]</span><br><span class="line"></span><br><span class="line">my_dict = defaultdict(list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span>  values:</span><br><span class="line">    <span class="keyword">if</span> value&gt;<span class="number">66</span>:</span><br><span class="line">        my_dict[<span class="string">'k1'</span>].append(value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        my_dict[<span class="string">'k2'</span>].append(value)</span><br></pre></td></tr></table></figure>

<p>使用<code>dict</code>时，如果引用的Key不存在，就会抛出<code>KeyError</code>。如果希望key不存在时，返回一个默认值，就可以用<code>defaultdict</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(<span class="keyword">lambda</span>: <span class="string">'N/A'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key1'</span>] = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key1'</span>] <span class="comment"># key1存在</span></span><br><span class="line"><span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key2'</span>] <span class="comment"># key2不存在，返回默认值</span></span><br><span class="line"><span class="string">'N/A'</span></span><br></pre></td></tr></table></figure>

<h4 id="5、Counter"><a href="#5、Counter" class="headerlink" title="5、Counter"></a>5、Counter</h4><p>Counter类的目的是用来跟踪值出现的次数。它是一个无序的容器类型，以字典的键值对形式存储，其中元素作为key，其计数作为value。计数值可以是任意的Interger（包括0和负数）。Counter类和其他语言的bags或multisets很相似。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = Counter(<span class="string">'abcdeabcdabcaba'</span>)</span><br><span class="line"><span class="keyword">print</span> c</span><br><span class="line">输出：Counter(&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">4</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'e'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="二、时间模块"><a href="#二、时间模块" class="headerlink" title="二、时间模块"></a>二、时间模块</h3><p>和时间有关系的我们就要用到时间模块。在使用模块之前，应该首先导入这个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#常用方法</span><br><span class="line">1.time.sleep(secs)</span><br><span class="line">(线程)推迟指定的时间运行。单位为秒。</span><br><span class="line">2.time.time()</span><br><span class="line">获取当前时间戳</span><br></pre></td></tr></table></figure>

<h4 id="1、表示时间的三种方式"><a href="#1、表示时间的三种方式" class="headerlink" title="1、表示时间的三种方式"></a>1、表示时间的三种方式</h4><p>在Python中，通常有这三种方式来表示时间：时间戳、元组(struct_time)、格式化的时间字符串：</p>
<ol>
<li><p>时间戳(timestamp) ：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">python中时间日期格式化符号：</span><br><span class="line">%y 两位数的年份表示（00-99）</span><br><span class="line">%Y 四位数的年份表示（000-9999）</span><br><span class="line">%m 月份（01-12）</span><br><span class="line">%d 月内中的一天（0-31）</span><br><span class="line">%H 24小时制小时数（0-23）</span><br><span class="line">%I 12小时制小时数（01-12）</span><br><span class="line">%M 分钟数（00=59）</span><br><span class="line">%S 秒（00-59）</span><br><span class="line">%a 本地简化星期名称</span><br><span class="line">%A 本地完整星期名称</span><br><span class="line">%b 本地简化的月份名称</span><br><span class="line">%B 本地完整的月份名称</span><br><span class="line">%c 本地相应的日期表示和时间表示</span><br><span class="line">%j 年内的一天（001-366）</span><br><span class="line">%p 本地A.M.或P.M.的等价符</span><br><span class="line">%U 一年中的星期数（00-53）星期天为星期的开始</span><br><span class="line">%w 星期（0-6），星期天为星期的开始</span><br><span class="line">%W 一年中的星期数（00-53）星期一为星期的开始</span><br><span class="line">%x 本地相应的日期表示</span><br><span class="line">%X 本地相应的时间表示</span><br><span class="line">%Z 当前时区的名称</span><br><span class="line">%% %号本身</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>格式化的时间字符串(Format String)： ‘1999-12-06’</p>
<table>
<thead>
<tr>
<th align="left">索引（Index）</th>
<th>属性（Attribute）</th>
<th align="left">值（Values）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td>tm_year（年）</td>
<td align="left">比如2011</td>
</tr>
<tr>
<td align="left">1</td>
<td>tm_mon（月）</td>
<td align="left">1 - 12</td>
</tr>
<tr>
<td align="left">2</td>
<td>tm_mday（日）</td>
<td align="left">1 - 31</td>
</tr>
<tr>
<td align="left">3</td>
<td>tm_hour（时）</td>
<td align="left">0 - 23</td>
</tr>
<tr>
<td align="left">4</td>
<td>tm_min（分）</td>
<td align="left">0 - 59</td>
</tr>
<tr>
<td align="left">5</td>
<td>tm_sec（秒）</td>
<td align="left">0 - 60</td>
</tr>
<tr>
<td align="left">6</td>
<td>tm_wday（weekday）</td>
<td align="left">0 - 6（0表示周一）</td>
</tr>
<tr>
<td align="left">7</td>
<td>tm_yday（一年中的第几天）</td>
<td align="left">1 - 366</td>
</tr>
<tr>
<td align="left">8</td>
<td>tm_isdst（是否是夏令时）</td>
<td align="left">默认为0</td>
</tr>
</tbody></table>
</li>
</ol>
<p>首先，我们先导入time模块，来认识一下python中表示时间的几种格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入时间模块</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment">#时间戳</span></span><br><span class="line">&gt;&gt;&gt;time.time()</span><br><span class="line"><span class="number">1500875844.800804</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间字符串</span></span><br><span class="line">&gt;&gt;&gt;time.strftime(<span class="string">"%Y-%m-%d %X"</span>)</span><br><span class="line"><span class="string">'2017-07-24 13:54:37'</span></span><br><span class="line">&gt;&gt;&gt;time.strftime(<span class="string">"%Y-%m-%d %H-%M-%S"</span>)</span><br><span class="line"><span class="string">'2017-07-24 13-55-04'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间元组:localtime将一个时间戳转换为当前时区的struct_time</span></span><br><span class="line">time.localtime()</span><br><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">7</span>, tm_mday=<span class="number">24</span>,</span><br><span class="line">　　　　　　　　　　tm_hour=<span class="number">13</span>, tm_min=<span class="number">59</span>, tm_sec=<span class="number">37</span>, </span><br><span class="line">                 tm_wday=<span class="number">0</span>, tm_yday=<span class="number">205</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong><em>小结：</em></strong></p>
<p>时间戳是计算机能够识别的时间；时间字符串是人能够看懂的时间；元组则是用来操作时间的</p>
<h4 id="2、几种格式之间的转换"><a href="#2、几种格式之间的转换" class="headerlink" title="2、几种格式之间的转换"></a>2、几种格式之间的转换</h4><p><img src="https://images2015.cnblogs.com/blog/827651/201707/827651-20170724144151992-1508626640.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#时间戳--&gt;结构化时间</span></span><br><span class="line"><span class="comment">#time.gmtime(时间戳)    #UTC时间，与英国伦敦当地时间一致</span></span><br><span class="line"><span class="comment">#time.localtime(时间戳) #当地时间。例如我们现在在北京执行这个方法：与UTC时间相差8小时，UTC时间+8小时 = 北京时间 </span></span><br><span class="line">&gt;&gt;&gt;time.gmtime(<span class="number">1500000000</span>)</span><br><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">7</span>, tm_mday=<span class="number">14</span>, tm_hour=<span class="number">2</span>, tm_min=<span class="number">40</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">4</span>, tm_yday=<span class="number">195</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt;time.localtime(<span class="number">1500000000</span>)</span><br><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">7</span>, tm_mday=<span class="number">14</span>, tm_hour=<span class="number">10</span>, tm_min=<span class="number">40</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">4</span>, tm_yday=<span class="number">195</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结构化时间--&gt;时间戳　</span></span><br><span class="line"><span class="comment">#time.mktime(结构化时间)</span></span><br><span class="line">&gt;&gt;&gt;time_tuple = time.localtime(<span class="number">1500000000</span>)</span><br><span class="line">&gt;&gt;&gt;time.mktime(time_tuple)</span><br><span class="line"><span class="number">1500000000.0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#结构化时间--&gt;字符串时间</span></span><br><span class="line"><span class="comment">#time.strftime("格式定义","结构化时间")  结构化时间参数若不传，则显示当前时间</span></span><br><span class="line">&gt;&gt;&gt;time.strftime(<span class="string">"%Y-%m-%d %X"</span>)</span><br><span class="line"><span class="string">'2017-07-24 14:55:36'</span></span><br><span class="line">&gt;&gt;&gt;time.strftime(<span class="string">"%Y-%m-%d"</span>,time.localtime(<span class="number">1500000000</span>))</span><br><span class="line"><span class="string">'2017-07-14'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#字符串时间--&gt;结构化时间</span></span><br><span class="line"><span class="comment">#time.strptime(时间字符串,字符串对应格式)</span></span><br><span class="line">&gt;&gt;&gt;time.strptime(<span class="string">"2017-03-16"</span>,<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">3</span>, tm_mday=<span class="number">16</span>, tm_hour=<span class="number">0</span>, tm_min=<span class="number">0</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">3</span>, tm_yday=<span class="number">75</span>, tm_isdst=<span class="number">-1</span>)</span><br><span class="line">&gt;&gt;&gt;time.strptime(<span class="string">"07/24/2017"</span>,<span class="string">"%m/%d/%Y"</span>)</span><br><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">7</span>, tm_mday=<span class="number">24</span>, tm_hour=<span class="number">0</span>, tm_min=<span class="number">0</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">205</span>, tm_isdst=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/827651/201707/827651-20170724144235883-1963884021.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#结构化时间 --&gt; %a %b %d %H:%M:%S %Y串</span></span><br><span class="line"><span class="comment">#time.asctime(结构化时间) 如果不传参数，直接返回当前时间的格式化串</span></span><br><span class="line">&gt;&gt;&gt;time.asctime(time.localtime(<span class="number">1500000000</span>))</span><br><span class="line"><span class="string">'Fri Jul 14 10:40:00 2017'</span></span><br><span class="line">&gt;&gt;&gt;time.asctime()</span><br><span class="line"><span class="string">'Mon Jul 24 15:18:33 2017'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间戳 --&gt; %a %b %d %H:%M:%S %Y串</span></span><br><span class="line"><span class="comment">#time.ctime(时间戳)  如果不传参数，直接返回当前时间的格式化串</span></span><br><span class="line">&gt;&gt;&gt;time.ctime()</span><br><span class="line"><span class="string">'Mon Jul 24 15:19:07 2017'</span></span><br><span class="line">&gt;&gt;&gt;time.ctime(<span class="number">1500000000</span>)</span><br><span class="line"><span class="string">'Fri Jul 14 10:40:00 2017'</span></span><br></pre></td></tr></table></figure>

<p>计算时间差：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">true_time=time.mktime(time.strptime(<span class="string">'2017-09-11 08:30:00'</span>,<span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br><span class="line">time_now=time.mktime(time.strptime(<span class="string">'2017-09-12 11:00:00'</span>,<span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br><span class="line">dif_time=time_now-true_time</span><br><span class="line">struct_time=time.gmtime(dif_time)</span><br><span class="line">print(<span class="string">'过去了%d年%d月%d天%d小时%d分钟%d秒'</span>%(struct_time.tm_year<span class="number">-1970</span>,struct_time.tm_mon<span class="number">-1</span>,</span><br><span class="line">                                       struct_time.tm_mday<span class="number">-1</span>,struct_time.tm_hour,</span><br><span class="line">                                       struct_time.tm_min,struct_time.tm_sec))</span><br></pre></td></tr></table></figure>

<h3 id="三、random模块"><a href="#三、random模块" class="headerlink" title="三、random模块"></a>三、random模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#随机小数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.random()      <span class="comment"># 大于0且小于1之间的小数</span></span><br><span class="line"><span class="number">0.7664338663654585</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.uniform(<span class="number">1</span>,<span class="number">3</span>) <span class="comment">#大于1小于3的小数</span></span><br><span class="line"><span class="number">1.6270147180533838</span></span><br><span class="line"><span class="comment">#恒富：发红包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#随机整数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">1</span>,<span class="number">5</span>)  <span class="comment"># 大于等于1且小于等于5之间的整数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randrange(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>) <span class="comment"># 大于等于1且小于10之间的奇数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#随机选择一个返回</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.choice([<span class="number">1</span>,<span class="string">'23'</span>,[<span class="number">4</span>,<span class="number">5</span>]])  <span class="comment"># #1或者23或者[4,5]</span></span><br><span class="line"><span class="comment">#随机选择多个返回，返回的个数为函数的第二个参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.sample([<span class="number">1</span>,<span class="string">'23'</span>,[<span class="number">4</span>,<span class="number">5</span>]],<span class="number">2</span>) <span class="comment"># #列表元素任意2个组合</span></span><br><span class="line">[[<span class="number">4</span>, <span class="number">5</span>], <span class="string">'23'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#打乱列表顺序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(item) <span class="comment"># 打乱次序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item</span><br><span class="line">[<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.shuffle(item)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>item</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>生成随机验证码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">v_code</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    code = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"></span><br><span class="line">        num=random.randint(<span class="number">0</span>,<span class="number">9</span>)</span><br><span class="line">        alf=chr(random.randint(<span class="number">65</span>,<span class="number">90</span>))</span><br><span class="line">        add=random.choice([num,alf])</span><br><span class="line">        code=<span class="string">""</span>.join([code,str(add)])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line">print(v_code())</span><br></pre></td></tr></table></figure>

<h3 id="四、os模块"><a href="#四、os模块" class="headerlink" title="四、os模块"></a>四、os模块</h3><p>os模块是与操作系统交互的一个接口</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">os.makedirs(<span class="string">'dirname1/dirname2'</span>)    可生成多层递归目录</span><br><span class="line">os.removedirs(<span class="string">'dirname1'</span>)    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</span><br><span class="line">os.mkdir(<span class="string">'dirname'</span>)    生成单级目录；相当于shell中mkdir dirname</span><br><span class="line">os.rmdir(<span class="string">'dirname'</span>)    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</span><br><span class="line">os.listdir(<span class="string">'dirname'</span>)    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</span><br><span class="line">os.remove()  删除一个文件</span><br><span class="line">os.rename(<span class="string">"oldname"</span>,<span class="string">"newname"</span>)  重命名文件/目录</span><br><span class="line">os.stat(<span class="string">'path/filename'</span>)  获取文件/目录信息</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">"bash command"</span>)  运行shell命令，直接显示</span><br><span class="line">os.popen(<span class="string">"bash command).read()  运行shell命令，获取执行结果</span></span><br><span class="line"><span class="string">os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径</span></span><br><span class="line"><span class="string">os.chdir("</span>dirname<span class="string">")  改变当前脚本工作目录；相当于shell下cd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">os.path</span></span><br><span class="line"><span class="string">os.path.abspath(path) 返回path规范化的绝对路径</span></span><br><span class="line"><span class="string">os.path.split(path) 将path分割成目录和文件名二元组返回 </span></span><br><span class="line"><span class="string">os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素 </span></span><br><span class="line"><span class="string">os.path.basename(path) 返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</span></span><br><span class="line"><span class="string">os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False</span></span><br><span class="line"><span class="string">os.path.isabs(path)  如果path是绝对路径，返回True</span></span><br><span class="line"><span class="string">os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False</span></span><br><span class="line"><span class="string">os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False</span></span><br><span class="line"><span class="string">os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</span></span><br><span class="line"><span class="string">os.path.getatime(path)  返回path所指向的文件或者目录的最后访问时间</span></span><br><span class="line"><span class="string">os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间</span></span><br><span class="line"><span class="string">os.path.getsize(path) 返回path的大小</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>os.stat(‘path/filename’)  获取文件/目录信息 的结构说明</p>
<p>stat结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stat 结构:</span><br><span class="line"></span><br><span class="line">st_mode: inode 保护模式</span><br><span class="line">st_ino: inode 节点号。</span><br><span class="line">st_dev: inode 驻留的设备。</span><br><span class="line">st_nlink: inode 的链接数。</span><br><span class="line">st_uid: 所有者的用户ID。</span><br><span class="line">st_gid: 所有者的组ID。</span><br><span class="line">st_size: 普通文件以字节为单位的大小；包含等待某些特殊文件的数据。</span><br><span class="line">st_atime: 上次访问的时间。</span><br><span class="line">st_mtime: 最后一次修改的时间。</span><br><span class="line">st_ctime: 由操作系统报告的&quot;ctime&quot;。在某些系统上（如Unix）是最新的元数据更改的时间，在其它系统上（如Windows）是创建时间（详细信息参见平台的文档）。</span><br></pre></td></tr></table></figure>

<p>os模块的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os.sep    输出操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot;</span><br><span class="line">os.linesep    输出当前平台使用的行终止符，win下为&quot;\r\n&quot;,Linux下为&quot;\n&quot;</span><br><span class="line">os.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:</span><br><span class="line">os.name    输出字符串指示当前使用平台。win-&gt;&apos;nt&apos;; Linux-&gt;&apos;posix&apos;</span><br></pre></td></tr></table></figure>

<h3 id="五、sys模块"><a href="#五、sys模块" class="headerlink" title="五、sys模块"></a>五、sys模块</h3><p>sys模块是与python解释器交互的一个接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sys.argv           命令行参数List，第一个元素是程序本身路径</span><br><span class="line">sys.exit(n)        退出程序，正常退出时exit(0),错误退出sys.exit(1)</span><br><span class="line">sys.version        获取Python解释程序的版本信息</span><br><span class="line">sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</span><br><span class="line">sys.platform       返回操作系统平台名称</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> SystemExit <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>

<h3 id="六、序列化模块"><a href="#六、序列化模块" class="headerlink" title="六、序列化模块"></a>六、序列化模块</h3><p>什么叫序列化——将原本的字典、列表等内容转换成一个字符串的过程就叫做<strong>序列化</strong>。</p>
<p>为什么要有序列化模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">比如，我们在python代码中计算的一个数据需要给另外一段程序使用，那我们怎么给？</span><br><span class="line">现在我们能想到的方法就是存在文件里，然后另一个python程序再从文件里读出来。</span><br><span class="line">但是我们都知道，对于文件来说是没有字典这个概念的，所以我们只能将数据转换成字典放到文件中。</span><br><span class="line">你一定会问，将字典转换成一个字符串很简单，就是str(dic)就可以办到了，为什么我们还要学习序列化模块呢？</span><br><span class="line">没错序列化的过程就是从dic 变成str(dic)的过程。现在你可以通过str(dic)，将一个名为dic的字典转换成一个字符串，</span><br><span class="line">但是你要怎么把一个字符串转换成字典呢？</span><br><span class="line">聪明的你肯定想到了eval()，如果我们将一个字符串类型的字典str_dic传给eval，就会得到一个返回的字典类型了。</span><br><span class="line">eval()函数十分强大，但是eval是做什么的？e官方demo解释为：将字符串str当成有效的表达式来求值并返回计算结果。</span><br><span class="line">ＢＵＴ！强大的函数有代价。安全性是其最大的缺点。</span><br><span class="line">想象一下，如果我们从文件中读出的不是一个数据结构，而是一句&quot;删除文件&quot;类似的破坏性语句，那么后果实在不堪设设想。</span><br><span class="line">而使用eval就要担这个风险。</span><br><span class="line">所以，我们并不推荐用eval方法来进行反序列化操作(将str转换成python中的数据结构)</span><br></pre></td></tr></table></figure>

<p><strong>序列化的目的</strong></p>
<p>1、以某种存储形式使自定义<a href="https://baike.baidu.com/item/对象持久化" target="_blank" rel="noopener">对象持久化</a>；</p>
<p>2、将对象从一个地方传递到另一个地方。</p>
<p>3、使程序更具维护性。</p>
<p><img src="https://images2017.cnblogs.com/blog/827651/201708/827651-20170805234418803-1378181341.png" alt></p>
<p>用于序列化的两个模块</p>
<ul>
<li>json，用于字符串 和 python数据类型间进行转换</li>
<li>pickle，用于python特有的类型 和 python的数据类型间进行转换</li>
</ul>
<h4 id="1、json"><a href="#1、json" class="headerlink" title="1、json"></a>1、json</h4><p>Json模块提供了四个功能：dumps、dump、loads、load</p>
<p><strong>loads和dumps</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>,<span class="string">'k3'</span>:<span class="string">'v3'</span>&#125;</span><br><span class="line">str_dic = json.dumps(dic)  <span class="comment">#序列化：将一个字典转换成一个字符串</span></span><br><span class="line">print(type(str_dic),str_dic)  <span class="comment">#&lt;class 'str'&gt; &#123;"k3": "v3", "k1": "v1", "k2": "v2"&#125;</span></span><br><span class="line"><span class="comment">#注意，json转换完的字符串类型的字典中的字符串是由""表示的</span></span><br><span class="line"></span><br><span class="line">dic2 = json.loads(str_dic)  <span class="comment">#反序列化：将一个字符串格式的字典转换成一个字典</span></span><br><span class="line"><span class="comment">#注意，要用json的loads功能处理的字符串类型的字典中的字符串必须由""表示</span></span><br><span class="line">print(type(dic2),dic2)  <span class="comment">#&lt;class 'dict'&gt; &#123;'k1': 'v1', 'k2': 'v2', 'k3': 'v3'&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list_dic = [<span class="number">1</span>,[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],<span class="number">3</span>,&#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>&#125;]</span><br><span class="line">str_dic = json.dumps(list_dic) <span class="comment">#也可以处理嵌套的数据类型 </span></span><br><span class="line">print(type(str_dic),str_dic) <span class="comment">#&lt;class 'str'&gt; [1, ["a", "b", "c"], 3, &#123;"k1": "v1", "k2": "v2"&#125;]</span></span><br><span class="line">list_dic2 = json.loads(str_dic)</span><br><span class="line">print(type(list_dic2),list_dic2) <span class="comment">#&lt;class 'list'&gt; [1, ['a', 'b', 'c'], 3, &#123;'k1': 'v1', 'k2': 'v2'&#125;]</span></span><br></pre></td></tr></table></figure>

<p><strong>load和dump</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">f = open(<span class="string">'json_file'</span>,<span class="string">'w'</span>)</span><br><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>,<span class="string">'k3'</span>:<span class="string">'v3'</span>&#125;</span><br><span class="line">json.dump(dic,f)  <span class="comment">#dump方法接收一个文件句柄，直接将字典转换成json字符串写入文件</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'json_file'</span>)</span><br><span class="line">dic2 = json.load(f)  <span class="comment">#load方法接收一个文件句柄，直接将文件中的json字符串转换成数据结构返回</span></span><br><span class="line">f.close()</span><br><span class="line">print(type(dic2),dic2)</span><br></pre></td></tr></table></figure>

<p><strong>ensure_ascii关键字参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">f = open(<span class="string">'file'</span>,<span class="string">'w'</span>)</span><br><span class="line">json.dump(&#123;<span class="string">'国籍'</span>:<span class="string">'中国'</span>&#125;,f)</span><br><span class="line">ret = json.dumps(&#123;<span class="string">'国籍'</span>:<span class="string">'中国'</span>&#125;)</span><br><span class="line">f.write(ret+<span class="string">'\n'</span>)</span><br><span class="line">json.dump(&#123;<span class="string">'国籍'</span>:<span class="string">'美国'</span>&#125;,f,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">ret = json.dumps(&#123;<span class="string">'国籍'</span>:<span class="string">'美国'</span>&#125;,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">f.write(ret+<span class="string">'\n'</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p><strong>其他参数说明</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Serialize obj to a JSON formatted str.(字符串表示的json对象) </span><br><span class="line">Skipkeys：默认值是False，如果dict的keys内的数据不是python的基本类型(str,unicode,int,long,float,bool,None)，设置为False时，就会报TypeError的错误。此时设置成True，则会跳过这类key </span><br><span class="line">ensure_ascii:，当它为True的时候，所有非ASCII码字符显示为\uXXXX序列，只需在dump时将ensure_ascii设置为False即可，此时存入json的中文即可正常显示。) </span><br><span class="line">If check_circular is false, then the circular reference check for container types will be skipped and a circular reference will result in an OverflowError (or worse). </span><br><span class="line">If allow_nan is false, then it will be a ValueError to serialize out of range float values (nan, inf, -inf) in strict compliance of the JSON specification, instead of using the JavaScript equivalents (NaN, Infinity, -Infinity). </span><br><span class="line">indent：应该是一个非负的整型，如果是0就是顶格分行显示，如果为空就是一行最紧凑显示，否则会换行且按照indent的数值显示前面的空白分行显示，这样打印出来的json数据也叫pretty-printed json </span><br><span class="line">separators：分隔符，实际上是(item_separator, dict_separator)的一个元组，默认的就是(‘,’,’:’)；这表示dictionary内keys之间用“,”隔开，而KEY和value之间用“：”隔开。 </span><br><span class="line">default(obj) is a function that should return a serializable version of obj or raise TypeError. The default simply raises TypeError. </span><br><span class="line">sort_keys：将数据根据keys的值进行排序。 </span><br><span class="line">To use a custom JSONEncoder subclass (e.g. one that overrides the .default() method to serialize additional types), specify it with the cls kwarg; otherwise JSONEncoder is used.</span><br></pre></td></tr></table></figure>

<p><strong>json的格式化输出</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">data = &#123;<span class="string">'username'</span>:[<span class="string">'李华'</span>,<span class="string">'二愣子'</span>],<span class="string">'sex'</span>:<span class="string">'male'</span>,<span class="string">'age'</span>:<span class="number">16</span>&#125;</span><br><span class="line">json_dic2 = json.dumps(data,sort_keys=<span class="literal">True</span>,indent=<span class="number">2</span>,separators=(<span class="string">','</span>,<span class="string">':'</span>),ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">print(json_dic2)</span><br></pre></td></tr></table></figure>

<h4 id="2、pickle"><a href="#2、pickle" class="headerlink" title="2、pickle"></a>2、pickle</h4><p>pickle模块提供了四个功能：dumps、dump(序列化，存）、loads（反序列化，读）、load  （不仅可以序列化字典，列表…<strong>可以把python中任意的数据类型序列化</strong>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>,<span class="string">'k3'</span>:<span class="string">'v3'</span>&#125;</span><br><span class="line">str_dic = pickle.dumps(dic)</span><br><span class="line">print(str_dic)  <span class="comment">#一串二进制内容</span></span><br><span class="line"></span><br><span class="line">dic2 = pickle.loads(str_dic)</span><br><span class="line">print(dic2)    <span class="comment">#字典</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">struct_time  = time.localtime(<span class="number">1000000000</span>)</span><br><span class="line">print(struct_time)</span><br><span class="line">f = open(<span class="string">'pickle_file'</span>,<span class="string">'wb'</span>)</span><br><span class="line">pickle.dump(struct_time,f)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'pickle_file'</span>,<span class="string">'rb'</span>)</span><br><span class="line">struct_time2 = pickle.load(f)</span><br><span class="line">print(struct_time2.tm_year)</span><br></pre></td></tr></table></figure>

<p>这时候机智的你又要说了，既然pickle如此强大，为什么还要学json呢？<br>这里我们要说明一下，json是一种所有的语言都可以识别的数据结构。<br>如果我们将一个字典或者序列化成了一个json存在文件里，那么java代码或者js代码也可以拿来用。<br>但是如果我们用pickle进行序列化，其他语言就不能读懂这是什么了～<br>所以，如果你序列化的内容是列表或者字典，我们非常推荐你使用json模块<br>但如果出于某种原因你不得不序列化其他的数据类型，而未来你还会用python对这个数据进行反序列化的话，那么就可以使用pickle</p>
<h3 id="七、re模块"><a href="#七、re模块" class="headerlink" title="七、re模块"></a>七、re模块</h3><p>讲正题之前我们先来看一个例子：<a href="https://reg.jd.com/reg/person?ReturnUrl=https%3A//www.jd.com/" target="_blank" rel="noopener">https://reg.jd.com/reg/person?ReturnUrl=https%3A//www.jd.com/</a></p>
<p>这是京东的注册页面，打开页面我们就看到这些要求输入个人信息的提示。<br>假如我们随意的在手机号码这一栏输入一个11111111111，它会提示我们格式有误。<br>这个功能是怎么实现的呢？<br>假如现在你用python写一段代码，类似：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phone_number = input(<span class="string">'please input your phone number ： '</span>)</span><br></pre></td></tr></table></figure>

<p>你怎么判断这个phone_number是合法的呢？</p>
<p>根据手机号码一共11位并且是只以13、14、15、18开头的数字这些特点，我们用python写了如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    phone_number = input(<span class="string">'please input your phone number ： '</span>)</span><br><span class="line">    <span class="keyword">if</span> len(phone_number) == <span class="number">11</span> \</span><br><span class="line">            <span class="keyword">and</span> phone_number.isdigit()\</span><br><span class="line">            <span class="keyword">and</span> (phone_number.startswith(<span class="string">'13'</span>) \</span><br><span class="line">            <span class="keyword">or</span> phone_number.startswith(<span class="string">'14'</span>) \</span><br><span class="line">            <span class="keyword">or</span> phone_number.startswith(<span class="string">'15'</span>) \</span><br><span class="line">            <span class="keyword">or</span> phone_number.startswith(<span class="string">'18'</span>)):</span><br><span class="line">        print(<span class="string">'是合法的手机号码'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'不是合法的手机号码'</span>)</span><br></pre></td></tr></table></figure>

<p>这是你的写法，现在我要展示一下我的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">phone_number = input(<span class="string">'please input your phone number ： '</span>)</span><br><span class="line"><span class="keyword">if</span> re.match(<span class="string">'^(13|14|15|18)[0-9]&#123;9&#125;$'</span>,phone_number):</span><br><span class="line">        print(<span class="string">'是合法的手机号码'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'不是合法的手机号码'</span>)</span><br></pre></td></tr></table></figure>

<p>对比上面的两种写法，此时此刻，我要问你你喜欢哪种方法呀？你肯定还是会说第一种，为什么呢？因为第一种不用学呀！<br>但是如果现在有一个文件，我让你从整个文件里匹配出所有的手机号码。你用python给我写个试试？<br>但是学了今天的技能之后，分分钟帮你搞定！</p>
<p>今天我们要学习python里的<strong>re模块和正则表达式</strong>，学会了这个就可以帮我们解决刚刚的疑问。正则表达式不仅在python领域，在整个编程届都占有举足轻重的地位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正则表达式和re模块:</span><br><span class="line">不管以后你是不是去做python开发，只要你是一个程序员就应该了解正则表达式的基本使用。如果未来你要在爬虫领域发展，你就更应该好好学习这方面的知识。</span><br><span class="line">但是你要知道，re模块本质上和正则表达式没有一毛钱的关系。re模块和正则表达式的关系 类似于 time模块和时间的关系</span><br><span class="line">你没有学习python之前，也不知道有一个time模块，但是你已经认识时间了 12:30就表示中午十二点半（这个时间可好，一般这会儿就该下课了）。</span><br><span class="line">时间有自己的格式，年月日时分秒，12个月，365天......已经成为了一种规则。你也早就牢记于心了。time模块只不过是python提供给我们的可以方便我们操作时间的一个工具而已</span><br></pre></td></tr></table></figure>

<p><strong>正则表达式</strong>本身也和python没有什么关系，就是<strong>匹配字符串内容的一种规则</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">官方定义：正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</span><br></pre></td></tr></table></figure>

<h4 id="（1）正则表达式"><a href="#（1）正则表达式" class="headerlink" title="（1）正则表达式"></a>（1）正则表达式</h4><p>​        一说规则我已经知道你很晕了，现在就让我们先来看一些实际的应用。<em>在线测试工具 <a href="http://tool.chinaz.com/regex/" target="_blank" rel="noopener">http://tool.chinaz.com/regex/</a></em></p>
<p>​        首先你要知道的是，谈到正则，就只和字符串相关了。在我给你提供的工具中，你输入的每一个字都是一个字符串。<br>其次，如果在一个位置的一个值，不会出现什么变化，那么是不需要规则的。<br>　　比如你要用”1”去匹配”1”，或者用”2”去匹配”2”，直接就可以匹配上。这连python的字符串操作都可以轻松做到。<br>那么在之后我们更多要考虑的是在<strong>同一个位置上</strong>可以出现的字符的范围。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字符组 ： [字符组]</span><br><span class="line">在同一个位置可能出现的各种字符组成了一个字符组，在正则表达式中用[]表示</span><br><span class="line">字符分为很多类，比如数字、字母、标点等等。</span><br><span class="line">假如你现在要求一个位置&quot;只能出现一个数字&quot;,那么这个位置上的字符只能是0、1、2...9这10个数之一。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><code>正则</code></th>
<th><code>待匹配字符</code></th>
<th><code>匹配结果</code></th>
<th><code>说明</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>[0123456789]</code></td>
<td><code>8</code></td>
<td><code>True</code></td>
<td><code>在一个字符组里枚举合法的所有字符，字符组里的任意一个字符和&quot;待匹配字符&quot;相同都视为可以匹配</code></td>
</tr>
<tr>
<td><code>[0123456789]</code></td>
<td><code>a</code></td>
<td><code>False</code></td>
<td><code>由于字符组中没有&quot;a&quot;字符，所以不能匹配</code></td>
</tr>
<tr>
<td><code>[0-9]</code></td>
<td><code>7</code></td>
<td><code>True</code></td>
<td><code>也可以用-表示范围,[0-9]就和[0123456789]是一个意思</code></td>
</tr>
<tr>
<td><code>[a-z]</code></td>
<td><code>s</code></td>
<td><code>True</code></td>
<td><code>同样的如果要匹配所有的小写字母，直接用[a-z]就可以表示</code></td>
</tr>
<tr>
<td><code>[A-Z]</code></td>
<td><code>B</code></td>
<td><code>True</code></td>
<td><code>[A-Z]就表示所有的大写字母</code></td>
</tr>
<tr>
<td><code>[0-9a-fA-F]</code></td>
<td><code>e</code></td>
<td><code>True</code></td>
<td><code>可以匹配数字，大小写形式的a～f，用来验证十六进制字符</code></td>
</tr>
</tbody></table>
<p><strong><em>字符：</em></strong></p>
<table>
<thead>
<tr>
<th><code>元字符</code></th>
<th><code>匹配内容</code></th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词的结尾</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结尾</td>
</tr>
<tr>
<td>\W</td>
<td><code>匹配非字母或数字或下划线</code></td>
</tr>
<tr>
<td>\D</td>
<td><code>匹配非数字</code></td>
</tr>
<tr>
<td>\S</td>
<td><code>匹配非空白符</code></td>
</tr>
<tr>
<td>a|b</td>
<td><code>匹配字符a或字符b</code></td>
</tr>
<tr>
<td>()</td>
<td><code>匹配括号内的表达式，也表示一个组</code></td>
</tr>
<tr>
<td>[…]</td>
<td><code>匹配字符组中的字符</code></td>
</tr>
<tr>
<td>[^…]</td>
<td><code>匹配除了字符组中字符的所有字符</code></td>
</tr>
</tbody></table>
<p><strong><em>量词：</em></strong></p>
<table>
<thead>
<tr>
<th><code>量词</code></th>
<th><code>用法说明</code></th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<h5 id="1、"><a href="#1、" class="headerlink" title="1、. ^ $"></a>1、. ^ $</h5><table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>海.</td>
<td>海燕海娇海东</td>
<td>海燕海娇海东</td>
<td>匹配所有”海.”的字符</td>
</tr>
<tr>
<td>^海.</td>
<td>海燕海娇海东</td>
<td>海燕</td>
<td>只从开头匹配”海.”</td>
</tr>
<tr>
<td>海.$</td>
<td>海燕海娇海东</td>
<td>海东</td>
<td>只匹配结尾的”海.$”</td>
</tr>
</tbody></table>
<h5 id="2、"><a href="#2、" class="headerlink" title="2、* + ? { }"></a>2、* + ? { }</h5><table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>李.?</td>
<td>李杰和李莲英和李二棍子</td>
<td>李杰 李莲 李二</td>
<td><code>?表示重复零次或一次，即只匹配&quot;李&quot;后面一个任意字符</code></td>
</tr>
<tr>
<td>李.*</td>
<td>李杰和李莲英和李二棍子</td>
<td>李杰和李莲英和李二棍子</td>
<td><code>*表示重复零次或多次，即匹配&quot;李&quot;后面0或多个任意字符</code></td>
</tr>
<tr>
<td>李.+</td>
<td>李杰和李莲英和李二棍子</td>
<td>李杰和李莲英和李二棍子</td>
<td><code>+表示重复一次或多次，即只匹配&quot;李&quot;后面1个或多个任意字符</code></td>
</tr>
<tr>
<td>李.{1,2}</td>
<td>李杰和李莲英和李二棍子</td>
<td>李杰和 李莲英 李二棍</td>
<td><code>{1,2}匹配1到2次任意字符</code></td>
</tr>
</tbody></table>
<p><strong><em>注意：</em></strong></p>
<p>前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配</p>
<table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>李.*?</td>
<td>李杰和李莲英和李二棍子</td>
<td>李 李 李</td>
<td>惰性匹配</td>
</tr>
</tbody></table>
<h5 id="3、字符集［］［-］"><a href="#3、字符集［］［-］" class="headerlink" title="3、字符集［］［^］"></a>3、字符集［］［^］</h5><table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>李[杰莲英二棍子]*</td>
<td>李杰和李莲英和李二棍子</td>
<td>李杰 李莲英 李二棍子</td>
<td><code>表示匹配&quot;李&quot;字后面[杰莲英二棍子]的字符任意次</code></td>
</tr>
<tr>
<td>李[^和]*</td>
<td>李杰和李莲英和李二棍子</td>
<td>李杰 李莲英 李二棍子</td>
<td><code>表示匹配一个不是&quot;和&quot;的字符任意次</code></td>
</tr>
<tr>
<td>[\d]</td>
<td>456bdha3</td>
<td>4 5 6 3</td>
<td><code>表示匹配任意一个数字，匹配到4个结果</code></td>
</tr>
<tr>
<td>[\d]+</td>
<td>456bdha3</td>
<td>456 3</td>
<td><code>表示匹配任意个数字，匹配到2个结果</code></td>
</tr>
</tbody></table>
<h5 id="4、分组-与-或-｜［-］"><a href="#4、分组-与-或-｜［-］" class="headerlink" title="4、分组 ()与 或 ｜［^］"></a>4、分组 ()与 或 ｜［^］</h5><p>身份证号码是一个长度为15或18个字符的字符串，如果是15位则全部由数字组成，首位不能为0；如果是18位，则前17位全部是数字，末位可能是数字或x，下面我们尝试用正则来表示：</p>
<table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>^[1-9]\d{13,16}[0-9x]$</td>
<td>110101198001017032</td>
<td>110101198001017032</td>
<td>表示可以匹配一个正确的身份证号</td>
</tr>
<tr>
<td>^[1-9]\d{13,16}[0-9x]$</td>
<td>1101011980010170</td>
<td>1101011980010170</td>
<td><code>表示也可以匹配这串数字，但这并不是一个正确的身份证号码，它是一个16位的数字</code></td>
</tr>
<tr>
<td>^[1-9]\d{14}(\d{2}[0-9x])?$</td>
<td>1101011980010170</td>
<td>False</td>
<td><code>现在不会匹配错误的身份证号了()表示分组，将\d{2}[0-9x]分成一组，就可以整体约束他们出现的次数为0-1次</code></td>
</tr>
<tr>
<td>^([1-9]\d{16}[0-9x]|[1-9]\d{14})$</td>
<td>110105199812067023</td>
<td>110105199812067023</td>
<td><code>表示先匹配[1-9]\d{16}[0-9x]如果没有匹配上就匹配[1-9]\d{14}</code></td>
</tr>
</tbody></table>
<h5 id="5、转义符"><a href="#5、转义符" class="headerlink" title="5、转义符 \"></a>5、转义符 \</h5><p>在正则表达式中，有很多有特殊意义的是元字符，比如\n和\s等，如果要在正则中匹配正常的”\n”而不是”换行符”就需要对”\“进行转义，变成’\\‘。</p>
<p>在python中，无论是正则表达式，还是待匹配的内容，都是以字符串的形式出现的，在字符串中\也有特殊的含义，本身还需要转义。所以如果匹配一次”\n”,字符串中要写成’\\n’，那么正则里就要写成”\\\\n”,这样就太麻烦了。这个时候我们就用到了r’\n’这个概念，此时的正则是r’\\n’就可以了。</p>
<table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>\n</td>
<td>False</td>
<td><code>因为在正则表达式中\是有特殊意义的字符，所以要匹配\n本身，用表达式\n无法匹配</code></td>
</tr>
<tr>
<td>\\n</td>
<td>\n</td>
<td>True</td>
<td><code>转义\之后变成\\，即可匹配</code></td>
</tr>
<tr>
<td>“\\\\n”</td>
<td>‘\\n’</td>
<td>True</td>
<td><code>如果在python中，字符串中的&#39;\&#39;也需要转义，所以每一个字符串&#39;\&#39;又需要转义一次</code></td>
</tr>
<tr>
<td>r’\\n’</td>
<td>r’\n’</td>
<td>True</td>
<td><code>在字符串之前加r，让整个字符串不转义</code></td>
</tr>
</tbody></table>
<h5 id="6、贪婪匹配"><a href="#6、贪婪匹配" class="headerlink" title="6、贪婪匹配"></a>6、贪婪匹配</h5><p>贪婪匹配：在满足匹配时，匹配尽可能长的字符串，默认情况下，采用贪婪匹配</p>
<table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配 结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;.*&gt;</td>
<td><script>...<script></td>
<td><script>...<script></td>
<td><code>默认为贪婪匹配模式，会匹配尽量长的字符串</code></td>
</tr>
<tr>
<td><.*?></td>
<td>r'\d'</td>
<td><script> <script></td>
<td><code>加上？为将贪婪匹配模式转为非贪婪匹配模式，会匹配尽量短的字符串</code></td>
</tr>
</tbody></table>
<p>几个常用的非贪婪匹配Pattern：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*? 重复任意次，但尽可能少重复</span><br><span class="line">+? 重复1次或更多次，但尽可能少重复</span><br><span class="line">?? 重复0次或1次，但尽可能少重复</span><br><span class="line">&#123;n,m&#125;? 重复n到m次，但尽可能少重复</span><br><span class="line">&#123;n,&#125;? 重复n次以上，但尽可能少重复</span><br></pre></td></tr></table></figure>

<p>. * ? 的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">. 是任意字符</span><br><span class="line">* 是取 0 至 无限长度</span><br><span class="line">? 是非贪婪模式。</span><br><span class="line">  何在一起就是 取尽量少的任意字符，一般不会这么单独写，他大多用在：</span><br><span class="line">  .*?x</span><br><span class="line"></span><br><span class="line">就是取前面任意长度的字符，直到一个x出现</span><br></pre></td></tr></table></figure>

<h4 id="（2）re模块下的常用方法"><a href="#（2）re模块下的常用方法" class="headerlink" title="（2）re模块下的常用方法"></a>（2）re模块下的常用方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.findall(<span class="string">'a'</span>, <span class="string">'eva egon yuan'</span>)  <span class="comment"># 返回所有满足匹配条件的结果,放在列表里</span></span><br><span class="line">print(ret) <span class="comment">#结果 : ['a', 'a']</span></span><br><span class="line"></span><br><span class="line">ret = re.search(<span class="string">'a'</span>, <span class="string">'eva egon yuan'</span>).group()</span><br><span class="line">print(ret) <span class="comment">#结果 : 'a'</span></span><br><span class="line"><span class="comment"># 函数会在字符串内查找模式匹配,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以</span></span><br><span class="line"><span class="comment"># 通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。</span></span><br><span class="line"></span><br><span class="line">ret = re.match(<span class="string">'a'</span>, <span class="string">'abc'</span>).group()  <span class="comment"># 同search,不过尽在字符串开始处进行匹配</span></span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment">#结果 : 'a'</span></span><br><span class="line"></span><br><span class="line">ret = re.split(<span class="string">'[ab]'</span>, <span class="string">'abcd'</span>)  <span class="comment"># 先按'a'分割得到''和'bcd',在对''和'bcd'分别按'b'分割</span></span><br><span class="line">print(ret)  <span class="comment"># ['', '', 'cd']</span></span><br><span class="line"></span><br><span class="line">ret = re.sub(<span class="string">'\d'</span>, <span class="string">'H'</span>, <span class="string">'eva3egon4yuan4'</span>, <span class="number">1</span>)<span class="comment">#将数字替换成'H'，参数1表示只替换1个</span></span><br><span class="line">print(ret) <span class="comment">#evaHegon4yuan4</span></span><br><span class="line"></span><br><span class="line">ret = re.subn(<span class="string">'\d'</span>, <span class="string">'H'</span>, <span class="string">'eva3egon4yuan4'</span>)<span class="comment">#将数字替换成'H'，返回元组(替换的结果,替换了多少次)</span></span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">obj = re.compile(<span class="string">'\d&#123;3&#125;'</span>)  <span class="comment">#将正则表达式编译成为一个 正则表达式对象，规则要匹配的是3个数字</span></span><br><span class="line">ret = obj.search(<span class="string">'abc123eeee'</span>) <span class="comment">#正则表达式对象调用search，参数为待匹配的字符串</span></span><br><span class="line">print(ret.group())  <span class="comment">#结果 ： 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">ret = re.finditer(<span class="string">'\d'</span>, <span class="string">'ds3sy4784a'</span>)   <span class="comment">#finditer返回一个存放匹配结果的迭代器</span></span><br><span class="line">print(ret)  <span class="comment"># &lt;callable_iterator object at 0x10195f940&gt;</span></span><br><span class="line">print(next(ret).group())  <span class="comment">#查看第一个结果</span></span><br><span class="line">print(next(ret).group())  <span class="comment">#查看第二个结果</span></span><br><span class="line">print([i.group() <span class="keyword">for</span> i <span class="keyword">in</span> ret])  <span class="comment">#查看剩余的左右结果</span></span><br></pre></td></tr></table></figure>

<p><strong><em>注意：</em></strong></p>
<ol>
<li><p>findall的优先级查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">ret = re.findall(&apos;www.(baidu|oldboy).com&apos;, &apos;www.oldboy.com&apos;)</span><br><span class="line">print(ret)  # [&apos;oldboy&apos;]     这是因为findall会优先把匹配结果组里内容返回,如果想要匹配结果,取消权限即可</span><br><span class="line"></span><br><span class="line">ret = re.findall(&apos;www.(?:baidu|oldboy).com&apos;, &apos;www.oldboy.com&apos;)</span><br><span class="line">print(ret)  # [&apos;www.oldboy.com&apos;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>split的优先级查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ret=re.split(&quot;\d+&quot;,&quot;eva3egon4yuan&quot;)</span><br><span class="line">print(ret) #结果 ： [&apos;eva&apos;, &apos;egon&apos;, &apos;yuan&apos;]</span><br><span class="line"></span><br><span class="line">ret=re.split(&quot;(\d+)&quot;,&quot;eva3egon4yuan&quot;)</span><br><span class="line">print(ret) #结果 ： [&apos;eva&apos;, &apos;3&apos;, &apos;egon&apos;, &apos;4&apos;, &apos;yuan&apos;]</span><br><span class="line"></span><br><span class="line">#在匹配部分加上（）之后所切出的结果是不同的，</span><br><span class="line">#没有（）的没有保留所匹配的项，但是有（）的却能够保留了匹配的项，</span><br><span class="line">#这个在某些需要保留匹配部分的使用过程是非常重要的。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="（3）综合练习与扩展"><a href="#（3）综合练习与扩展" class="headerlink" title="（3）综合练习与扩展"></a>（3）综合练习与扩展</h4><h5 id="1、匹配标签"><a href="#1、匹配标签" class="headerlink" title="1、匹配标签"></a>1、匹配标签</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = re.search(<span class="string">"&lt;(?P&lt;tag_name&gt;\w+)&gt;\w+&lt;/(?P=tag_name)&gt;"</span>,<span class="string">"&lt;h1&gt;hello&lt;/h1&gt;"</span>)</span><br><span class="line"><span class="comment">#还可以在分组中利用?&lt;name&gt;的形式给分组起名字</span></span><br><span class="line"><span class="comment">#获取的匹配结果可以直接用group('名字')拿到对应的值</span></span><br><span class="line">print(ret.group(<span class="string">'tag_name'</span>))  <span class="comment">#结果 ：h1</span></span><br><span class="line">print(ret.group())  <span class="comment">#结果 ：&lt;h1&gt;hello&lt;/h1&gt;</span></span><br><span class="line"></span><br><span class="line">ret = re.search(<span class="string">r"&lt;(\w+)&gt;\w+&lt;/\1&gt;"</span>,<span class="string">"&lt;h1&gt;hello&lt;/h1&gt;"</span>)</span><br><span class="line"><span class="comment">#如果不给组起名字，也可以用\序号来找到对应的组，表示要找的内容和前面的组内容一致</span></span><br><span class="line"><span class="comment">#获取的匹配结果可以直接用group(序号)拿到对应的值</span></span><br><span class="line">print(ret.group(<span class="number">1</span>))</span><br><span class="line">print(ret.group())  <span class="comment">#结果 ：&lt;h1&gt;hello&lt;/h1&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2、匹配整数"><a href="#2、匹配整数" class="headerlink" title="2、匹配整数"></a>2、匹配整数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret=re.findall(<span class="string">r"\d+"</span>,<span class="string">"1-2*(60+(-40.35/5)-(-4*3))"</span>)</span><br><span class="line">print(ret) <span class="comment">#['1', '2', '60', '40', '35', '5', '4', '3']</span></span><br><span class="line">ret=re.findall(<span class="string">r"-?\d+\.\d*|(-?\d+)"</span>,<span class="string">"1-2*(60+(-40.35/5)-(-4*3))"</span>)</span><br><span class="line">print(ret) <span class="comment">#['1', '-2', '60', '', '5', '-4', '3']</span></span><br><span class="line">ret.remove(<span class="string">""</span>)</span><br><span class="line">print(ret) <span class="comment">#['1', '-2', '60', '5', '-4', '3']</span></span><br></pre></td></tr></table></figure>

<h5 id="3、数字匹配"><a href="#3、数字匹配" class="headerlink" title="3、数字匹配"></a>3、数字匹配</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、 匹配一段文本中的每行的邮箱</span><br><span class="line">      http://blog.csdn.net/make164492212/article/details/51656638</span><br><span class="line"></span><br><span class="line">2、 匹配一段文本中的每行的时间字符串，比如：‘1990-07-12’；</span><br><span class="line"></span><br><span class="line">   分别取出1年的12个月（^(0?[1-9]|1[0-2])$）、</span><br><span class="line">   一个月的31天：^((0?[1-9])|((1|2)[0-9])|30|31)$</span><br><span class="line"></span><br><span class="line">3、 匹配qq号。(腾讯QQ号从10000开始)  ［1,9］[0,9]&#123;4,&#125;</span><br><span class="line"></span><br><span class="line">4、 匹配一个浮点数。       ^(-?\d+)(\.\d+)?$   或者  -?\d+\.?\d*</span><br><span class="line"></span><br><span class="line">5、 匹配汉字。             ^[\u4e00-\u9fa5]&#123;0,&#125;$ </span><br><span class="line"></span><br><span class="line">6、 匹配出所有整数</span><br></pre></td></tr></table></figure>

<h5 id="4、爬虫练习"><a href="#4、爬虫练习" class="headerlink" title="4、爬虫练习"></a>4、爬虫练习</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPage</span><span class="params">(url)</span>:</span></span><br><span class="line"></span><br><span class="line">    response=requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> response.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsePage</span><span class="params">(s)</span>:</span></span><br><span class="line">    </span><br><span class="line">    com=re.compile(<span class="string">'&lt;div class="item"&gt;.*?&lt;div class="pic"&gt;.*?&lt;em .*?&gt;(?P&lt;id&gt;\d+).*?&lt;span class="title"&gt;(?P&lt;title&gt;.*?)&lt;/span&gt;'</span></span><br><span class="line">                   <span class="string">'.*?&lt;span class="rating_num" .*?&gt;(?P&lt;rating_num&gt;.*?)&lt;/span&gt;.*?&lt;span&gt;(?P&lt;comment_num&gt;.*?)评价&lt;/span&gt;'</span>,re.S)</span><br><span class="line"></span><br><span class="line">    ret=com.finditer(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">"id"</span>:i.group(<span class="string">"id"</span>),</span><br><span class="line">            <span class="string">"title"</span>:i.group(<span class="string">"title"</span>),</span><br><span class="line">            <span class="string">"rating_num"</span>:i.group(<span class="string">"rating_num"</span>),</span><br><span class="line">            <span class="string">"comment_num"</span>:i.group(<span class="string">"comment_num"</span>),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(num)</span>:</span></span><br><span class="line"></span><br><span class="line">    url=<span class="string">'https://movie.douban.com/top250?start=%s&amp;filter='</span>%num</span><br><span class="line">    response_html=getPage(url)</span><br><span class="line">    ret=parsePage(response_html)</span><br><span class="line">    print(ret)</span><br><span class="line">    f=open(<span class="string">"move_info7"</span>,<span class="string">"a"</span>,encoding=<span class="string">"utf8"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> ret:</span><br><span class="line">        print(obj)</span><br><span class="line">        data=json.dumps(obj,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        f.write(data+<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        main(count)</span><br><span class="line">        count+=<span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>简化版：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPage</span><span class="params">(url)</span>:</span></span><br><span class="line">    response = urlopen(url)</span><br><span class="line">    <span class="keyword">return</span> response.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsePage</span><span class="params">(s)</span>:</span></span><br><span class="line">    com = re.compile(</span><br><span class="line">        <span class="string">'&lt;div class="item"&gt;.*?&lt;div class="pic"&gt;.*?&lt;em .*?&gt;(?P&lt;id&gt;\d+).*?&lt;span class="title"&gt;(?P&lt;title&gt;.*?)&lt;/span&gt;'</span></span><br><span class="line">        <span class="string">'.*?&lt;span class="rating_num" .*?&gt;(?P&lt;rating_num&gt;.*?)&lt;/span&gt;.*?&lt;span&gt;(?P&lt;comment_num&gt;.*?)评价&lt;/span&gt;'</span>, re.S)</span><br><span class="line"></span><br><span class="line">    ret = com.finditer(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">"id"</span>: i.group(<span class="string">"id"</span>),</span><br><span class="line">            <span class="string">"title"</span>: i.group(<span class="string">"title"</span>),</span><br><span class="line">            <span class="string">"rating_num"</span>: i.group(<span class="string">"rating_num"</span>),</span><br><span class="line">            <span class="string">"comment_num"</span>: i.group(<span class="string">"comment_num"</span>),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(num)</span>:</span></span><br><span class="line">    url = <span class="string">'https://movie.douban.com/top250?start=%s&amp;filter='</span> % num</span><br><span class="line">    response_html = getPage(url)</span><br><span class="line">    ret = parsePage(response_html)</span><br><span class="line">    print(ret)</span><br><span class="line">    f = open(<span class="string">"move_info7"</span>, <span class="string">"a"</span>, encoding=<span class="string">"utf8"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> ret:</span><br><span class="line">        print(obj)</span><br><span class="line">        data = str(obj)</span><br><span class="line">        f.write(data + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    main(count)</span><br><span class="line">    count += <span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>flags：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flags有很多可选值：</span><br><span class="line"></span><br><span class="line">re.I(IGNORECASE)忽略大小写，括号内是完整的写法</span><br><span class="line">re.M(MULTILINE)多行模式，改变^和$的行为</span><br><span class="line">re.S(DOTALL)点可以匹配任意字符，包括换行符</span><br><span class="line">re.L(LOCALE)做本地化识别的匹配，表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境，不推荐使用</span><br><span class="line">re.U(UNICODE) 使用\w \W \s \S \d \D使用取决于unicode定义的字符属性。在python3中默认使用该flag</span><br><span class="line">re.X(VERBOSE)冗长模式，该模式下pattern字符串可以是多行的，忽略空白字符，并可以添加注释</span><br></pre></td></tr></table></figure>

</script></td></tr></tbody></table>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="John Doe">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://suliangxu.github.io" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1193135584@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  



  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
