<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="网络编程,">










<meta name="description" content="[TOC] （一）楔子​       你现在已经学会了写python代码，假如你写了两个python文件a.py和b.py，分别去运行，你就会发现，这两个python的文件分别运行的很好。但是如果这两个程序之间想要传递一个数据，你要怎么做呢？ ​       这个问题以你现在的知识就可以解决了，我们可以创建一个文件，把a.py想要传递的内容写到文件中，然后b.py从这个文件中读取内容就可以了。">
<meta name="keywords" content="网络编程">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程">
<meta property="og:url" content="http://yoursite.com/2019/07/23/python全栈/第01部分：基础+模块+面向对象+网络编程/网络编程/网络编程/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[TOC] （一）楔子​       你现在已经学会了写python代码，假如你写了两个python文件a.py和b.py，分别去运行，你就会发现，这两个python的文件分别运行的很好。但是如果这两个程序之间想要传递一个数据，你要怎么做呢？ ​       这个问题以你现在的知识就可以解决了，我们可以创建一个文件，把a.py想要传递的内容写到文件中，然后b.py从这个文件中读取内容就可以了。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/6.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/10.png">
<meta property="og:updated_time" content="2019-08-02T10:12:54.577Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网络编程">
<meta name="twitter:description" content="[TOC] （一）楔子​       你现在已经学会了写python代码，假如你写了两个python文件a.py和b.py，分别去运行，你就会发现，这两个python的文件分别运行的很好。但是如果这两个程序之间想要传递一个数据，你要怎么做呢？ ​       这个问题以你现在的知识就可以解决了，我们可以创建一个文件，把a.py想要传递的内容写到文件中，然后b.py从这个文件中读取内容就可以了。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/07/23/python全栈/第01部分：基础+模块+面向对象+网络编程/网络编程/网络编程/">





  <title>网络编程 | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/23/python全栈/第01部分：基础+模块+面向对象+网络编程/网络编程/网络编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">网络编程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-23T09:03:20+08:00">
                2019-07-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python全栈-01部分-网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">python全栈 -01部分 -网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h2 id="（一）楔子"><a href="#（一）楔子" class="headerlink" title="（一）楔子"></a>（一）楔子</h2><p>​       你现在已经学会了写python代码，假如你写了两个python文件a.py和b.py，分别去运行，你就会发现，这两个python的文件分别运行的很好。但是如果这两个程序之间想要传递一个数据，你要怎么做呢？</p>
<p>​       这个问题以你现在的知识就可以解决了，我们可以创建一个文件，把a.py想要传递的内容写到文件中，然后b.py从这个文件中读取内容就可以了。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1.png" alt></p>
<p>​        但是当你的a.py和b.py分别在不同电脑上的时候，你要怎么办呢？</p>
<p>​      类似的机制有计算机网盘，qq等等。我们可以在我们的电脑上和别人聊天，可以在自己的电脑上向网盘中上传、下载内容。这些都是两个程序在通信。</p>
<h2 id="（二）软件开发的架构"><a href="#（二）软件开发的架构" class="headerlink" title="（二）软件开发的架构"></a>（二）软件开发的架构</h2><p>我们了解的涉及到两个程序之间通讯的应用大致可以分为两种：</p>
<p>第一种是应用类：qq、微信、网盘、优酷这一类是属于需要安装的桌面应用</p>
<p>第二种是web类：比如百度、知乎、博客园等使用浏览器访问就可以直接使用的应用</p>
<p>这些应用的本质其实都是两个程序之间的通讯。而这两个分类又对应了两个软件开发的架构～</p>
<h3 id="一、C-S架构"><a href="#一、C-S架构" class="headerlink" title="一、C/S架构"></a>一、C/S架构</h3><p>​      C/S即：<strong>Client与Server</strong> ，中文意思：客户端与服务器端架构，这种架构也是从用户层面（也可以是物理层面）来划分的。</p>
<p>​        服务端是要一直运行，等待服务别人的</p>
<p>​        客户端是当人们有需求时，才请求服务</p>
<p>​       这里的客户端一般泛指客户端应用程序EXE，程序需要先安装后，才能运行在用户的电脑上，对用户的电脑操作系统环境依赖较大。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2.png" alt></p>
<h3 id="二、B-S架构"><a href="#二、B-S架构" class="headerlink" title="二、B/S架构"></a>二、B/S架构</h3><p>​        B/S即：<strong>Browser与Server</strong>,中文意思：浏览器端与服务器端架构，这种架构是从用户层面来划分的。</p>
<p>​        Browser浏览器，其实也是一种Client客户端，只是这个客户端不需要大家去安装什么应用程序，只需在浏览器上通过HTTP请求服务器端相关的资源（网页资源），客户端Browser浏览器就能进行增删改查。</p>
<p>​        <strong>B/S架构其实也是一种C/S架构。</strong></p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/3.png" alt></p>
<h2 id="（三）网络基础"><a href="#（三）网络基础" class="headerlink" title="（三）网络基础"></a>（三）网络基础</h2><h3 id="一、一个程序如何在网络上找到另一个程序？"><a href="#一、一个程序如何在网络上找到另一个程序？" class="headerlink" title="一、一个程序如何在网络上找到另一个程序？"></a>一、一个程序如何在网络上找到另一个程序？</h3><p>​        首先，程序必须要启动，其次，必须有这台机器的地址，我们都知道我们人的地址大概就是国家\省\市\区\街道\楼\门牌号这样字。那么每一台联网的机器在网络上也有自己的地址，它的地址是怎么表示的呢？</p>
<p>​       就是使用一串数字来表示的，例如：100.4.5.6</p>
<p><strong>1、什么是ip地址</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP地址是指互联网协议地址（英语：Internet Protocol Address，又译为网际协议地址），是IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</span><br><span class="line"></span><br><span class="line">IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节）。IP地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。例：点分十进IP地址（100.4.5.6），实际上是32位二进制数（01100100.00000100.00000101.00000110）。</span><br></pre></td></tr></table></figure>

<p>本地回环地址：127.0.0.1</p>
<p><strong>2、什么是端口</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"端口"是英文port的意译，可以认为是设备与外界通讯交流的出口。</span><br></pre></td></tr></table></figure>

<p><strong>3、在windows上查看端口占用情况</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -aon|findstr "49157"</span><br></pre></td></tr></table></figure>

<p>因此ip地址精确到具体的一台电脑，而端口精确到具体的程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">我们找寻一台机器 : ip地址</span><br><span class="line">    如何判断 要找的机器在不在同一个局域网内:</span><br><span class="line">        用自己的ip地址和子网掩码按位与运算</span><br><span class="line">        192.168.21.36 11000000.10101000.00010101.00100100</span><br><span class="line">        255.255.255.0 11111111.11111111.11111111.00000000</span><br><span class="line">        192.168.21.0  11000000.10101000.00010101.00000000  # ---网段</span><br><span class="line">        用要找的机器ip和子网掩码按位与运算</span><br><span class="line">        192.168.21.21</span><br><span class="line">        如果上面的两个结果相同说明两台机器在同一个网段</span><br><span class="line">        子网掩码</span><br><span class="line">            2进制 8进制 10进制 16进制</span><br><span class="line"></span><br><span class="line">            16 8 4 2 1 (填位法)</span><br><span class="line">            1  0 1 0 0</span><br><span class="line">    要找的机器和你在同一个局域网内:</span><br><span class="line">        通过交换机</span><br><span class="line">            广播</span><br><span class="line">            和要找机器ip地址相同的服务器做出响应,将自己的ip地址返回给交换机</span><br><span class="line">            单播 : 把返回的信息再传递给要找机器的服务器</span><br><span class="line">    要找的机器和你不在同一个局域网内</span><br><span class="line">            先走交换机</span><br><span class="line">            交换机直接将消息传递给&quot;网关ip&quot;,通过ip找到对应机器所在的局域网</span><br><span class="line">            路由表 :网段 网关ip</span><br><span class="line">            通过对方局域网中的交换机进行广播</span><br><span class="line">            把信息回传给交换机</span><br><span class="line">            ......</span><br></pre></td></tr></table></figure>

<h3 id="二、osi七层模型"><a href="#二、osi七层模型" class="headerlink" title="二、osi七层模型"></a>二、osi七层模型</h3><h4 id="1、引子"><a href="#1、引子" class="headerlink" title="1、引子"></a>1、引子</h4><p>​        须知一个完整的计算机系统是由硬件、操作系统、应用软件三者组成,具备了这三个条件，一台计算机系统就可以自己跟自己玩了（打个单机游戏，玩个扫雷啥的）</p>
<p>​        如果你要跟别人一起玩，那你就需要上网了，什么是互联网？</p>
<p>​        互联网的核心就是由一堆协议组成，协议就是标准，比如全世界人通信的标准是英语，如果把计算机比作人，互联网协议就是计算机界的英语。所有的计算机都学会了互联网协议，那所有的计算机都就可以按照统一的标准去收发信息从而完成通信了。</p>
<h4 id="2、osi七层模型"><a href="#2、osi七层模型" class="headerlink" title="2、osi七层模型"></a>2、osi七层模型</h4><p>人们按照分工不同把互联网协议从逻辑上划分了层级：</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/4.png" alt></p>
<h3 id="三、socket概念"><a href="#三、socket概念" class="headerlink" title="三、socket概念"></a>三、socket概念</h3><h4 id="1、socket层"><a href="#1、socket层" class="headerlink" title="1、socket层"></a>1、socket层</h4><p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/5.png" alt></p>
<h4 id="2、理解socket"><a href="#2、理解socket" class="headerlink" title="2、理解socket"></a>2、理解socket</h4><p>​       Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其实站在你的角度上看，socket就是一个模块。我们通过调用模块中已经实现的方法建立两个进程之间的连接和通信。</span><br><span class="line">也有人将socket说成ip+port，因为ip是用来标识互联网中的一台主机的位置，而port（端口）是用来标识这台机器上的一个应用程序。</span><br><span class="line">所以我们只要确立了ip和port就能找到一个应用程序，并且使用socket模块来与之通信。</span><br></pre></td></tr></table></figure>

<h3 id="四、套接字（socket）的发展史"><a href="#四、套接字（socket）的发展史" class="headerlink" title="四、套接字（socket）的发展史"></a>四、套接字（socket）的发展史</h3><p>​       套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计<strong>用在同 一台主机上多个应用程序之间的通讯</strong>。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。 </p>
<h4 id="1、基于文件类型的套接字家族"><a href="#1、基于文件类型的套接字家族" class="headerlink" title="1、基于文件类型的套接字家族"></a>1、基于文件类型的套接字家族</h4><p>套接字家族的名字：AF_UNIX</p>
<p>unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信。</p>
<h4 id="2、基于网络类型的套接字家族"><a href="#2、基于网络类型的套接字家族" class="headerlink" title="2、基于网络类型的套接字家族"></a>2、基于网络类型的套接字家族</h4><p>套接字家族的名字：AF_INET（用于ipv4）</p>
<p>(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)</p>
<h3 id="五、tcp协议和udp协议"><a href="#五、tcp协议和udp协议" class="headerlink" title="五、tcp协议和udp协议"></a>五、tcp协议和udp协议</h3><p><strong>TCP</strong>（Transmission Control Protocol）可靠的、面向连接的协议（eg:打电话）、传输效率低全双工通信（发送缓存&amp;接收缓存）、面向字节流。使用TCP的应用：Web浏览器；电子邮件、文件传输程序。</p>
<p><strong>UDP</strong>（User Datagram Protocol）不可靠的、无连接的服务，传输效率高（发送前时延小），一对一、一对多、多对一、多对多、面向报文，尽最大努力服务，无拥塞控制。使用UDP的应用：域名系统 (DNS)；视频流；IP语音(VoIP)。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/6.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TCP协议属于 : 传输层</span><br><span class="line">    面向连接 可靠的 字节流传输  长连接（一对一）</span><br><span class="line">UDP协议属于 : 传输层</span><br><span class="line">    面向数据包的 无连接的 不可靠的 速度快 不占用连接</span><br></pre></td></tr></table></figure>

<h2 id="（四）套接字（socket）初使用"><a href="#（四）套接字（socket）初使用" class="headerlink" title="（四）套接字（socket）初使用"></a>（四）套接字（socket）初使用</h2><h3 id="一、基于TCP协议的socket"><a href="#一、基于TCP协议的socket" class="headerlink" title="一、基于TCP协议的socket"></a>一、基于TCP协议的socket</h3><p><strong>tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端</strong></p>
<p><strong>（1）</strong></p>
<p><strong>server端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8898</span>))  <span class="comment">#把地址绑定到套接字</span></span><br><span class="line">sk.listen()          <span class="comment">#监听链接</span></span><br><span class="line">conn,addr = sk.accept() <span class="comment">#接受客户端链接</span></span><br><span class="line">ret = conn.recv(<span class="number">1024</span>)  <span class="comment">#接收客户端信息</span></span><br><span class="line">print(ret)       <span class="comment">#打印客户端信息</span></span><br><span class="line">conn.send(<span class="string">b'hi'</span>)        <span class="comment">#向客户端发送信息</span></span><br><span class="line">conn.close()       <span class="comment">#关闭客户端套接字</span></span><br><span class="line">sk.close()        <span class="comment">#关闭服务器套接字(可选)</span></span><br></pre></td></tr></table></figure>

<p><strong>client端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sk = socket.socket()           <span class="comment"># 创建客户套接字</span></span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8898</span>))    <span class="comment"># 尝试连接服务器</span></span><br><span class="line">sk.send(<span class="string">b'hello!'</span>)</span><br><span class="line">ret = sk.recv(<span class="number">1024</span>)         <span class="comment"># 对话(发送/接收)</span></span><br><span class="line">print(ret)</span><br><span class="line">sk.close()            <span class="comment"># 关闭客户套接字</span></span><br></pre></td></tr></table></figure>

<p><strong>问题：重启服务端时遇到</strong></p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/7.png" alt></p>
<p>解决方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加入一条socket配置，重用ip和端口</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> SOL_SOCKET,SO_REUSEADDR</span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>) <span class="comment">#就是它，在bind前加,避免重启服务端时，出现OSError</span></span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8898</span>))  <span class="comment">#把地址绑定到套接字</span></span><br><span class="line">sk.listen()          <span class="comment">#监听链接</span></span><br><span class="line">conn,addr = sk.accept() <span class="comment">#接受客户端链接</span></span><br><span class="line">ret = conn.recv(<span class="number">1024</span>)   <span class="comment">#接收客户端信息</span></span><br><span class="line">print(ret)              <span class="comment">#打印客户端信息</span></span><br><span class="line">conn.send(<span class="string">b'hi'</span>)        <span class="comment">#向客户端发送信息</span></span><br><span class="line">conn.close()       <span class="comment">#关闭客户端套接字</span></span><br><span class="line">sk.close()        <span class="comment">#关闭服务器套接字(可选)</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）</strong></p>
<p><strong>server端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">sk.bind((<span class="string">'192.168.21.36'</span>,<span class="number">9000</span>))</span><br><span class="line">sk.listen()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr = sk.accept()  <span class="comment"># 接收连接 三次握手conn</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        inp = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">        <span class="keyword">if</span> inp == <span class="string">'q'</span>:</span><br><span class="line">            conn.send(inp.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        conn.send(inp.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        msg = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">b'q'</span>:<span class="keyword">break</span></span><br><span class="line">        print(msg.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    conn.close()    <span class="comment"># 四次挥手</span></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p><strong>client端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = sk.recv(<span class="number">1024</span>)</span><br><span class="line">    print(msg.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">b'q'</span>:<span class="keyword">break</span></span><br><span class="line">    inp = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">'q'</span>:</span><br><span class="line">        sk.send(inp.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sk.send(inp.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<h3 id="二、基于UDP协议的socket"><a href="#二、基于UDP协议的socket" class="headerlink" title="二、基于UDP协议的socket"></a>二、基于UDP协议的socket</h3><p><strong>udp是无链接的，启动服务之后可以直接接受消息，不需要提前建立链接</strong></p>
<h4 id="1、简单使用"><a href="#1、简单使用" class="headerlink" title="1、简单使用"></a>1、简单使用</h4><p><strong>server端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">udp_sk = socket.socket(type=socket.SOCK_DGRAM)   <span class="comment">#创建一个服务器的套接字</span></span><br><span class="line">udp_sk.bind((<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>))        <span class="comment">#绑定服务器套接字</span></span><br><span class="line">msg,addr = udp_sk.recvfrom(<span class="number">1024</span>)</span><br><span class="line">print(msg)</span><br><span class="line">udp_sk.sendto(<span class="string">b'hi'</span>,addr)                 <span class="comment"># 对话(接收与发送)</span></span><br><span class="line">udp_sk.close()                         <span class="comment"># 关闭服务器套接字</span></span><br></pre></td></tr></table></figure>

<p><strong>client端</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>)</span><br><span class="line">udp_sk=socket.socket(type=socket.SOCK_DGRAM)</span><br><span class="line">udp_sk.sendto(<span class="string">b'hello'</span>,ip_port)</span><br><span class="line">back_msg,addr=udp_sk.recvfrom(<span class="number">1024</span>)</span><br><span class="line">print(back_msg.decode(<span class="string">'utf-8'</span>),addr)</span><br></pre></td></tr></table></figure>

<h4 id="2、qq聊天"><a href="#2、qq聊天" class="headerlink" title="2、qq聊天"></a>2、qq聊天</h4><p><strong>server</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8081</span>)</span><br><span class="line">udp_server_sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">udp_server_sock.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    qq_msg,addr=udp_server_sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">'来自[%s:%s]的一条消息:\033[1;44m%s\033[0m'</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>],qq_msg.decode(<span class="string">'utf-8'</span>)))</span><br><span class="line">    back_msg=input(<span class="string">'回复消息: '</span>).strip()</span><br><span class="line"></span><br><span class="line">    udp_server_sock.sendto(back_msg.encode(<span class="string">'utf-8'</span>),addr)</span><br></pre></td></tr></table></figure>

<p><strong>client</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">udp_client_socket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">qq_name_dic=&#123;</span><br><span class="line">    <span class="string">'金老板'</span>:(<span class="string">'127.0.0.1'</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">'哪吒'</span>:(<span class="string">'127.0.0.1'</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">'egg'</span>:(<span class="string">'127.0.0.1'</span>,<span class="number">8081</span>),</span><br><span class="line">    <span class="string">'yuan'</span>:(<span class="string">'127.0.0.1'</span>,<span class="number">8081</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    qq_name=input(<span class="string">'请选择聊天对象: '</span>).strip()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        msg=input(<span class="string">'请输入消息,回车发送,输入q结束和他的聊天: '</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">'q'</span>:<span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg <span class="keyword">or</span> <span class="keyword">not</span> qq_name <span class="keyword">or</span> qq_name <span class="keyword">not</span> <span class="keyword">in</span> qq_name_dic:<span class="keyword">continue</span></span><br><span class="line">        udp_client_socket.sendto(msg.encode(<span class="string">'utf-8'</span>),qq_name_dic[qq_name])</span><br><span class="line"></span><br><span class="line">        back_msg,addr=udp_client_socket.recvfrom(BUFSIZE)</span><br><span class="line">        print(<span class="string">'来自[%s:%s]的一条消息:\033[1;44m%s\033[0m'</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>],back_msg.decode(<span class="string">'utf-8'</span>)))</span><br><span class="line"></span><br><span class="line">udp_client_socket.close()</span><br></pre></td></tr></table></figure>

<h4 id="3、时间服务器"><a href="#3、时间服务器" class="headerlink" title="3、时间服务器"></a>3、时间服务器</h4><p><strong>server</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> strftime</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">9000</span>)</span><br><span class="line">bufsize = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">tcp_server = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">tcp_server.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">tcp_server.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg, addr = tcp_server.recvfrom(bufsize)</span><br><span class="line">    print(<span class="string">'===&gt;'</span>, msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">        time_fmt = <span class="string">'%Y-%m-%d %X'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        time_fmt = msg.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    back_msg = strftime(time_fmt)</span><br><span class="line"></span><br><span class="line">    tcp_server.sendto(back_msg.encode(<span class="string">'utf-8'</span>), addr)</span><br><span class="line"></span><br><span class="line">tcp_server.close()</span><br></pre></td></tr></table></figure>

<p><strong>client</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">tcp_client=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">'请输入时间格式(例%Y %m %d)&gt;&gt;: '</span>).strip()</span><br><span class="line">    tcp_client.sendto(msg.encode(<span class="string">'utf-8'</span>),ip_port)</span><br><span class="line"></span><br><span class="line">    data=tcp_client.recv(bufsize)</span><br></pre></td></tr></table></figure>

<h3 id="三、socket参数的详解"><a href="#三、socket参数的详解" class="headerlink" title="三、socket参数的详解"></a>三、socket参数的详解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.socket(family=AF_INET,type=SOCK_STREAM,proto=<span class="number">0</span>,fileno=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>创建socket对象的参数说明：</p>
<table>
<thead>
<tr>
<th><strong>family</strong></th>
<th>地址系列应为AF_INET(默认值),AF_INET6,AF_UNIX,AF_CAN或AF_RDS。 （AF_UNIX 域实际上是使用本地 socket 文件来通信）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>type</strong></td>
<td>套接字类型应为SOCK_STREAM(默认值),SOCK_DGRAM,SOCK_RAW或其他SOCK_常量之一。 <strong>SOCK_STREAM</strong> 是基于TCP的，有保障的（即能保证数据正确传送到对方）面向连接的SOCKET，多用于资料传送。  <strong>SOCK_DGRAM</strong> 是基于UDP的，无保障的面向消息的socket，多用于在网络上发广播信息。</td>
</tr>
<tr>
<td><strong>proto</strong></td>
<td>协议号通常为零,可以省略,或者在地址族为AF_CAN的情况下,协议应为CAN_RAW或CAN_BCM之一。</td>
</tr>
<tr>
<td><strong>fileno</strong></td>
<td>如果指定了fileno,则其他参数将被忽略,导致带有指定文件描述符的套接字返回。 与socket.fromfd()不同,fileno将返回相同的套接字,而不是重复的。 这可能有助于使用socket.close()关闭一个独立的插座。</td>
</tr>
</tbody></table>
<h2 id="（五）黏包"><a href="#（五）黏包" class="headerlink" title="（五）黏包"></a>（五）黏包</h2><h3 id="一、黏包现象"><a href="#一、黏包现象" class="headerlink" title="一、黏包现象"></a>一、黏包现象</h3><p>让我们基于tcp先制作一个远程执行命令的程序（命令ls -l ; lllllll ; pwd）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server 下发命令</span></span><br><span class="line"><span class="comment"># client 执行命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh协议</span></span><br><span class="line"><span class="comment"># import os</span></span><br><span class="line"><span class="comment"># ret = os.popen('ls').read()</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="comment"># 内置模块 和os模块的功能有相似之处</span></span><br><span class="line"><span class="comment"># 能执行操作系统的命令的功能</span></span><br><span class="line">ret = subprocess.Popen(<span class="string">'dir'</span>,    <span class="comment"># 要执行的命令</span></span><br><span class="line">                       shell=<span class="literal">True</span>,  <span class="comment"># 表示要执行的是一条系统命令</span></span><br><span class="line">                       stdout=subprocess.PIPE, <span class="comment"># 存储执行结果的正常信息</span></span><br><span class="line">                       stderr=subprocess.PIPE) <span class="comment"># 存储执行结果的错误信息</span></span><br><span class="line">print(<span class="string">'stdout : '</span>,ret.stdout.read().decode(<span class="string">'gbk'</span>))</span><br><span class="line">print(<span class="string">'stderr : '</span>,ret.stderr.read().decode(<span class="string">'gbk'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 的结果的编码是以当前所在的系统为准的，如果是windows，那么res.stdout.read()读出的就是GBK编码的，在接收端需要用GBK解码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 且只能从管道里读一次结果</span></span><br></pre></td></tr></table></figure>

<p>同时执行多条命令之后，得到的结果很可能只有一部分，在执行其他命令的时候又接收到之前执行的另外一部分结果，这种显现就是黏包。</p>
<h4 id="1、基于tcp协议实现的黏包"><a href="#1、基于tcp协议实现的黏包" class="headerlink" title="1、基于tcp协议实现的黏包"></a>1、基于tcp协议实现的黏包</h4><p><strong>tcp - server</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>)</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=tcp_socket_server.accept()</span><br><span class="line">    print(<span class="string">'客户端'</span>,addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd=conn.recv(BUFSIZE)</span><br><span class="line">        <span class="keyword">if</span> len(cmd) == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">'utf-8'</span>),shell=<span class="literal">True</span>,</span><br><span class="line">                         stdout=subprocess.PIPE,</span><br><span class="line">                         stdin=subprocess.PIPE,</span><br><span class="line">                         stderr=subprocess.PIPE)</span><br><span class="line"></span><br><span class="line">        stderr=res.stderr.read()</span><br><span class="line">        stdout=res.stdout.read()</span><br><span class="line">        conn.send(stderr)</span><br><span class="line">        conn.send(stdout)</span><br></pre></td></tr></table></figure>

<p><strong>tcp - client</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> len(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">'quit'</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    act_res=s.recv(BUFSIZE)</span><br><span class="line"></span><br><span class="line">    print(act_res.decode(<span class="string">'utf-8'</span>),end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2、基于udp协议实现的黏包"><a href="#2、基于udp协议实现的黏包" class="headerlink" title="2、基于udp协议实现的黏包"></a>2、基于udp协议实现的黏包</h4><p><strong>udp - server</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">udp_server=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line">udp_server.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">udp_server.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#收消息</span></span><br><span class="line">    cmd,addr=udp_server.recvfrom(bufsize)</span><br><span class="line">    print(<span class="string">'用户命令-----&gt;'</span>,cmd)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#逻辑处理</span></span><br><span class="line">    res=subprocess.Popen(cmd.decode(<span class="string">'utf-8'</span>),shell=<span class="literal">True</span>,stderr=subprocess.PIPE,stdin=subprocess.PIPE,stdout=subprocess.PIPE)</span><br><span class="line">    stderr=res.stderr.read()</span><br><span class="line">    stdout=res.stdout.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#发消息</span></span><br><span class="line">    udp_server.sendto(stderr,addr)</span><br><span class="line">    udp_server.sendto(stdout,addr)</span><br><span class="line">udp_server.close()</span><br></pre></td></tr></table></figure>

<p><strong>udp - client</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>)</span><br><span class="line">bufsize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">udp_client=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    udp_client.sendto(msg.encode(<span class="string">'utf-8'</span>),ip_port)</span><br><span class="line">    err,addr=udp_client.recvfrom(bufsize)</span><br><span class="line">    out,addr=udp_client.recvfrom(bufsize)</span><br><span class="line">    <span class="keyword">if</span> err:</span><br><span class="line">        print(<span class="string">'error : %s'</span>%err.decode(<span class="string">'utf-8'</span>),end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> out:</span><br><span class="line">        print(out.decode(<span class="string">'utf-8'</span>), end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：只有TCP有粘包现象，UDP永远不会粘包</strong></p>
<h3 id="二、黏包成因"><a href="#二、黏包成因" class="headerlink" title="二、黏包成因"></a>二、黏包成因</h3><h4 id="1、TCP协议中的数据传递"><a href="#1、TCP协议中的数据传递" class="headerlink" title="1、TCP协议中的数据传递"></a>1、TCP协议中的数据传递</h4><p><strong>（1）tcp协议的拆包机制</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。 </span><br><span class="line">MTU是Maximum Transmission Unit的缩写。意思是网络上传送的最大数据包。MTU的单位是字节。 大部分网络设备的MTU都是1500。如果本机的MTU比网关的MTU大，大的数据包就会被拆开来传送，这样会产生很多数据包碎片，增加丢包率，降低网络速度。</span><br></pre></td></tr></table></figure>

<p><strong>（2）面向流的通信特点和Nagle算法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。</span><br><span class="line">收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。</span><br><span class="line">这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。 </span><br><span class="line">对于空消息：tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），也可以被发送，udp协议会帮你封装上消息头发送过去。 </span><br><span class="line">可靠黏包的tcp协议：tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。</span><br></pre></td></tr></table></figure>

<p><strong>（3）基于tcp协议特点的黏包现象成因</strong></p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/8.png" alt></p>
<p>​        例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束</p>
<p>​        此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。</p>
<h4 id="2、UDP不会发生黏包"><a href="#2、UDP不会发生黏包" class="headerlink" title="2、UDP不会发生黏包"></a>2、UDP不会发生黏包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。 </span><br><span class="line">不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是有消息保护边界的。 </span><br><span class="line">对于空消息：tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），也可以被发送，udp协议会帮你封装上消息头发送过去。 </span><br><span class="line">不可靠不黏包的udp协议：udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠。</span><br></pre></td></tr></table></figure>

<p><strong><em>补充：udp和tcp一次发送数据长度的限制</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用UDP协议发送时，用sendto函数最大能发送数据的长度为：65535- IP头(20) – UDP头(8)＝65507字节。用sendto函数发送数据时，如果发送数据长度大于该值，则函数会返回错误。（丢弃这个包，不进行发送） </span><br><span class="line"></span><br><span class="line"> 用TCP协议发送时，由于TCP是数据流协议，因此不存在包大小的限制（暂不考虑缓冲区的大小），这是指在用send函数时，数据长度参数不受限制。而实际上，所指定的这段数据并不一定会一次性发送出去，如果这段数据比较长，会被分段发送，如果比较短，可能会等待和下一次数据一起发送。</span><br></pre></td></tr></table></figure>

<h4 id="3、会发生黏包的两种情况"><a href="#3、会发生黏包的两种情况" class="headerlink" title="3、会发生黏包的两种情况"></a>3、会发生黏包的两种情况</h4><p><strong>（1）情况一：发送方的缓存机制</strong></p>
<p>发送端需要等缓冲区满才发送出去，造成黏包（发送数据时间间隔很短，数据很小，会合到一起，产生黏包）</p>
<p>服务端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr=tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data1=conn.recv(<span class="number">10</span>)</span><br><span class="line">data2=conn.recv(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-----&gt;'</span>,data1.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(<span class="string">'-----&gt;'</span>,data2.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.send(<span class="string">'hello'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">s.send(<span class="string">'egg'</span>.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>

<p><strong>（2）情况二：接收方的缓存机制</strong></p>
<p>接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包） </p>
<p>服务端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">tcp_socket_server=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">tcp_socket_server.bind(ip_port)</span><br><span class="line">tcp_socket_server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn,addr=tcp_socket_server.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data1=conn.recv(<span class="number">2</span>) <span class="comment">#一次没有收完整</span></span><br><span class="line">data2=conn.recv(<span class="number">10</span>)<span class="comment">#下次收的时候,会先取旧的数据,然后取新的</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'-----&gt;'</span>,data1.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(<span class="string">'-----&gt;'</span>,data2.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE=<span class="number">1024</span></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex(ip_port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.send(<span class="string">'hello egg'</span>.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>

<h4 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h4><p>黏包现象只发生在tcp协议中：</p>
<p>1.从表面上看，黏包问题主要是因为发送方和接收方的缓存机制、tcp协议面向流通信的特点。</p>
<p>2.实际上，<strong>主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">为什么会出现黏包现象？</span><br><span class="line">首先只有在TCP协议中才会出现黏包现象</span><br><span class="line">是因为TCP协议是面向流的协议</span><br><span class="line">在发送的数据传输的过程中还有缓存机制来避免数据流失</span><br><span class="line">因此 在连续发送小数据的时候 以及接收大小不符的时候都容易出现黏包现象</span><br><span class="line">本质还是因为我们在接受数据的时候不知道发送的数据的长短</span><br><span class="line"></span><br><span class="line">解决黏包问题：</span><br><span class="line">1、在传输大量数据之前先告诉接收端要发送的数据的大小</span><br><span class="line">2、如果想要更漂亮地解决问题，可以通过struct模块来实现</span><br></pre></td></tr></table></figure>

<h3 id="三、黏包的解决方案"><a href="#三、黏包的解决方案" class="headerlink" title="三、黏包的解决方案"></a>三、黏包的解决方案</h3><h4 id="1、解决方案一"><a href="#1、解决方案一" class="headerlink" title="1、解决方案一"></a>1、解决方案一</h4><p>​        问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据。</p>
<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/9.png" alt></p>
<p>服务端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line">sk.listen()</span><br><span class="line">conn, addr = sk.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">'q'</span>:</span><br><span class="line">        conn.send(<span class="string">b'q'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    conn.send(cmd.encode(<span class="string">'utf-8'</span>))  <span class="comment">#</span></span><br><span class="line">    num = conn.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    conn.send(<span class="string">b'ok'</span>)</span><br><span class="line">    res = conn.recv(int(num)).decode(<span class="string">'utf-8'</span>)   <span class="comment">#</span></span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>) <span class="comment">#</span></span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    res = subprocess.Popen(cmd, shell=<span class="literal">True</span>,</span><br><span class="line">                           stdout=subprocess.PIPE,</span><br><span class="line">                           stderr=subprocess.PIPE)</span><br><span class="line">    std_out = res.stdout.read()</span><br><span class="line">    std_err = res.stderr.read()</span><br><span class="line"></span><br><span class="line">    sk.send(str(len(std_out) + len(std_err)).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    sk.recv(<span class="number">1024</span>)   <span class="comment"># ok</span></span><br><span class="line">    sk.send(std_out)</span><br><span class="line">    sk.send(std_err)</span><br><span class="line"></span><br><span class="line">sk.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好处：确定了我到底要接收多大的数据</span></span><br><span class="line">        <span class="comment"># 要在文件中配置一个配置项：就是每一次recv的大小  buffer = 4096</span></span><br><span class="line">        <span class="comment"># 当我们要发送大数据的时候，要明确的告诉接收方要发送多大的数据，以便接收方能够准确的接收到所有的数据</span></span><br><span class="line">        <span class="comment"># 多用在文件传输的过程中</span></span><br><span class="line">            <span class="comment"># 大文件的传输 一定是按照字节读，每一次读固定的字节</span></span><br><span class="line">            <span class="comment"># 传输的过程中 一边读一边传， 接收端一边收一边写</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺点：多了一次交互，会产生额外的网络延迟</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存在的问题：</span><br><span class="line">程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗</span><br></pre></td></tr></table></figure>

<h4 id="2、解决方案进阶"><a href="#2、解决方案进阶" class="headerlink" title="2、解决方案进阶"></a>2、解决方案进阶</h4><p>刚刚的方法，问题在于我们我们在发送</p>
<p>我们可以借助一个模块，这个模块可以把要发送的数据长度转换成固定长度的字节。这样客户端每次接收消息之前只要先接受这个固定长度字节的内容看一看接下来要接收的信息大小，那么最终接受的数据只要达到这个值就停止，就能刚好不多不少的接收完整的数据了。</p>
<h5 id="（1）struct模块"><a href="#（1）struct模块" class="headerlink" title="（1）struct模块"></a>（1）struct模块</h5><p>该模块可以把一个类型，如数字，转成固定长度的bytes</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; struct.pack(&apos;i&apos;,1111111111111)</span><br><span class="line"></span><br><span class="line">struct.error: &apos;i&apos; format requires -2147483648 &lt;= number &lt;= 2147483647 #这个是范围</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/suliangxu/MyHexoPicture/master/python%E5%85%A8%E6%A0%88/%E7%AC%AC01%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%2B%E6%A8%A1%E5%9D%97%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/10.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们在网络上传输的所有数据都叫做 数据包</span><br><span class="line">数据包里所有的数据都叫 报文</span><br><span class="line">报文里不止有数据， 还有ip地址 mac地址 端口号</span><br><span class="line">所有报文都有报头</span><br><span class="line">一般所有协议都有报头：接收多少个字节...</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json,struct</span><br><span class="line"><span class="comment">#假设通过客户端上传1T:1073741824000的文件a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为避免粘包,必须自定制报头</span></span><br><span class="line">header=&#123;<span class="string">'file_size'</span>:<span class="number">1073741824000</span>,<span class="string">'file_name'</span>:<span class="string">'/a/b/c/d/e/a.txt'</span>,<span class="string">'md5'</span>:<span class="string">'8f6fbf8347faa4924a76856701edb0f3'</span>&#125; <span class="comment">#1T数据,文件路径和md5值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了该报头能传送,需要序列化并且转为bytes</span></span><br><span class="line">head_bytes=bytes(json.dumps(header),encoding=<span class="string">'utf-8'</span>) <span class="comment">#序列化并转成bytes,用于传输</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节</span></span><br><span class="line">head_len_bytes=struct.pack(<span class="string">'i'</span>,len(head_bytes)) <span class="comment">#这4个字节里只包含了一个数字,该数字是报头的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端开始发送</span></span><br><span class="line">conn.send(head_len_bytes) <span class="comment">#先发报头的长度,4个bytes</span></span><br><span class="line">conn.send(head_bytes) <span class="comment">#再发报头的字节格式</span></span><br><span class="line">conn.sendall(文件内容) <span class="comment">#然后发真实内容的字节格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务端开始接收</span></span><br><span class="line">head_len_bytes=s.recv(<span class="number">4</span>) <span class="comment">#先收报头4个bytes,得到报头长度的字节格式</span></span><br><span class="line">x=struct.unpack(<span class="string">'i'</span>,head_len_bytes)[<span class="number">0</span>] <span class="comment">#提取报头的长度</span></span><br><span class="line"></span><br><span class="line">head_bytes=s.recv(x) <span class="comment">#按照报头长度x,收取报头的bytes格式</span></span><br><span class="line">header=json.loads(json.dumps(header)) <span class="comment">#提取报头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后根据报头的内容提取真实的数据,比如</span></span><br><span class="line">real_data_len=s.recv(header[<span class="string">'file_size'</span>])</span><br><span class="line">s.recv(real_data_len)</span><br></pre></td></tr></table></figure>

<p>关于struct的详细用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="comment">#http://www.cnblogs.com/coser/archive/2011/12/17/2291160.html</span></span><br><span class="line">__author__ = <span class="string">'Linhaifeng'</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">values1 = (<span class="number">1</span>, <span class="string">'abc'</span>.encode(<span class="string">'utf-8'</span>), <span class="number">2.7</span>)</span><br><span class="line">values2 = (<span class="string">'defg'</span>.encode(<span class="string">'utf-8'</span>),<span class="number">101</span>)</span><br><span class="line">s1 = struct.Struct(<span class="string">'I3sf'</span>)</span><br><span class="line">s2 = struct.Struct(<span class="string">'4sI'</span>)</span><br><span class="line"></span><br><span class="line">print(s1.size,s2.size)</span><br><span class="line">prebuffer=ctypes.create_string_buffer(s1.size+s2.size)</span><br><span class="line">print(<span class="string">'Before : '</span>,binascii.hexlify(prebuffer))</span><br><span class="line"><span class="comment"># t=binascii.hexlify('asdfaf'.encode('utf-8'))</span></span><br><span class="line"><span class="comment"># print(t)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1.pack_into(prebuffer,<span class="number">0</span>,*values1)</span><br><span class="line">s2.pack_into(prebuffer,s1.size,*values2)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'After pack'</span>,binascii.hexlify(prebuffer))</span><br><span class="line">print(s1.unpack_from(prebuffer,<span class="number">0</span>))</span><br><span class="line">print(s2.unpack_from(prebuffer,s1.size))</span><br><span class="line"></span><br><span class="line">s3=struct.Struct(<span class="string">'ii'</span>)</span><br><span class="line">s3.pack_into(prebuffer,<span class="number">0</span>,<span class="number">123</span>,<span class="number">123</span>)</span><br><span class="line">print(<span class="string">'After pack'</span>,binascii.hexlify(prebuffer))</span><br><span class="line">print(s3.unpack_from(prebuffer,<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<h5 id="（2）使用struct解决黏包"><a href="#（2）使用struct解决黏包" class="headerlink" title="（2）使用struct解决黏包"></a>（2）使用struct解决黏包</h5><p>借助struct模块，我们知道长度数字可以被转换成一个标准大小的4字节数字。因此可以利用这个特点来预先发送数据长度。</p>
<table>
<thead>
<tr>
<th>发送时</th>
<th>接收时</th>
</tr>
</thead>
<tbody><tr>
<td>先发送struct转换好的数据长度4字节</td>
<td>先接受4个字节使用struct转换成数字来获取要接收的数据长度</td>
</tr>
<tr>
<td>再发送数据</td>
<td>再按照长度接收数据</td>
</tr>
</tbody></table>
<h6 id="a-简单版："><a href="#a-简单版：" class="headerlink" title="(a)简单版："></a>(a)简单版：</h6><p>server</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line">sk.listen()</span><br><span class="line">conn, addr = sk.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">'q'</span>:</span><br><span class="line">        conn.send(<span class="string">b'q'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    conn.send(cmd.encode(<span class="string">'utf-8'</span>))  <span class="comment">#</span></span><br><span class="line">    num = conn.recv(<span class="number">4</span>)</span><br><span class="line">    num = struct.unpack(<span class="string">'i'</span>, num)[<span class="number">0</span>]</span><br><span class="line">    res = conn.recv(int(num)).decode(<span class="string">'utf-8'</span>)   <span class="comment">#</span></span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>client</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>) <span class="comment">#</span></span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    res = subprocess.Popen(cmd, shell=<span class="literal">True</span>,</span><br><span class="line">                           stdout=subprocess.PIPE,</span><br><span class="line">                           stderr=subprocess.PIPE)</span><br><span class="line">    std_out = res.stdout.read()</span><br><span class="line">    std_err = res.stderr.read()</span><br><span class="line"></span><br><span class="line">    len_num = len(std_out) + len(std_err)</span><br><span class="line">    num_by = struct.pack(<span class="string">'i'</span>, len_num)</span><br><span class="line">    sk.send(num_by)</span><br><span class="line">    sk.send(std_out)</span><br><span class="line">    sk.send(std_err)</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<h6 id="b-复杂版："><a href="#b-复杂版：" class="headerlink" title="(b)复杂版："></a>(b)复杂版：</h6><p>服务端（自定制报头）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,struct,json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>) <span class="comment">#就是它，在bind前加</span></span><br><span class="line"></span><br><span class="line">phone.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">phone.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=phone.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'cmd: %s'</span> %cmd)</span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">'utf-8'</span>),</span><br><span class="line">                             shell=<span class="literal">True</span>,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        print(err)</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            back_msg=err</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            back_msg=res.stdout.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(<span class="string">'i'</span>,len(back_msg))) <span class="comment">#先发back_msg的长度</span></span><br><span class="line">        conn.sendall(back_msg) <span class="comment">#在发真实的内容</span></span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端（自定制报头）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> socket,time,struct</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">res=s.connect_ex((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> len(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">'quit'</span>:<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    l=s.recv(<span class="number">4</span>)</span><br><span class="line">    x=struct.unpack(<span class="string">'i'</span>,l)[<span class="number">0</span>]</span><br><span class="line">    print(type(x),x)</span><br><span class="line">    <span class="comment"># print(struct.unpack('I',l))</span></span><br><span class="line">    r_s=<span class="number">0</span></span><br><span class="line">    data=<span class="string">b''</span></span><br><span class="line">    <span class="keyword">while</span> r_s &lt; x:</span><br><span class="line">        r_d=s.recv(<span class="number">1024</span>)</span><br><span class="line">        data+=r_d</span><br><span class="line">        r_s+=len(r_d)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(data.decode('utf-8'))</span></span><br><span class="line">    print(data.decode(<span class="string">'gbk'</span>)) <span class="comment">#windows默认gbk编码</span></span><br></pre></td></tr></table></figure>

<h6 id="c-更复杂版"><a href="#c-更复杂版" class="headerlink" title="(c)更复杂版"></a>(c)更复杂版</h6><p>我们还可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了）</p>
<table>
<thead>
<tr>
<th>发送时</th>
<th>接收时</th>
</tr>
</thead>
<tbody><tr>
<td>先发报头长度</td>
<td>先收报头长度，用struct取出来</td>
</tr>
<tr>
<td>再编码报头内容然后发送</td>
<td>根据取出的长度收取报头内容，然后解码，反序列化</td>
</tr>
<tr>
<td>最后发真实内容</td>
<td>从反序列化的结果中取出待取数据的详细信息，然后去取真实的数据内容</td>
</tr>
</tbody></table>
<p>服务端（定制稍微复杂一点的报头）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,struct,json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">phone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>) <span class="comment">#就是它，在bind前加</span></span><br><span class="line"></span><br><span class="line">phone.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">phone.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn,addr=phone.accept()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cmd=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">break</span></span><br><span class="line">        print(<span class="string">'cmd: %s'</span> %cmd)</span><br><span class="line"></span><br><span class="line">        res=subprocess.Popen(cmd.decode(<span class="string">'utf-8'</span>),</span><br><span class="line">                             shell=<span class="literal">True</span>,</span><br><span class="line">                             stdout=subprocess.PIPE,</span><br><span class="line">                             stderr=subprocess.PIPE)</span><br><span class="line">        err=res.stderr.read()</span><br><span class="line">        print(err)</span><br><span class="line">        <span class="keyword">if</span> err:</span><br><span class="line">            back_msg=err</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            back_msg=res.stdout.read()</span><br><span class="line"></span><br><span class="line">        headers=&#123;<span class="string">'data_size'</span>:len(back_msg)&#125;</span><br><span class="line">        head_json=json.dumps(headers)</span><br><span class="line">        head_json_bytes=bytes(head_json,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">        conn.send(struct.pack(<span class="string">'i'</span>,len(head_json_bytes))) <span class="comment">#先发报头的长度</span></span><br><span class="line">        conn.send(head_json_bytes) <span class="comment">#再发报头</span></span><br><span class="line">        conn.sendall(back_msg) <span class="comment">#在发真实的内容</span></span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct,json</span><br><span class="line"></span><br><span class="line">ip_port=(<span class="string">'127.0.0.1'</span>,<span class="number">8080</span>)</span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd=input(<span class="string">'&gt;&gt;: '</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cmd:<span class="keyword">continue</span></span><br><span class="line">    client.send(bytes(cmd,encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    head=client.recv(<span class="number">4</span>)</span><br><span class="line">    head_json_len=struct.unpack(<span class="string">'i'</span>,head)[<span class="number">0</span>]</span><br><span class="line">    head_json=json.loads(client.recv(head_json_len).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    data_len=head_json[<span class="string">'data_size'</span>]</span><br><span class="line"></span><br><span class="line">    recv_size=<span class="number">0</span></span><br><span class="line">    recv_data=<span class="string">b''</span></span><br><span class="line">    <span class="keyword">while</span> recv_size &lt; data_len:</span><br><span class="line">        recv_data+=client.recv(<span class="number">1024</span>)</span><br><span class="line">        recv_size+=len(recv_data)</span><br><span class="line"></span><br><span class="line">    print(recv_data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="comment">#print(recv_data.decode('gbk')) #windows默认gbk编码</span></span><br></pre></td></tr></table></figure>

<h4 id="3、FTP作业：上传下载文件"><a href="#3、FTP作业：上传下载文件" class="headerlink" title="3、FTP作业：上传下载文件"></a>3、FTP作业：上传下载文件</h4><p>服务端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8090</span>))</span><br><span class="line">buffer = <span class="number">1024</span></span><br><span class="line">sk.listen()</span><br><span class="line"></span><br><span class="line">conn, addr = sk.accept()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收端</span></span><br><span class="line">head_len = conn.recv(<span class="number">4</span>)</span><br><span class="line">head_len = struct.unpack(<span class="string">'i'</span>, head_len)[<span class="number">0</span>]</span><br><span class="line">json_head = conn.recv(head_len).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">head = json.loads(json_head)</span><br><span class="line"></span><br><span class="line">filesize = head[<span class="string">'filesize'</span>]</span><br><span class="line"><span class="keyword">with</span> open(head[<span class="string">'filename'</span>], <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> filesize:</span><br><span class="line">        <span class="keyword">if</span> filesize &gt;= buffer:</span><br><span class="line">            content = conn.recv(buffer)</span><br><span class="line">            f.write(content)</span><br><span class="line">            filesize -= buffer</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            content = conn.recv(filesize)</span><br><span class="line">            f.write(content)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8090</span>))</span><br><span class="line"></span><br><span class="line">buffer = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送文件</span></span><br><span class="line">head = &#123;<span class="string">'filepath'</span>: <span class="string">r'D:\视频存放位置\day18'</span>,</span><br><span class="line">        <span class="string">'filename'</span>: <span class="string">r'04 python fullstack s9 day18 re模块。mp4'</span>,</span><br><span class="line">        <span class="string">'filesize'</span>: <span class="literal">None</span>&#125;</span><br><span class="line">file_path = os.path.join(head[<span class="string">'filepath'</span>], head[<span class="string">'filename'</span>])</span><br><span class="line">filesize = os.path.getsize(file_path)</span><br><span class="line">head[<span class="string">'filesize'</span>] = filesize</span><br><span class="line"></span><br><span class="line">json_head = json.dump(head)     <span class="comment"># 字典转成了字符串</span></span><br><span class="line">bytes_head = json_head.encode(<span class="string">'utf-8'</span>)      <span class="comment"># 字符串转bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算head的长度</span></span><br><span class="line">head_len = len(bytes_head)      <span class="comment"># 报头长度</span></span><br><span class="line">pack_len = struct.pack(<span class="string">'i'</span>, head_len)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sk.send(pack_len)       <span class="comment"># 先发报头长度</span></span><br><span class="line">sk.send(bytes_head)     <span class="comment"># 再发送bytes类型的报头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(file_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> filesize:</span><br><span class="line">        <span class="keyword">if</span> filesize &gt;= buffer:</span><br><span class="line">            content = f.read(buffer)    <span class="comment"># 每次读出的内容</span></span><br><span class="line">            sk.send(content)</span><br><span class="line">            filesize -= buffer</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            content = f.read(filesize)</span><br><span class="line">            sk.send(content)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<h2 id="（六）socket的更多方法介绍"><a href="#（六）socket的更多方法介绍" class="headerlink" title="（六）socket的更多方法介绍"></a>（六）socket的更多方法介绍</h2><h3 id="一、更多方法"><a href="#一、更多方法" class="headerlink" title="一、更多方法"></a>一、更多方法</h3><p><strong>服务端套接字函数</strong><br>s.bind()    绑定(主机,端口号)到套接字<br>s.listen()  开始TCP监听<br>s.accept()  被动接受TCP客户的连接,(阻塞式)等待连接的到来</p>
<p><strong>客户端套接字函数</strong><br>s.connect()     主动初始化TCP服务器连接<br>s.connect_ex()  connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</p>
<p><strong>公共用途的套接字函数</strong><br>s.recv()            接收TCP数据<br>s.send()            发送TCP数据<br>s.sendall()         发送TCP数据<br>s.recvfrom()        接收UDP数据<br>s.sendto()          发送UDP数据<br>s.getpeername()     连接到当前套接字的远端的地址<br>s.getsockname()     当前套接字的地址<br>s.getsockopt()      返回指定套接字的参数<br>s.setsockopt()      设置指定套接字的参数<br>s.close()           关闭套接字</p>
<p><strong>面向锁的套接字方法</strong><br><strong>s.setblocking()     设置套接字的阻塞与非阻塞模式</strong></p>
<p>​        s.setblocking(False) 设置非阻塞模式 </p>
<p>s.settimeout()      设置阻塞套接字操作的超时时间<br>s.gettimeout()      得到阻塞套接字操作的超时时间</p>
<p><strong>面向文件的套接字的函数</strong><br>s.fileno()          套接字的文件描述符<br>s.makefile()        创建一个与该套接字相关的文件</p>
<h3 id="二、send和sendall方法"><a href="#二、send和sendall方法" class="headerlink" title="二、send和sendall方法"></a>二、send和sendall方法</h3><p>官方文档对socket模块下的socket.send()和socket.sendall()解释如下：</p>
<p>socket.send(string[, flags])<br>Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above. Returns the number of bytes sent. Applications are responsible for checking that all data has been sent; if only some of the data was transmitted, the application needs to attempt delivery of the remaining data.</p>
<p>send()的返回值是发送的字节数量，这个数量值可能小于要发送的string的字节数，也就是说可能无法发送string中所有的数据。如果有错误则会抛出异常。</p>
<p>–</p>
<p>socket.sendall(string[, flags])<br>Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above. Unlike send(), this method continues to send data from string until either all data has been sent or an error occurs. None is returned on success. On error, an exception is raised, and there is no way to determine how much data, if any, was successfully sent.</p>
<p>尝试发送string的所有数据，成功则返回None，失败则抛出异常。</p>
<p>故，下面两段代码是等价的：</p>
<p>sock.sendall(‘Hello world\n’)    # sandall 一次性发送所有数据，send 可能会有拆包现象</p>
<p>buffer = ‘Hello world\n’</p>
<p>while buffer:</p>
<p>​    bytes = sock.send(buffer)</p>
<p>​    buffer = buffer[bytes:]</p>
<h2 id="（七）验证客户端链接的合法性"><a href="#（七）验证客户端链接的合法性" class="headerlink" title="（七）验证客户端链接的合法性"></a>（七）验证客户端链接的合法性</h2><p>如果你想在分布式系统中实现一个简单的客户端链接认证功能，又不像SSL那么复杂，那么利用hmac+加盐的方式来实现</p>
<h3 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"></span><br><span class="line">secret_key = <span class="string">b'egg'</span></span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line">sk.listen()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_conn</span><span class="params">(conn)</span>:</span></span><br><span class="line">    msg = os.urandom(<span class="number">32</span>)</span><br><span class="line">    conn.send(msg)</span><br><span class="line">    h = hmac.new(secret_key, msg)</span><br><span class="line">    digest = h.digest()</span><br><span class="line">    client_digest = conn.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hmac.compare_digest(digest, client_digest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn, addr = sk.accept()</span><br><span class="line">res = check_conn(conn)</span><br><span class="line"><span class="keyword">if</span> res:</span><br><span class="line">    print(<span class="string">'合法的客户端'</span>)</span><br><span class="line">    conn.close()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'不合法的客户端'</span>)</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<h3 id="2、客户端（合法）"><a href="#2、客户端（合法）" class="headerlink" title="2、客户端（合法）"></a>2、客户端（合法）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"></span><br><span class="line">secret_key = <span class="string">b'egg'</span></span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line">msg = sk.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">h = hmac.new(secret_key, msg)</span><br><span class="line">digest = h.digest()</span><br><span class="line"></span><br><span class="line">sk.send(digest)</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<h2 id="（八）socketserver"><a href="#（八）socketserver" class="headerlink" title="（八）socketserver"></a>（八）socketserver</h2><h3 id="1、server端"><a href="#1、server端" class="headerlink" title="1、server端"></a>1、server端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyServer</span><span class="params">(socketserver.BaseRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            msg = self.request.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="keyword">if</span> msg == <span class="string">'q'</span>:</span><br><span class="line">                <span class="comment"># self.request.close()</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            print(msg)        <span class="comment"># self.request相当于一个conn</span></span><br><span class="line"></span><br><span class="line">            info = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">            self.request.send(info.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server = socketserver.ThreadingTCPServer((<span class="string">'127.0.0.1'</span>, <span class="number">8090</span>), MyServer)</span><br><span class="line"></span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure>

<h3 id="2、client"><a href="#2、client" class="headerlink" title="2、client"></a>2、client</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8090</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    sk.send((<span class="string">'user1:'</span> + msg).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    ret = sk.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    print(ret)</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/网络编程/" rel="tag"># 网络编程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/21/python全栈/第01部分：基础+模块+面向对象+网络编程/面向对象/面向对象进阶/" rel="next" title="面向对象进阶">
                <i class="fa fa-chevron-left"></i> 面向对象进阶
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/23/数据结构笔记/第一章-绪论/" rel="prev" title="第一章 绪论">
                第一章 绪论 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="John Doe">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://suliangxu.github.io" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1193135584@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#（一）楔子"><span class="nav-text">（一）楔子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（二）软件开发的架构"><span class="nav-text">（二）软件开发的架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、C-S架构"><span class="nav-text">一、C/S架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、B-S架构"><span class="nav-text">二、B/S架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（三）网络基础"><span class="nav-text">（三）网络基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、一个程序如何在网络上找到另一个程序？"><span class="nav-text">一、一个程序如何在网络上找到另一个程序？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、osi七层模型"><span class="nav-text">二、osi七层模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、引子"><span class="nav-text">1、引子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、osi七层模型"><span class="nav-text">2、osi七层模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、socket概念"><span class="nav-text">三、socket概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、socket层"><span class="nav-text">1、socket层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、理解socket"><span class="nav-text">2、理解socket</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、套接字（socket）的发展史"><span class="nav-text">四、套接字（socket）的发展史</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、基于文件类型的套接字家族"><span class="nav-text">1、基于文件类型的套接字家族</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、基于网络类型的套接字家族"><span class="nav-text">2、基于网络类型的套接字家族</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、tcp协议和udp协议"><span class="nav-text">五、tcp协议和udp协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（四）套接字（socket）初使用"><span class="nav-text">（四）套接字（socket）初使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、基于TCP协议的socket"><span class="nav-text">一、基于TCP协议的socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、基于UDP协议的socket"><span class="nav-text">二、基于UDP协议的socket</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、简单使用"><span class="nav-text">1、简单使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、qq聊天"><span class="nav-text">2、qq聊天</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、时间服务器"><span class="nav-text">3、时间服务器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、socket参数的详解"><span class="nav-text">三、socket参数的详解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（五）黏包"><span class="nav-text">（五）黏包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、黏包现象"><span class="nav-text">一、黏包现象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、基于tcp协议实现的黏包"><span class="nav-text">1、基于tcp协议实现的黏包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、基于udp协议实现的黏包"><span class="nav-text">2、基于udp协议实现的黏包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、黏包成因"><span class="nav-text">二、黏包成因</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、TCP协议中的数据传递"><span class="nav-text">1、TCP协议中的数据传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、UDP不会发生黏包"><span class="nav-text">2、UDP不会发生黏包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、会发生黏包的两种情况"><span class="nav-text">3、会发生黏包的两种情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、总结"><span class="nav-text">4、总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、黏包的解决方案"><span class="nav-text">三、黏包的解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、解决方案一"><span class="nav-text">1、解决方案一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、解决方案进阶"><span class="nav-text">2、解决方案进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）struct模块"><span class="nav-text">（1）struct模块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）使用struct解决黏包"><span class="nav-text">（2）使用struct解决黏包</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#a-简单版："><span class="nav-text">(a)简单版：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#b-复杂版："><span class="nav-text">(b)复杂版：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#c-更复杂版"><span class="nav-text">(c)更复杂版</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、FTP作业：上传下载文件"><span class="nav-text">3、FTP作业：上传下载文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（六）socket的更多方法介绍"><span class="nav-text">（六）socket的更多方法介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、更多方法"><span class="nav-text">一、更多方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、send和sendall方法"><span class="nav-text">二、send和sendall方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（七）验证客户端链接的合法性"><span class="nav-text">（七）验证客户端链接的合法性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、服务端"><span class="nav-text">1、服务端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、客户端（合法）"><span class="nav-text">2、客户端（合法）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（八）socketserver"><span class="nav-text">（八）socketserver</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、server端"><span class="nav-text">1、server端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、client"><span class="nav-text">2、client</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  



  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
